

# [Overview](https://developer.garmin.com/connect-iq/overview/)nGarmin Connect IQ 
 Menu Overview Make Your Mark
 Building unique wearable experiences leveraging Garmin device sensors and features is easy with Connect IQ. Using available APIs and ANT+ profiles, the apps you build will be exposed to millions of customers who rely on our purpose-driven devices . With a familiar language, a variety of app types and a helpful SDK, you will engage your customers in new and exciting ways. Go on, make your mark. Stay Up To Date
 Latest Version: Connect IQ 7.4.2 
 Updated: December 11, 2024 9:00 AM Get the SDK API Documentation 
 Programmer's Guide 
 How to Submit Your App 

 Build with Connect IQ
 Audio&nbsp;Content Provider&nbsp;Apps
 Data Fields
 Device Apps
 Widgets
 Watch Faces

 Audio Content Provider Apps
 Sync audio content from third-party providers
 Manage downloaded audio content
 Customize audio content playback experience

 Data Fields
 Customize built-in features
 Present activity information in a new, creative way
 Access the ANT+ sensors and ANT generic channel
 Capture, display, record and share data with FIT recording

 Device Apps
 Get extended access to the wearable device
 Read and record the FIT file
 Access accelerometer
 Access the ANT+ sensors and ANT generic channel
 Leverage GPS and sensor data
 Use BLE to communicate with mobile phones/Internet
 Capture, display, record and share data with FIT recording
 Connect to authenticated web services through OAuth

 Widgets
 Provide information at a glance
 Add custom cards to the main carousel
 Respond to user interaction and create custom interfaces
 Access the ANT+ sensors and ANT generic channel
 Leverage GPS and sensor data
 Use BLE to communicate with mobile phones/Internet
 Connect to authenticated web services through OAuth

 Watch Faces
 Customize the default watch face
 Build colorful, always-on watch faces
 Use drawing tool kit, custom fonts and custom bitmaps

 See What's Possible
 Visit the App Store Join the Community
 Receive insights, seek advice and discuss your ideas with other Connect IQ developers in our forums. Visit the Forums Stay Informed
 Join the Garmin Connect IQ developer program to be notified about new versions of the Connect IQ SDK as well as tips and tricks from the experts. Sign Up


# [Compatible Devices](https://developer.garmin.com/connect-iq/compatible-devices/)nMenu Compatible Devices × Device Type: All Watches/Wearables Outdoor Handhelds Edge Supported CIQ Version: All All 
 1.2.0 
 1.4.0 
 2.4.0 
 3.0.0 
 3.1.0 
 3.2.0 
 3.3.0 
 3.4.0 
 5.0.0 

 Watches/Wearables Screen Resolution Screen Shape Screen Technology API Level 
 Approach® S60 240 x 240 round Memory-In-Pixel (64 colors) 2.4.0 
 Approach® S62 260 x 260 round Memory-In-Pixel (64 colors) 3.0.0 
 Approach® S70 42mm 390 x 390 round AMOLED 5.0.0 
 Approach® S70 47mm 454 x 454 round AMOLED 5.0.0 
 Captain Marvel 218 x 218 round Memory-In-Pixel (64 colors) 3.3.0 
 D2™ Air 390 x 390 round AMOLED 3.2.0 
 D2™ Air X10 416 x 416 round AMOLED 5.0.0 
 D2™ Bravo 218 x 218 round Memory-In-Pixel (16 colors) 1.4.0 
 D2™ Bravo Titanium 218 x 218 round Memory-In-Pixel (16 colors) 1.4.0 
 D2™ Charlie 240 x 240 round Memory-In-Pixel (64 colors) 3.0.0 
 D2™ Delta 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 D2™ Delta PX 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 D2™ Delta S 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 D2™ Mach 1 416 x 416 round AMOLED 5.0.0 
 Darth Vader™ 260 x 260 round Memory-In-Pixel (64 colors) 3.3.0 
 Descent™ G1 / G1 Solar 176 x 176 semi-octagon Transflective Liquid-Crystal (Single Color) 3.4.0 
 Descent™ Mk1 240 x 240 round Memory-In-Pixel (64 colors) 3.0.0 
 Descent™ Mk2 / Descent™ Mk2i 280 x 280 round Memory-In-Pixel (64 colors) 3.4.0 
 Descent™ Mk2 S 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 Descent™ Mk3 43mm / Mk3i 43mm 390 x 390 round AMOLED 5.0.0 
 Descent™ Mk3i 51mm 454 x 454 round AMOLED 5.0.0 
 Enduro™ 280 x 280 round Memory-In-Pixel (64 colors) 3.4.0 
 Enduro™ 3 280 x 280 round Memory-In-Pixel (64 colors) 5.0.0 
 epix™ 205 x 148 rectangle Memory-In-Pixel (64 colors) 1.2.0 
 epix™ (Gen 2) / quatix® 7 Sapphire 416 x 416 round AMOLED 5.0.0 
 epix™ Pro (Gen 2) 42mm 390 x 390 round AMOLED 5.0.0 
 epix™ Pro (Gen 2) 47mm / quatix® 7 Pro 416 x 416 round AMOLED 5.0.0 
 epix™ Pro (Gen 2) 51mm / D2™ Mach 1 Pro / tactix® 7 – AMOLED Edition 454 x 454 round AMOLED 5.0.0 
 fēnix® 3 / tactix® Bravo / quatix® 3 218 x 218 round Memory-In-Pixel (16 colors) 1.4.0 
 fēnix® 3 HR 218 x 218 round Memory-In-Pixel (16 colors) 1.4.0 
 fēnix® 5 / quatix® 5 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 fēnix® 5 Plus 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 fēnix® 5S 218 x 218 round Memory-In-Pixel (64 colors) 3.1.0 
 fēnix® 5S Plus 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 fēnix® 5X / tactix® Charlie 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 fēnix® 5X Plus 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 fēnix® 6 / 6 Solar / 6 Dual Power 260 x 260 round Memory-In-Pixel (64 colors) 3.4.0 
 fēnix® 6 Pro / 6 Sapphire / 6 Pro Solar / 6 Pro Dual Power / quatix® 6 260 x 260 round Memory-In-Pixel (64 colors) 3.4.0 
 fēnix® 6S / 6S Solar / 6S Dual Power 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 fēnix® 6S Pro / 6S Sapphire / 6S Pro Solar / 6S Pro Dual Power 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 fēnix® 6X Pro / 6X Sapphire / 6X Pro Solar / tactix® Delta Sapphire / Delta Solar / Delta Solar - Ballistics Edition / quatix® 6X / 6X Solar / 6X Dual Power 280 x 280 round Memory-In-Pixel (64 colors) 3.4.0 
 fēnix® 7 / quatix® 7 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7 Pro 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7 Pro - Solar Edition (no Wi-Fi) 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7S 240 x 240 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7S Pro 240 x 240 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7X / tactix® 7 / quatix® 7X Solar / Enduro™ 2 280 x 280 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7X Pro 280 x 280 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 7X Pro - Solar Edition (no Wi-Fi) 280 x 280 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 8 43mm 416 x 416 round AMOLED 5.0.0 
 fēnix® 8 47mm / 51mm 454 x 454 round AMOLED 5.0.0 
 fēnix® 8 Solar 47mm 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® 8 Solar 51mm 280 x 280 round Memory-In-Pixel (64 colors) 5.0.0 
 fēnix® Chronos 218 x 218 round Memory-In-Pixel (64 colors) 3.1.0 
 fēnix® E 416 x 416 round AMOLED 5.0.0 
 First Avenger 260 x 260 round Memory-In-Pixel (64 colors) 3.3.0 
 Forerunner® 165 390 x 390 round AMOLED 5.0.0 
 Forerunner® 165 Music 390 x 390 round AMOLED 5.0.0 
 Forerunner® 230 215 x 180 semi-round Memory-In-Pixel (16 colors) 1.4.0 
 Forerunner® 235 215 x 180 semi-round Memory-In-Pixel (16 colors) 1.4.0 
 Forerunner® 245 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 Forerunner® 245 Music 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 Forerunner® 255 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 Forerunner® 255 Music 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 Forerunner® 255s 218 x 218 round Memory-In-Pixel (64 colors) 5.0.0 
 Forerunner® 255s Music 218 x 218 round Memory-In-Pixel (64 colors) 5.0.0 
 Forerunner® 265 416 x 416 round AMOLED 5.0.0 
 Forerunner® 265s 360 x 360 round AMOLED 5.0.0 
 Forerunner® 45 208 x 208 round Memory-In-Pixel (8 colors) 1.4.0 
 Forerunner® 55 208 x 208 round Memory-In-Pixel (8 colors) 3.4.0 
 Forerunner® 630 215 x 180 semi-round Memory-In-Pixel (16 colors) 1.4.0 
 Forerunner® 645 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 Forerunner® 645 Music 240 x 240 round Memory-In-Pixel (64 colors) 3.2.0 
 Forerunner® 735xt 215 x 180 semi-round Memory-In-Pixel (16 colors) 2.4.0 
 Forerunner® 745 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 Forerunner® 920XT 205 x 148 rectangle Memory-In-Pixel (16 colors) 1.4.0 
 Forerunner® 935 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 Forerunner® 945 240 x 240 round Memory-In-Pixel (64 colors) 3.3.0 
 Forerunner® 945 LTE 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 Forerunner® 955 / Solar 260 x 260 round Memory-In-Pixel (64 colors) 5.0.0 
 Forerunner® 965 454 x 454 round AMOLED 5.0.0 
 Garmin Swim™ 2 208 x 208 round Memory-In-Pixel (8 colors) 1.4.0 
 Instinct® 2 / Solar / Dual Power / dēzl Edition 176 x 176 semi-octagon Transflective Liquid-Crystal (Single Color) 3.4.0 
 Instinct® 2S / Solar / Dual Power 163 x 156 semi-octagon Transflective Liquid-Crystal (Single Color) 3.4.0 
 Instinct® 2X Solar 176 x 176 semi-octagon Transflective Liquid-Crystal (Single Color) 3.4.0 
 Instinct® Crossover 176 x 176 semi-octagon Transflective Liquid-Crystal (Single Color) 3.4.0 
 MARQ® (Gen 2) Athlete / Adventurer / Captain / Golfer / Carbon Edition / Commander - Carbon Edition 390 x 390 round AMOLED 5.0.0 
 MARQ® (Gen 2) Aviator 390 x 390 round AMOLED 5.0.0 
 MARQ® Adventurer 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Athlete 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Aviator 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Captain / MARQ® Captain: American Magic Edition 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Commander 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Driver 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Expedition 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 MARQ® Golfer 240 x 240 round Memory-In-Pixel (64 colors) 3.4.0 
 Rey™ 218 x 218 round Memory-In-Pixel (64 colors) 3.3.0 
 Venu® 390 x 390 round AMOLED 3.3.0 
 Venu® 2 416 x 416 round AMOLED 5.0.0 
 Venu® 2 Plus 416 x 416 round AMOLED 5.0.0 
 Venu® 2S 360 x 360 round AMOLED 5.0.0 
 Venu® 3 454 x 454 round AMOLED 5.0.0 
 Venu® 3S 390 x 390 round AMOLED 5.0.0 
 Venu® Mercedes-Benz® Collection 390 x 390 round AMOLED 3.2.0 
 Venu® Sq 240 x 240 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Venu® Sq 2 320 x 360 rectangle AMOLED 5.0.0 
 Venu® Sq 2 Music 320 x 360 rectangle AMOLED 5.0.0 
 Venu® Sq. Music Edition 240 x 240 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 vívoactive® 205 x 148 rectangle Memory-In-Pixel (64 colors) 1.4.0 
 vívoactive® 3 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 vívoactive® 3 Mercedes-Benz® Collection 240 x 240 round Memory-In-Pixel (64 colors) 3.0.0 
 vívoactive® 3 Music 240 x 240 round Memory-In-Pixel (64 colors) 3.2.0 
 vívoactive® 3 Music LTE 240 x 240 round Memory-In-Pixel (64 colors) 3.1.0 
 vívoactive® 4 260 x 260 round Memory-In-Pixel (64 colors) 3.3.0 
 vívoactive® 4S 218 x 218 round Memory-In-Pixel (64 colors) 3.3.0 
 vívoactive® 5 390 x 390 round AMOLED 5.0.0 
 vívoactive® HR 148 x 205 rectangle Memory-In-Pixel (64 colors) 2.4.0 
 Outdoor Handhelds Screen Resolution Screen Shape Screen Technology API Level 
 GPSMAP® 66s / 66i / 66sr / 66st 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.1.0 
 GPSMAP® 67 / 67i 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.2.0 
 GPSMAP® 86s / 86sc / 86i / 86sci 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.0.0 
 Montana® 7 Series 480 x 800 rectangle Transflective Liquid-Crystal (High Color) 3.2.0 
 Oregon® 7 Series 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.0.0 
 Rino® 7 Series 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.0.0 
 Edge Screen Resolution Screen Shape Screen Technology API Level 
 Edge® 1000 / Explore 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 2.4.0 
 Edge® 1030 282 x 470 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Edge® 1030 / Bontrager 282 x 470 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Edge® 1030 Plus 282 x 470 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Edge® 1040 / 1040 Solar 282 x 470 rectangle Transflective Liquid-Crystal (High Color) 5.0.0 
 Edge® 1050 480 x 800 rectangle Transflective Liquid-Crystal (High Color) 5.0.0 
 Edge® 130 230 x 303 rectangle Transflective Liquid-Crystal (Single Color) 3.1.0 
 Edge® 130 Plus 230 x 303 rectangle Transflective Liquid-Crystal (Single Color) 3.2.0 
 Edge® 520 200 x 265 rectangle Transflective Liquid-Crystal (High Color) 2.4.0 
 Edge® 520 Plus 200 x 265 rectangle Transflective Liquid-Crystal (High Color) 3.1.0 
 Edge® 530 246 x 322 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Edge® 540 / 540 Solar 246 x 322 rectangle Transflective Liquid-Crystal (High Color) 5.0.0 
 Edge® 820 / Explore 200 x 265 rectangle Transflective Liquid-Crystal (High Color) 3.1.0 
 Edge® 830 246 x 322 rectangle Transflective Liquid-Crystal (High Color) 3.3.0 
 Edge® 840 / 840 Solar 246 x 322 rectangle Transflective Liquid-Crystal (High Color) 5.0.0 
 Edge® Explore 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 3.1.0 
 Edge® Explore 2 240 x 400 rectangle Transflective Liquid-Crystal (High Color) 5.0.0


# [Get the SDK](https://developer.garmin.com/connect-iq/sdk/)nMenu Get the SDK Connect IQ SDK
 By downloading any of the following SDKs, you accept our license agreement. Updated August 6, 2024 This Connect IQ Developer Agreement (the " Agreement ") between you and, if applicable, your company (" you " or " your ") and Garmin International, Inc. and its affiliates (" Garmin ") governs your use of the SDK and other Program Materials to develop Applications, your submission of Applications for publication on the CIQ Store, and, if applicable, the sale of your Application on the CIQ Store. Capitalized terms have the meanings set forth in the body of this Agreement or in Section IX of this Agreement. By using the Program Materials, you signify your agreement to this Agreement. Garmin may modify this Agreement at any time by updating this posting. Your continued use of the Program Materials following the posting of a revised Agreement means that you accept and agree to the changes. You should visit this page periodically to review this Agreement. If Garmin makes a material change to the Agreement, we will notify you. This Agreement supersedes and replaces the Garmin CONNECT IQ SDK License Agreement and CONNECT IQ Application Developer Agreement. I. Development of Applications using the SDK 
 a. License. Subject to the terms and conditions of this Agreement, Garmin hereby grants you a limited, non-exclusive, personal, revocable, non-assignable, non-sublicensable and non-transferable license to use the Program Materials for the sole purpose of developing and testing Applications. All licenses not expressly granted in this Agreement are reserved. 
 b. Restrictions : You may not use the Program Materials for any purpose not expressly permitted by this Agreement. You agree not to rent, lease, lend, upload to or host on any website or server, sell, redistribute, or sublicense the Program Materials, in whole or in part, or to enable others to do so. You may not and you agree not to, or to enable others to, modify, create derivative works of, copy (except as expressly permitted under this Agreement), decompile, reverse engineer, disassemble, attempt to derive the source code of, or decrypt the Program Materials, or any part thereof. You may not: (a) alter or remove any copyright, trademark, or other proprietary notices appearing on or in the Program Materials; (b) engage in any activity with respect to the Program Materials that interferes with, disrupts, damages, or accesses in an unauthorized manner any Garmin devices, platforms, or systems, or those of any of its affiliates or any third party; or (c) make any statements that you or your Application are affiliated with, or sponsored, certified, or otherwise endorsed by Garmin or any of its affiliates, unless expressly permitted by Garmin in writing. 
 c. Updates; No Support or Maintenance : Garmin may, but is not obligated to, extend, enhance, or otherwise modify the SDK at any time without notice. If updates are made available by Garmin, the terms of this Agreement will govern such updates, unless the update is accompanied by a separate license in which case the terms of that license will govern. Garmin may, but is not obligated to, provide any maintenance, technical or other support for the SDK. You agree that the form and nature of the Program Materials may change without prior notice to you and that future versions of the Program Materials may be incompatible with applications developed on previous versions of the Program Materials. 
 d. Application Requirements : You are solely responsible for all aspects of development and use of your Application, including related documentation, user assistance, support and warranty. You will ensure that your Application complies with (i) the Developer Guidelines, available at https://developer.garmin.com/connect-iq/app-review-guidelines/ , as updated by Garmin from time to time; and (ii) the requirements set forth in Exhibit A (Application Requirements) . None of Garmin's review, testing, or approval of your Application, if applicable, limits or relieves you of any responsibilities related to your Application.

 II. Distribution of Applications on the CIQ Store 
 a. Registration and Application Submission Process. To submit an Application, you must comply with the following requirements: 1. Registration . You must complete the registration process specified by Garmin (" Registration ") to create an account (" Garmin Developer Account "). You must provide complete and accurate information as requested during Registration. You must maintain your Garmin Developer Account in good standing. You may not share your login credentials or your Garmin Developer Account with anyone other than Authorized Users and you must ensure that each Authorized User is aware of and complies with the terms and conditions of this Agreement. Garmin reserves the right to approve or decline your participation as a Garmin Developer in its sole discretion.
 2. Branded Username . If the username associated with your Application includes a company's name or brand, then you must either be authorized by that company to use the company's name or brand in your username or change your username to remove the company's name or brand.
 3. Minimum Age . You must be at least 18 years of age to create a developer account and submit an Application.
 4. Application Submission . By submitting your Application you represent and warrant that: A. Your Application complies with the Application Requirements.
 B. You will not attempt to conceal, misrepresent or obscure any features, content, services or functionality in your Application from Garmin's review or hinder Garmin from being able to fully review your Application.


 5. Submission Process; Takedown . Garmin may, but is not obligated to, review your Application before it is uploaded to the CIQ Store. At any time Garmin may (a) determine that your Application does not meet all or any part of the Application Requirements; (b) refuse to upload or remove your Application for any reason, even if your Application meets the Application Requirements, and (c) terminate, restrict, or otherwise modify your ability to access any Garmin services, products, or systems.


 b. Distribution of Applications. You hereby appoint Garmin as your agent to make your Application(s) available on the CIQ Store. By submitting your Application, you grant Garmin a non-exclusive, non-transferable, irrevocable, royalty-free license to use your Application for any purposes, including without limitation for testing or other related purposes to ensure that it complies with this Agreement, to permit users to download your Application through the CIQ Store, and to make available to users of any of Garmin's products or applications. Garmin shall not acquire any ownership interest in or to your Application, subject to Garmin's ownership of the Program Materials. 
 c. Monetizing Your Apps. 1. General Requirements. For purposes of this Agreement, “Monetizing” an Application means that you are collecting money or receiving items with monetary value in connection with your Application – whether such remuneration is required to download your Application, to use certain features in your Application, as a solicited tip or donation, or requested or suggested by you for any other reason. If you Monetize your App, you represent and warrant that: A. You will accurately provide any information required by Garmin during the onboarding process or as requested from time to time to maintain your account in good standing, including but not limited to information necessary to authenticate your identity.
 B. You will accurately disclose to end users the scope of any payment requirements and fulfill all such purchases.
 C. If you use a payment processor not provided by Garmin, you will ensure the security of any such payment method.


 2. Use of Garmin Merchant Service. You are not required to use the Merchant Service to Monetize your Application, but if you choose to do so, then the requirements in this Section apply. A. Supported Countries. You must be in a supported country to use the Merchant Service. Information on supported countries is available in the Documentation.
 B. Marketplace Account. You must have a valid account (" Merchant Account ") under a separate agreement with Garmin's authorized payment processor and marketplace platform provider and maintain that account in good standing.
 C. Fees. In consideration of Garmin’s provision of the Merchant Service, Garmin will collect (i) a non-refundable annual fee; and (ii) a service fee that is a percentage of revenue collected by Garmin—in each case, in the amounts specified in the Documentation.
 D. Customer Returns. You agree that your earned revenue from sales through the Merchant Service is subject to the return policy published in the Documentation. In Garmin’s discretion, Garmin may either hold funds during the applicable return period, set-off amounts from returned Applications from future payouts to you, or require you to provide a Garmin a refund in the amount remitted to you for a returned Application.
 E. Payout Schedule. Garmin will remit earned payments to you in accordance with the schedule and minimum amount threshold specified in the Documentation.
 F. Taxes. (i) You agree to timely provide, as soon as reasonably practicable, any tax documentation or certification requested by Garmin in connection with your use of the Merchant Service.
 (ii) Where Garmin or its payment processor reasonably determines that it is required by applicable (local) legislation or by the applicable governmental tax authority to declare, charge, deduct, or withhold any taxes (in each case, " Withholding Taxes "), Garmin may also deduct the amount of such Withholding Taxes from the amount Garmin remits to you.
 (iii) In Garmin’s discretion, Garmin may add applicable sales taxes, VAT taxes, or similar transaction taxes to the final purchase of an Application to an end user.







 III. Term and Termination 
 a. This Agreement shall commence on the date you indicate your acceptance of the terms and conditions hereof and shall remain in full force and effect until terminated as provided hereunder (the "Term"). This Section III does not limit Garmin’s rights to immediately remove or suspend an Application from the CIQ Store in the event that it violates this Agreement. The removal of an Application from the CIQ Store does not constitute a termination of this Agreement.
 b. Termination. 1. Termination by You. You may terminate this Agreement by delivering written notice to Garmin of termination at least 30 days prior to the termination date.
 2. Termination for Cause. If you fail to perform or comply in any material respect with any of its obligations under this Agreement and such failure is not remedied within 30 days after receipt of written notice of such failure, then Garmin may terminate this Agreement effective upon expiration of such 30-day cure period.


 c. Effect of Termination. Upon termination of the Agreement for any reason: 1. You shall immediately stop using and delete the Program Materials.
 2. Upon termination, Garmin will remove your Application from the CIQ Store. End users who have previously downloaded a copy of the Application may continue to use that copy indefinitely. Garmin will pay any amounts due in your account in accordance with the ordinary schedule specified in the Documentation.
 3. Provisions that naturally survive termination of this Agreement shall so survive.



 IV. Proprietary Rights 
 a. Garmin's Ownership. Garmin retains all rights, title, and interest in and to the Program Materials, including any updates. You agree to cooperate with Garmin to maintain Garmin's ownership of the Program Materials, and you agree to promptly provide notice to Garmin of any claims relating to the Program Materials. There are no implied licenses under this Agreement, and any rights not expressly granted to you hereunder are reserved by Garmin.
 b. License to Your Marks. You grant Garmin a revocable, non-exclusive, non-transferable royalty-free license to use your Trademarks in connection with Garmin’s activities under this Agreement and to publicize, in Garmin’s sole discretion, your participation in the Garmin Developer Program and your Application.
 c. Feedback. If you provide any Feedback to Garmin: (a) you grant to Garmin a worldwide, non-exclusive, royalty-free, transferable, sublicensable, perpetual and irrevocable license to use and otherwise exploit such Feedback in connection with any Garmin products, applications and services; (b) Garmin shall be free to use, disclose, reproduce, distribute and otherwise commercialize all Feedback that you provide without obligation or restriction of any kind on account of Intellectual Property Rights or otherwise; (c) you waive all rights to be compensated or seek compensation for your Feedback; and (d) Feedback, even if marked confidential, shall not create any confidentiality obligations on Garmin, unless Garmin has otherwise expressly agreed in a signed agreement.
 d. Confidential Information. You shall hold Garmin's Confidential Information in confidence and shall not disclose such Confidential Information to third parties or use such Confidential Information for any purpose other than as necessary to perform under this Agreement. You agree to limit access to the Confidential Information to Authorized Users. All such Authorized Users must have a written confidentiality agreement with you that is no less restrictive than the terms contained herein. You will protect the Confidential Information from unauthorized use, access, or disclosure in the same manner as you protect your own confidential or proprietary information of a similar nature and with no less than reasonable care. The foregoing restrictions on disclosure shall not apply to Confidential Information that (a) becomes, through no act or fault of yours, publicly known; (b) is received by you from a third party without a restriction on disclosure or use; or (c) is independently developed by you without reference to Garmin's Confidential Information. In addition, you will not disclose to any third party the existence of any new feature of the Garmin Developer Program before Garmin makes a public announcement regarding their existence.

 V. Representations and Warranties 
 a. Mutual Warranties. Each party represents and warrants to the other that: (a) it has all necessary right, power and ability to execute, and to perform the obligations contemplated by, this Agreement; (b) no authorization or approval from any third party is required in connection with such party's execution, delivery or performance of this Agreement; and (c) such party's obligations under this Agreement do not violate any Law or breach any other agreement to which such party is bound.
 a. Your Warranties. You represent and warrant to Garmin that: (a) you are duly licensed to conduct your business under the Laws of all jurisdictions in which you conduct business; (b) any materials you provide, create or develop that are in any way related to this Agreement, or the use thereof, do not and will not infringe any Intellectual Property Rights of any third party; and (c) all information you provide to Garmin is true, correct and complete in all respects and you will update Garmin with any changes to information you have previously supplied. You represent and warrant that you have all Intellectual Property Rights, including all necessary patent, trademark, trade secret, copyright or other proprietary rights, in and to the Application (including without limitation any and all content therein or portions thereof). If you use third-party materials, you represent and warrant that you have the right to distribute the third-party material in the Application.
 c. DISCLAIMER OF WARRANTIES. THE PROGRAM MATERIALS AND ALL INFORMATION AND OTHER MATERIALS CONTAINED OR MADE AVAILABLE THEREIN IS PROVIDED ON AN "AS IS", "AS AVAILABLE" BASIS WITHOUT WARRANTY OF ANY KIND, AND YOUR USE OF ANY OF THE FOREGOING IS AT YOUR OWN RISK. NONE OF THE GARMIN PARTIES (AS DEFINED BELOW) REPRESENT OR WARRANT THAT THE PROGRAM MATERIALS OR ANY INFORMATION OR OTHER MATERIALS CONTAINED OR MADE AVAILABLE THEREIN WILL BE AVAILABLE, ACCESSIBLE, UNINTERRUPTED, TIMELY, SECURE, ACCURATE, COMPLETE, OR ERROR-FREE. YOU EXPRESSLY ACKNOWLEDGE THAT COMPUTER NETWORK-BASED SERVICES MAY BE SUBJECT TO OUTAGES, INTERRUPTIONS, ATTACKS BY THIRD PARTIES AND DELAY OCCURRENCES. GARMIN SPECIFICALLY DISCLAIMS ALL REPRESENTATIONS, WARRANTIES, AND CONDITIONS WHETHER EXPRESS OR IMPLIED, ARISING BY STATUTE, OPERATION OF LAW, USAGE OF TRADE, COURSE OF DEALING, OR OTHERWISE. You may have rights that vary from jurisdiction to jurisdiction; however, the above disclaimers apply to the maximum extent permitted by applicable Law.

 VI. LIMITATIONS OF LIABILITY 
 TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAWS, UNDER NO CIRCUMSTANCES WILL: (A) GARMIN OR ANY OF ITS CURRENT OR FORMER AFFILIATES (OR ANY OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SUCCESSORS OR ASSIGNS OF ANY OF THEM) (COLLECTIVELY, THE "GARMIN PARTIES") BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR EXEMPLARY DAMAGES (HOWEVER ARISING), UNDER ANY THEORY OF LIABILITY OR CAUSE OF ACTION WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT OR OTHERWISE, REGARDLESS OF WHETHER IT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; AND (B) EXCEPT FOR ANY ACCOUNT BALANCE OWED TO YOU FOR APPLICATION SALES THROUGH THE MERCHANT SERVICE, THE GARMIN PARTIES' TOTAL LIABILITY TO YOU, WHETHER ARISING IN TORT (INCLUDING NEGLIGENCE), CONTRACT OR OTHERWISE, UNDER THIS AGREEMENT OR WITH REGARD TO THE PROGRAM MATERIALS OR ANY OTHER INFORMATION AND OTHER MATERIALS CONTAINED OR MADE AVAILABLE THEREIN, WILL IN NO CASE EXCEED $100.
 VII. Indemnification 
 You agree to indemnify, release, hold harmless and, upon request, defend the Garmin Parties from and against any and all claims, actions, proceedings, and suits and all related liabilities, damages, settlements, penalties, fines, costs or expenses (including reasonable attorneys' fees and other litigation expenses, whether prior to, at trial or any other proceeding and in any appeal or other post judgment proceeding) incurred by Garmin, arising out of or relating to: (a) any breach or alleged breach by you of any representation, warranty, or obligation contained in this Agreement; (b) any damage or loss caused by negligence, fraud, dishonesty or willful misconduct by you, any Authorized User, or any of your affiliates, employees, agents, contractors, suppliers or customers; (c) any contract or agreement between you and a third party; (d) use by any party of your Application, including any claims by any end user; (e) any claims related to the nature or characteristics of your Application, or any of your other products or services; (f) any infringement or alleged infringement of a patent, copyright, trademark or other intellectual property or proprietary right relating to this Agreement; (g) any alleged or actual violation by you of any applicable Laws; or (h) any claims or governmental regulatory actions related to your collection, use or sharing of user data collected through your Application in violation of this Agreement or the privacy or other rights of any user or other third party.
 VIII. General Provisions 
 a. Publicity. You may not issue any press release regarding your association with Garmin without the express prior written consent of Garmin. You shall not include any marketing of Garmin's name, logo or other trademarks in your Application or in any other materials without Garmin's prior written consent. Notwithstanding the foregoing, if your submitted Application is approved by Garmin, you may promote your Application’s compatibility with certain Garmin products so long as your statements concerning compatibility are accurate and you adhere to Garmin’s guidelines at https://developer.garmin.com/brand-guidelines/overview/ .
 b. Independent Development. Nothing in this Agreement will impair the right of Garmin or its affiliates to develop, acquire, license, market, promote or distribute any products, software or technologies, including those that perform the same or similar functions as, or otherwise compete with, the Application or any other products, software or technologies that you may develop, produce, market, sell or distribute.
 c. Notices. Garmin may provide notices to you via the email address that you have provided with your account. You may send notices to Garmin via postal mail to Garmin International, Inc., 1200 E. 151st St., Olathe, KS 66062, ATTN: Legal Department. You agree to receive electronic communications from Garmin. You agree that any notice, agreement, disclosure or other communication that Garmin sends you electronically will satisfy any legal communication requirements, including that such communications be in writing.
 d. Governing Law; Venue. All legal issues arising from or related to your use of the Program Materials and this Agreement shall be construed in accordance with and governed by the laws of the State of Kansas applicable to contracts entered into and performed within the State of Kansas without respect to its conflict of laws principles. You agree to submit to the personal and exclusive jurisdiction of the United States District Court for the District of Kansas, or any Kansas State court sitting in Johnson County, to resolve any dispute, claim or cause of action arising out of this Agreement. You hereby irrevocably waive, to the fullest extent permitted by law, any objection which you may now or hereafter have to the laying of the venue of any such proceeding brought in such a court and any claim that any such proceeding brought in such a court has been brought in an inconvenient forum. Specifically excluded from application to this Agreement is the United Nations Convention on Contracts for the International Sale of Goods.
 e. Costs and Expenses. You are solely responsible for all costs and expenses related to participating in the Garmin Developer Program, including the development of any Application.
 f. Severability. If any provision in this Agreement is held invalid, the remainder of this Agreement shall continue to be enforceable. If any provision in this Agreement is deemed unlawful, void or unenforceable, then that provision is deemed severable from this Agreement and the remaining provisions are still valid and enforceable.
 g. Assignment. You may not assign, whether by transfer, merger operation of law or otherwise, any of your rights or delegate the performance of any of your obligations under this Agreement without the prior written consent of Garmin. Any purported assignment in violation of hereof shall be null and void. Garmin has the right to assign this Agreement to an affiliate without prior approval from you.
 h. Force Majeure. Garmin will not be liable to you for any losses arising out of the delay or interruption of Garmin's performance of obligations under the Agreement due to any acts of God, or any other occurrences which are beyond Garmin's reasonable control.
 i. Entire Agreement. This Agreement together with all of Garmin's policies referenced herein sets forth the entire understanding and agreement of the parties, and supersedes any and all prior or contemporaneous oral or written agreements or understandings between the parties, as to the subject matter of this Agreement. Garmin's failure to insist upon or enforce strict performance of this Agreement will not be considered a waiver of any provision or right. Neither the course of conduct between the parties nor trade practice will modify this Agreement.
 j. Export Restrictions. You may not use, export, re-export, import, sell or transfer any of the Program Materials except as authorized by United States Law and other applicable Laws in the jurisdiction in which you obtain such Program Materials. You will comply with all Laws that restrict your and/or Garmin's ability to operate in or transact business with certain countries or share certain technologies and data with certain individuals ("Export Restrictions"). Your compliance with the Export Restrictions shall be such that Garmin shall not violate any of the Export Restrictions as a result of your acts or omissions.

 IX. Definitions 
 a. "Application(s)" means any software programs that you develop by using components of the Program Materials.
 b. "Application Requirements" means this Agreement, the Connect IQ Store Review Guidelines, and any additional guidelines that Garmin may otherwise provide or make available to you.
 c. "Authorized Users" means your employees, agents and contractors who have a need to access and use your Garmin Developer Account as permitted under this Agreement.
 d. "CIQ Store" means the Garmin-operated website, mobile application, or on-device application where end users download Applications.
 e. "Companion SDK" means the SDK provided by Garmin to enable the development of Applications for third-party platforms. Unless otherwise specified, references in this Agreement to the SDK include the Companion SDK.
 f. "Confidential Information" means the SDK, the Program Materials, the underlying computer code to which you may obtain or receive access, the functional or technical design, logic or other internal routines or workings of the Garmin SDK, and any other materials of Garmin that Garmin designates as confidential or which you should reasonably believe to be confidential.
 g. "Documentation" means the Connect IQ Monetization System manual available to you in the developer dashboard, available at https://developer.garmin.com/connect-iq/monetization .
 h. "Feedback" means any suggestions, comments, feedback or other information or materials you provide to Garmin with respect to the Garmin Developer Program, the SDK, or any of Garmin's products or services.
 i. "Garmin Developer" means any developer having gone through the Registration process and been approved by Garmin to use the Program Materials.
 j. "Garmin Developer Account" means the account by which you and/or Authorized Users gain access to the Program Materials subject to the terms and conditions of this Agreement.
 k. "Garmin Developer Program" means the program Garmin has developed to enable Garmin Developers to use the Program Materials, as such program may be revised from time to time at Garmin's sole discretion.
 l. "Intellectual Property Rights" means ideas, inventions, discoveries, improvements, modifications, updates, enhancements, designs, business models, software, derivatives, know-how, processes, methodologies, technical information, data, test results, information, know-how, concepts, and works of authorship, whether patentable or not and whether reduced to practice or not, and all related intellectual property, including, but not limited to, patents and patent applications (including but not limited to all reissues, continuations, continuations-in-part, revisions, extensions, divisionals, designs and reexaminations thereof), copyrights, mask works, trademarks, trade secrets, and other forms of intellectual property protection related thereto, including all applications, certifications and registrations therefor.
 m. "Laws" means all local, state, regional, national, foreign, international or other laws, policies, guidelines, standards, regulations, ordinances, rules and judgments applicable to you, your business or your access to and use of the Garmin Developer Program, including without limitation Federal Trade Commission regulations, rules and judgments, and those of any other regulatory body or agency having jurisdiction over the subject matter hereof.
 n. "Merchant Service" means Garmin’s service to enable the sale of Applications to end users directly on the CIQ Store through Garmin’s authorized payment processor.
 o. "SDK" means Garmin's CONNECT IQ software development kit, in object code form, that is licensed to you under this Agreement, including documentation, firmware, software, sample code, tools, libraries, APIs, data, and files made available to you by Garmin.
 p. "Program Materials" means any materials made available to you by Garmin or a Garmin affiliate in connection with the Garmin Developer Program, at a Garmin developer website or otherwise, including the SDK and all tools, the Documentation, other SDK- and CIQ Store-related documentation and materials, in written or digital form, such as sample code, simulators, tools, and libraries, and including any upgrades, modified versions, updates, enhancements, bug fixes, supplements to, revisions, new releases, and/or additions thereto, if any, that may be provided or made available by Garmin.
 q. "Trademark(s)" means all means, collectively, all trademarks, service marks, logos, trade dress, trade names and service names, any registrations and applications to register, and all goodwill in, any of the foregoing, and all similar or related rights arising under any of the Laws of the United States or any other country or jurisdiction, whether now existing or hereafter adopted or acquired.

 Exhibit A - Application Requirements 
 I. Privacy. a. Privacy Policy. If your Application will collect any data from users of the Application, then you must have a privacy policy for the Application that complies with all applicable Laws. You must update your privacy policy if you change the way you collect, use, store, or disclose user data. Additionally, you may not change the URL or location for your privacy policy without redirecting users to the new location of your privacy policy. Your privacy policy or other notices or terms must make it clear that any data submitted to the Application is submitted to you and not to Garmin and that Garmin has no responsibility or liability for any such data.
 b. Data Retention. You are not permitted to retain user data for longer than needed for the reasonable operation of your Application unless the user gives you express consent to retain the user's data for a longer period.
 c. Location Data. You represent and warrant that your Application does not default to collect location data about users and that users are notified and required to opt in to allow your Application to collect location data.
 d. Other Data Restrictions. Your Application may only access and/or collect information from Garmin about a user or the user's activities if the user gives you express prior consent, and your Application may only use that information when, and for the limited purposes for which, the user has given you express consent. In addition, you or your Application may not: (i) retain any data you receive from Garmin concerning a user or the user's activities without the user's express consent, (ii) retain any user data collected through the Application or from Garmin after a user has revoked consent or asked you to delete such data; or (iii) sell, rent, or transfer (directly or indirectly) any data concerning a user or the user's activities you receive from Garmin.


 II. Security; Data. You are solely responsible for the security of user data residing on server(s) or systems owned or operated by you, or by a third party designated by you (e.g., a web hosting company, processor, or other service provider). You must maintain, and must require any third party designated by you to maintain processes and controls to protect and secure user data. You acknowledge that Garmin will not be liable for any improperly processed or unauthorized transactions or illegal or fraudulent access to your Garmin Developer Account, your Application or to Program Materials. You must notify us immediately in the event of any unauthorized access (confirmed or suspected) to Program Materials, your Garmin Developer Account credentials, your authentication key, and/or your Application.

 III. Other Regulations. a. You are required to comply with all applicable laws, regulations, and policies, including but not limited to all U.S. Food and Drug Administration (“FDA”) laws, regulations, and policies, related to the manufacturing, marketing, sale, and distribution of your Application in the United States, as well as in other jurisdictions where your Application is available, manufactured, marketed, sold, distributed or used. You agree, upon Garmin’s request, to promptly provide any such clearance documentation related to this section E(i) to support the marketing of your Application.
 b. You are solely responsible for complying with any laws, orders, rules, and regulations of the Federal Communications Commission, FDA, other U.S. regulatory bodies such as the U.S. Federal Trade Commission and the U.S. Department of Health and Human Services, any Federal, State or local governmental authority, and the laws, regulations, and policies of any jurisdiction applicable to its use of the Licensed Material and associated Devices (e.g. MHRA, CFDA). You will not seek any regulatory marketing permissions or make any determinations that may result in the Program Materials, Connect IQ SDK, or any other Garmin products or services being determined to be regulated products or that may impose any obligations or limitations on Garmin.


 IV. Push Notifications. Garmin may make available to you a push notification API to enable your Application to push notifications to the Garmin devices of the end users of your Application. If you are authorized by Garmin to use the push notification API, then you agree that you will not push messages to the Garmin devices of the end users of your Application without their consent. In addition, push notifications must not be required for your Application to function, must not require payment or other charge, and must not be used for advertising, promotions, or direct marketing purposes or to send sensitive personal or confidential information.

 Get the Connect IQ 7.4.2 SDK
 This SDK supports Connect IQ 1.x, 2.x and 3x. Last Updated: December 11, 2024 Install the SDK Manager
 Download the SDK manager.
 Accept &amp; Download for Windows Accept &amp; Download for Mac Accept &amp; Download for Linux Launch the SDK manager from your chosen download location.
 Complete the first-time setup process.
 Use the SDK manager to download the latest Connect IQ SDK and devices.
 Once the download completes, click Yes when prompted to use the new SDK version as your active SDK.
 Close the SDK Manager.
 Installing the Visual Studio Code Monkey C Extension:
 In Visual Studio Code, go to the View &gt; Extension menu
 In the Extensions Marketplace, search box type "Monkey C"
 Select the Monkey C extension from Garmin.
 Use the Install button to install the extension in Visual Studio Code. This will require a restart of Visual Studio Code.
 After Visual Studio Code restarts, summon the command palette with Ctrl + Shift + P ( Command + Shift + P on Mac).
 Type "Verify Installation" and select Monkey C: Verify Installation 
 The direct download option does not include the Visual Studio Code Monkey C extension and may be used if Visual Studio Code is not the preferred development environment. Get the Connect IQ Mobile SDK
 The Android SDK is available via Maven Central . A sample app is available on GitHub that demonstrates integration and use of the SDK in an Android app.
 The iOS SDK is available via GitHub . A sample app is available on GitHub that demonstrates integration and use of the SDK in an iOS app.
 By using the SDK, you agree to the license agreement above. A copy of the license agreement is included with the SDK as well.


# [https://developer.garmin.com/connect-iq/monetization](https://developer.garmin.com/connect-iq/monetization)nMenu Monetization Connect IQ Monetization System
 The Connect IQ™ monetization system gives developers the ability to monetize their Connect IQ apps. Customers are provided a straightforward purchase experience, and can create a single digital wallet that can be used for both Connect IQ content, as well as Garmin® products and services. Merchant Onboarding 
 App Sales 
 Account Management 
 Price Points


# [Submit an App](https://developer.garmin.com/connect-iq/submit-an-app/)nMenu Submit an App Stay Informed
 Join the Garmin Connect IQ developer program to be notified about new features. Sign Up Submit an App
 Once your apps are fully tested and ready to go, you can publish and promote your apps. Prepare your app for submission:
 Make sure your app manifest specifies all the products you wish to support.
 Use the Monkey C: Export Project command in the Visual Studio Code Monkey C extension to generate your .iq file that contains the binaries for all of the products you are supporting.
 After you select it, you will be presented a wizard to create the IQ file.
 Click Finish to generate an app package. You can also click Next to update the list of supported languages before exporting. If there are no errors, your apps are now ready to publish.
 Publishing the First Version
 The first step is to upload your IQ file to the Connect IQ Store. Once the binary has been validated you will be able to add a description and screen shots. Be very specific in your description. This is your chance to get people interested in getting your app. Submit an App Approval Process
 After you upload your app successfully, we will review it. You will be able to preview your app and download it yourself for testing. While approval is pending, your app will not appear in the Connect IQ Store. Once it’s approved, we will notify you. Then it will appear on the Connect IQ Store for all users to send to their devices. General Guidelines
 We’re glad you want to develop Connect IQ apps, and we want you to be successful. Here are some guidelines that you should keep in mind as you develop your apps. These guidelines will help you speed through the approval process. Keep in mind that these guidelines may change at any time.


# [Stay Informed](https://developer.garmin.com/connect-iq/stay-informed/)nMenu Stay Informed &nbsp; @Garmin #ConnectIQ Stay Informed
 Join the Garmin Connect IQ developer program to be notified about new versions and features of the Connect IQ SDK. By signing up, I agree to Garmin’s privacy policy . Stay Informed Last Updated: May 25, 2018


# [Connect IQ Basics](https://developer.garmin.com/connect-iq/connect-iq-basics/)nMenu Connect IQ Basics Welcome to Connect IQ
 Connect IQ combines three W’s: Wear - Garmin devices don’t live on a desk or in a pocket. Rather, they are worn on wrists or mounted to bicycles to help our users beat yesterday. Garmin’s experience in power management, activity tracking and ANT or ANT+ sensors means our users will spend more time using the products and less time charging them.
 Where - Location awareness is at the center of our products. While they are still highly functional devices even when not paired with a smart phone, initiating this pairing process will unlock a world of new features and functions for your Garmin device.
 Ware - Garmin’s new Connect IQ app system allows for developers to extend their apps into Garmin’s wearable ecosystem.
 
 Connect IQ products provide the best of what Garmin has to offer like beautiful design, location awareness, and efficient power management with the Connect IQ app system. Using the Connect IQ SDK, developers can create apps for Connect IQ devices and distribute them via the Connect IQ Store. Connect IQ apps are created in Monkey C, an object-oriented language designed for easy app development. The goal of Monkey C is to simplify the app building process, letting developers focus more on the customer and less on resource constraints. It uses reference counting to automatically clean up memory, freeing you from focusing on memory management. In addition, the resource compiler helps you import fonts and images to easily convert them between devices. If you’ve worked with dynamic languages in the past like Java™, PHP, Ruby or Python™, Monkey C should be very familiar. Devices and APIs
 The problem of API fragmentation is a challenge for app developers. If a developer takes advantage of new APIs, newer devices with less customer penetration may be targeted. If only established APIs are used, apps may not take advantage of new capabilities. Garmin devices each have some differences you’ll need to account for: round screens versus square screens, touch screens versus buttons, and a different array of sensors depending on the device purpose. While the Java philosophy of “write once run anywhere” is a notable goal, creating a universal API that crosses every Garmin device would inevitably become a lowest common denominator API. Rather than attempting to abstract away differences in devices, Connect IQ APIs are tailored to the devices they run on. If a device has a magnetometer, the device should have available the Magnetometer API. If two devices each have a magnetometer, the API should be the same between them. If a device does not have a magnetometer, it will not provide that API. To see the Connect IQ compatible devices and their capabilities go to the Device Reference section . System versus API Level
 Connect IQ uses two versions [1] : the API level and the system number . The API level is a three number ( major.minor.micro ) version that dictates the potential APIs that a device supports. As stated above, not every device supports every API, but if a product is at or below an API level it is guaranteed to not support an API. The system number is a single digit number that is associated with a minimum API level. The system number communicates the set of devices that meet the minimum API level. Products running the latest system are most likely to get API updates and bug fixes. Products not running the latest system may receive updates when necessary. The Tao of Connect IQ
 There is a rhyme and reason behind Monkey C to make it easier for developers to support the Garmin ecosystem of products: The developer chooses what devices to support Connect IQ apps can run across multiple devices, but the intended devices are up to the developer. Not every device will be aimed at the markets the developer wants to target or provide the experience the developer wants to provide. The developer should not be forced to support devices they don’t want to. 
 The developer tools should help developers support multiple devices The developer tools lessen the weight of supporting multiple devices. The Resource Compiler hides device specific palettes and orientations from the developer. It also allows per device override of resources, allowing different images, fonts, and page layouts to be specified in the resources XML. The simulator needs to expose only the APIs a particular device supports so the developer can test device support. 
 Similar devices should have similar APIs Not all devices will be equal, but there is often commonality between them. Two different watches may have different display technologies, but they both support bitmaps, fonts, user events, ANT/ANT+ , and BLE . A developer writing a sports app should not have to completely rewrite their app to support multiple devices. 
 At runtime, the developer can ask what the system ‘has’ Connect IQ applications are dynamically linked to the system. If an app makes a reference to an API that does not exist on a particular system, the app will fail at runtime when the app references the API, not at load time like C++. This allows an app to avoid making the call by taking advantage of the ‘ has ’ operator. 
 Overview
 Section Description 
 Getting Started Step by step instructions for installing the Connect IQ tools 
 Your First App Create your first watch face using Connect IQ 
 App Types Learn about the watch face app type and what must be taken into consideration 
 Experienced Connect IQ developers reading this may be wondering if we are attempting to make fetch happen, and the answer is yes. You have to admit that it is pretty fetch. &nbsp;↩


# [Getting Started](https://developer.garmin.com/connect-iq/connect-iq-basics/getting-started/)nMenu Connect IQ Basics Getting Started
 The Connect IQ SDK Manager
 The Connect IQ SDK Manager application keeps your Connect IQ SDK and device library up to date. It will download SDK updates and new devices from the cloud as they become available. Installing the Connect IQ SDK Manager
 Go to developer.garmin.com/connect-iq/sdk 
 In the Install the SDK Manager section select Accept &amp; Download 
 Create a new folder in a convenient location Windows and Linux [1] - Copy the executable and support files to the new folder
 Mac - Open the disk image and copy the SDK manager to the new folder
 
 Launch the SDK Manager. You should see the following: 
 Press the Login button and enter the credentials of the Connect account: 
 The SDK Manager can remember your credentials or you can re-enter them every time. Select which option you prefer and press Next 
 You’ll be presented with the option of having the Connect IQ SDK update automatically, or to be notified when a new version is available. Select the option you prefer and press Next 
 You’ll be presented with the option of having Connect IQ devices update, or to be notified when new devices are available. If you want to update devices automatically, you can choose the types of devices you want updates for. Select the option you prefer and press Finish 
 The SDK Manager has two tabs: SDK and Devices . The SDK tab shows what SDKs are available. Use the button to download and install a SDK. Use the to un-install a SDK. Use the “Use as SDK” button to set the active SDK. The Devices tab shows the devices available for the SDK. If a new device is available for download a button will appear next to it. If a device is being updated a spinner will appear next to it. Finally, the can be used to remove a device. The Monkey C Visual Studio Code Extension
 The Monkey C extension adds support for using the Connect IQ SDK, including a syntax highlighting editor, build integration, and integrated debugger. The Monkey C extension requires Visual Studio Code , the Oracle Java™ Runtime Environment 8 (version 1.8.0 or higher), and Connect IQ SDK version 4.0.6 or higher. Installing the Monkey C Extension
 In Visual Studio Code, go to the View &gt; Extension 
 In the Extensions Marketplace, search box type “Monkey C”
 Select the Monkey C extension from Garmin
 Use the Install button to install the extension in Visual Studio Code. This will require a restart of Visual Studio Code.
 After Visual Studio Code restarts, summon the command palette with Ctrl + Shift + P ( Command + Shift + P on Mac)
 Type “Verify Installation” and select Monkey C: Verify Installation 
 Generating a Developer Key
 The Connect IQ compiler requires a developer key to sign apps when they’re compiled and packaged. The required key must be a RSA 4096 bit private key. Note : It’s important you keep track of the key you use to sign app packages. You will need to use the same key to sign updates to an existing app on the store. If you lose your original signing key you will not be able to update your app. Generating a Key Using the Monkey C Extension
 If you have a developer key, you can set the path to it by selecting File &gt; Preferences &gt; Settings &gt; Monkey C and setting the Monkey C: Developer Key Path to your developer key. If you do not have a developer key, you can generate one using the following steps: Summon the command palette with Ctrl + Shift + P ( Command + Shift + P on Mac)
 Type “Generate a developer key” and select Monkey C: Generate a Developer Key 
 Select the directory in which to save your developer key
 The developer key specified in the Connect IQ compiler preferences will automatically be passed to the compiler when a project is compiled. [linuxsupport]: Connect IQ only supports Ubuntu Linux distributions linuxsupport &nbsp;↩


# [Your First App](https://developer.garmin.com/connect-iq/connect-iq-basics/your-first-app/)nMenu Connect IQ Basics Your First Connect IQ App
 Creating Your First Project
 First you need to create your new project: Use Ctrl + Shift + P ( Command + Shift + P on the Mac) to summon the command palette
 Type “New Project” and select Monkey C: New Project [1] 
 When prompted with Set Project Name enter a name for your new project
 Select the project type Watch Face 
 Select the Simple template upon which the project will be based
 Select 3.2.0 as the minimum API level
 Set the parent directory for your new project
 Once the project is initialized, the following project elements will be created automatically: bin Contains binary and debug output from the app compilation resources Inputs to the resource compiler, such as layouts, images, fonts, and strings, and language-specific resources source Contains the Monkey C source files, initially broken into ‘App’ and ‘View’ files manifest.xml Application properties like the app id, the app type, and the targeted devices About the Minimum SDK Version Field
 The minimum SDK version allows you to configure device compatibility by ensuring that only devices that support, at a minimum, the SDK version you’ve selected will be enabled for your app. For example, if your app relies heavily on a feature of the 2.1.x SDK, such as the Sensor History feature, you can set your minimum SDK version to 2.1.x and the list of available devices will be pruned such that you cannot select an incompatible product. Editing the Supported Products
 After creating the project, you will be presented with the project manifest, which is where metadata about your project like the name id, application id and supported products is maintained. Most of this will be auto-created by the New Project command, but you will need to edit the supported products: Use Ctrl + Shift + P ( Command + Shift + P on the Mac) to summon the command palette
 Type “Edit Products” and select Monkey C: Edit Products 
 You will be presented with a list of all products that meet your minimum API level. Select the top checkbox to select all products or select the specific products you want to support.
 The manifest will update with all products. Running the Program
 Before running the program, make sure you have one of your source files (In the source folder with the .mc extension) open and selected in the editor. Select Run &gt; Run Without Debugging ( Command + F5 on Mac, Ctrl + F5 on other platforms)
 You will be prompted with the list of products your application supports. Select one from the list.
 If all goes well the simulator will start up and the selected watch will appear: Importing an Example
 To try one of the Connect IQ sample apps load it into Visual Studio Code: Click the File menu 
 Select Open Folder… 
 Browse in the downloaded SDK samples folder and select the root directory of the sample to import 
 Click Select Folder to complete the import 
 Side Loading an App
 The Monkey C extension provides a wizard to help developers side load an application. The wizard will create an executable (PRG) of the selected project. Here’s how to use it: Plug your device into your computer
 Use Ctrl + Shift + P ( Command + Shift + P on the Mac) to summon the command palette
 In the command palette type “Build for Device” and select Monkey C: Build for Device 
 Select the product you wish to build for. If you are unable to choose a device for which to build (the menu appears empty), it means that there are no valid devices configured for your project. See Editing the Supported Products for instructions.
 Choose a directory for the output and click Select Folder 
 In your file manager, go to the directory selected in step 4
 Copy the generated PRG files to your device’s GARMIN/APPS directory
 When using the command palette you will be tempted to type Money C instead of Monkey C which is understandable as Money C is Monkey C’s nom de plume in the music industry with such hits as Mo’ Monkeys Mo’ Problems and Baller C Baller Do &nbsp;↩


# [App Types](https://developer.garmin.com/connect-iq/connect-iq-basics/app-types/)nMenu Connect IQ Basics App Types
 Every Connect IQ app must identify its app type. The app type sets the use case and boundaries for the app when it runs. There are five app types available in the Connect IQ system: Watch Faces - These are the home screen for Garmin wearables. They can be simple timepieces or complex data screens with dozens of health and fitness stats.
 Data Fields - Data fields are plug-ins to the Garmin activity experience. They allow computation of new metrics or allow bringing new data into a workout.
 Widgets - Widgets are mini-apps that can be launched from the home screen. They are intended to provide glanceable access to information.
 Device Apps - Device apps are the most powerful app type and provide full access to the system.
 Audio Content Providers - Audio content providers are plug-ins to the media player on music-enabled wearables, and they provide a bridge between the media and third-party content services.
 
 APIs and App Types
 The app type defines the user context of an app. Watch faces, for example, have many constraints because they operate in low power mode. To enforce these limits, the Connect IQ Virtual Machine will limit your available APIs based on your app type. Module Name Data Field Watch Face Widget App Audio Content Provider API Level 
 Toybox.Activity ✓ ✓ ✓ 1.0.0 
 Toybox.ActivityMonitor * ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.ActivityRecording * ✓ 1.0.0 
 Toybox.Ant * ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Application ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Attention ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Background * ✓ ✓ ✓ ✓ ✓ 2.3.0 
 Toybox.BluetoothLowEnergy * ✓ ✓ ✓ ✓ 3.1.0 
 Toybox.Communications * ✓** ✓ ✓ ✓ 1.0.0 
 Toybox.Complications * ✓ ✓ ✓ 4.1.0 
 Toybox.Cryptography * ✓ ✓ ✓ ✓ ✓ 3.0.0 
 Toybox.FitContributor * ✓ ✓ ✓ 1.3.0 
 Toybox.Graphics ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Lang ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Math ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Media ✓ 3.0.0 
 Toybox.PersistedContent * ✓ ✓ ✓ 2.2.0 
 Toybox.PersistedLocations * ✓ ✓ 1.0.0 
 Toybox.Positioning * ✓ ✓ ✓ 1.0.0 
 Toybox.Sensor * ✓ ✓ ✓ 1.0.0 
 Toybox.SensorHistory * ✓ ✓ ✓ ✓ ✓ 2.1.0 
 Toybox.SensorLogging * ✓ ✓ 2.3.0 
 Toybox.StringUtil ✓ ✓ ✓ ✓ ✓ 1.3.0 
 Toybox.System ✓ ✓ ✓ ✓ ✓ 1.3.0 
 Toybox.Test ✓ ✓ ✓ ✓ ✓ 2.1.0 
 Toybox.Time ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Timer ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.UserProfile * ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.WatchUi ✓ ✓ ✓ ✓ ✓ 1.0.0 
 Toybox.Weather ✓ ✓ ✓ ✓ ✓ 3.2.0 
 *Requires app permission ** Communications support in data field introduced in API level 5.0.0 A Toybox module requested for your app type that is outside this list will result in a Symbol Not Found error. Watch Faces
 Watch faces are a special application type that display on the main screen of Garmin’s wearable devices. These application types are limited some ways to allow them to have minimal impact on the device’s battery life. Watch faces run continuously on the device and can have the most effect on power consumption. A poorly designed watch face — one that takes too long to draw — can greatly degrade the battery life of the wearable. Due to these battery life concerns, watch faces have the least access to APIs in the system. They have access to graphics, bitmaps, fonts, current activity tracker status, current battery status, and the user’s activity profile. They cannot access the compass, GPS, or other sensors. If you use custom fonts for numeric display, use the filter option to only load the critical glyphs. This will save memory that you can use for additional graphics Watch Face Sleep
 Watch faces spend the majority of the time in “Sleep Mode” in this mode, execution is restricted to updates once each minute, and cannot use timers or animations. When a user raises the watch to look at it, the watch face exits sleep mode. When this occurs, the WatchFace.onExitSleep() method is called, and updates will increase to once per second, and timers and animations are allowed until the WatchFace.onEnterSleep() method is called. Watch Face Delegate
 Since API Level 2.3.0 The WatchUi.WatchFaceDelegate provides input from the system to watch faces. The delegate should be returned as the second element of the array returned from AppBase.getInitialView() similar to input delegates for other application types. This delegate is currently only used to report power budget violations for watch faces that support every second updates. If the execution budget is exceeded over the course of a minute, the WatchFaceDelegate.onPowerBudgetExceeded() callback will be invoked, providing information about the execution time of the watch face, and the limit that was exceeded. Data Fields
 Dynamic data fields allow customers and third party developers to write additional metrics and data that will display with Garmin activities. The goal is to create a system that not only makes it easy for a user to make a quick data field based off our workout data, but also gives the developer the the ability to customize the presentation. Data fields can display during an already supported activity on the device. They are a great way to provide new metrics to users by performing calculations on data that is already being recorded. Data fields are integrated within existing activities, so it’s best if they appear in the same font and format as that used for the native data fields on the device. For that reason, the simple layout is best, as it will ensure your data field will have the same native look and will scale appropriately to all data screen layouts. If you would like to customize your data field, for example, by inserting a bitmap in place of a numerical value, you will need to ensure that your custom field will scale appropriately among one-field, two-field, three-field, and other layouts. Data Fields and Simple Data Fields
 The base class for data fields is WatchUi.DataField . This class extends WatchUi.View , and in many ways behaves similarly to other View objects. The View.onUpdate() method call will be made every time the data field needs to update. In Garmin activities, the user controls the data page layout; specifically, whether it displays one, two, three, or more fields. The Connect IQ data field must handle displaying in all of those layouts, and the developer can use the simulator to test their field in all layouts supported by devices. Many developers will only want to display a single value and not want to handle all the complexity of the drawing of a data field. In those instances, they can use a WatchUi.SimpleDataField object. A simple data field handles the drawing of the field in multiple sizes, and only requires the developer to implement a DataField.compute() method. The compute() method is passed an Activity.Info object, which contains all current workout information. Use a SimpleDataField when possible to guarantee your data field will have the native look and feel of the other Garmin Data Fields. Connect IQ will try to ensure your data displays with the best font and layout possible. The following is an example of a “Beers Earned” data field, which displays how many beers you have “earned” during your workout: using Toybox.Application; using Toybox.WatchUi; class BeerView extends WatchUi.SimpleField { function initialize() { units = "beers"; } function compute(info) { return info.calories / 150; // Calories in average bottle of beer } } class BeersEarned extends Application.AppBase { function getInitialView() { return new BeerView(); } } Simulating a Workout
 To test your data field in the simulator, feed your data field simulated data by clicking the Simulation menu, choose FIT Data and then Simulate . This will generate random but valid data. You can also use Simulation &gt; FIT Data &gt; Playback File… to simulate a workout by using a pre-recorded FIT file. Widgets
 Widgets are mini-apps that allow developers to provide glanceable views of information. The information may be from a cloud service, from the onboard sensors, or from other Connect IQ APIs. Widgets are launchable from a rotating carousel of pages accessible from the main screen of wearables, or from a side view on bike computers and outdoor handhelds. Unlike apps, Widgets time out after a period of inactivity and are not allowed to record activities, but they are also launchable at any time. Base View and the Widget Carousel
 On wearable products the watch face is the home screen of the widget carousel. Users can use the up/down buttons (on button products) or up/down swipes (on touchscreen wearables) to navigate through the widgets. When a widget launches the initial view returned from getInitialView() is shown. Since they are used for widget navigation, the WatchUi.InputHandler will never receive either the up/down button or up/down swipe events when the base view is shown. Any views pushed on top of the base view using WatchUi.pushView() will not have these input restrictions. The expectation for all views in the widget loop is that the system menu shows when the user performs the menu behavior. For widgets, the first item on the system menu will be to view the menu options for the widget. When the user makes that selection, your widget’s BehaviorDelegate.onMenu() will be called. Glances
 Since API Level 3.1.0 The Fenix 6 moved glanceable information from a page carousel presentation to a list presentation. Each item offers a small area of real-estate to display information. If the user selects it the full widget is launched. When launched in this context, the widget base view don’t have the input restrictions regularly applied. Glance views run in a limited runtime space, with reduced memory and privileges and do not accept any input. When your widget is launched, you can check if DeviceInfo has isGlanceModeEnabled defined. If it does, you can also determine what the value is. If glance mode is enabled you can launch directly into the interactive portion of your widget. Otherwise you should launch the base view. See the Glance section for more information. Designing a Widget
 Your widget should be designed with both a glance and a base view. Your base view and glance should both offer a simple summary of the presented data. If the user performs a behavior (pressing the start button, touching the screen) that indicates they want more information, your widget should then push a view that allows navigation through the offered information. Device Apps
 Device apps are by far the most robust type of app available. These allow the most flexibility and customization to the app designer. They also provide the most access to the capabilities of the wearable device, such as accessing ANT+ sensors, the accelerometer and reading/recording FIT files. The suite of Garmin wearables are each designed to fulfill different needs and behaviors of active individuals, from endurance runners to triathletes to outdoor enthusiasts and adventurers. The core focus of these wearables centers on the recording and tracking of activities, from running to hiking to skiing. Users of the different Garmin wearables desire to track specific types of data and great care should be taken in designing your watch app to understand the needs of the user doing a particular activity or task and provide appropriate feedback, metrics and configurability to give the user the best experience. The initial view of the app should be a call to action. If your app represents some form of activity like hiking or weight lifting, the initial view of the app should ask to be started. Present the user with information from the sensors that make them want to hit the start button. Garmin commonly uses page loops to present multiple pages of information. Page loops are a carousel of pages, each one a unique view on the activity. This is a common metaphor in Garmin products and easy to implement in Connect IQ. When your app is presenting large amounts of text to the user, try to keep information in the center of the screen. On round screens the top and bottom of the screen provide a limited viewing area. Use the top for contextual headers, scroll arrows, and other small hints of information. Audio Content Providers
 Garmin media enabled devices are designed for active lifestyle users who want to listen to music without carrying their phone on their rides, runs or other activities. The media player allows the user to listen to their music, podcasts, and audio-books on the go. Audio content providers function as plug-ins for the media player on media-enabled product. These apps act as bridges between music services and the Garmin media player. Audio content providers allow users to select content from a content provid.er, sync the content over Wi-Fi to the device, and listen to it These apps have three contexts: Playback Configuration: Allows the user to select what content they want to listen to from what they have synced
 Sync: The device activates Wi-Fi and allows the audio content provider to request content for later offline playback
 Playback: The playback experience. The audio content provider tells the media player what to play based on the user’s selection.
 Your app should implement an Application.AudioContentProviderApp instead of the traditional Application.AppBase . This class adds the following methods: Method Purpose 
 AudioContentProviderApp.getContentDelegate() Get a Media.ContentDelegate for use by the system to get and iterate through media content on the device. 
 AudioContentProviderApp.getPlaybackConfigurationView() Get the initial view for configuring playback. This is the main view when launched by the media player. 
 AudioContentProviderApp.getProviderIconInfo() Get audio provider icon information. 
 AppBase.getSyncDelegate() Get a Communications.SyncDelegate object that communicates sync status to the system for syncing media content to the device. 
 Sync Configuration has been deprecated. We recommend providing the user a mechanism to download content inside of the playback configuration. See the How do I create an Audio Content Provider? section for more information.


# [Monkey C](https://developer.garmin.com/connect-iq/monkey-c/)nMenu Monkey C Hello Monkey C!
 There is no better way to learn Monkey C than by jumping right in. Let’s take a look at the application object of a watch face. using Toybox.Application as App; using Toybox.System; class MyProjectApp extends App.AppBase { // onStart() is called on application start up function onStart(state) { } // onStop() is called when your application is exiting function onStop(state) { } // Return the initial view of your application here function getInitialView() { return [ new MyProjectView() ]; } } If this looks familiar and non-threatening, that’s the point. Monkey C is intended to be the language you didn’t know you already knew. At the top is a using statement, which is analogous to C++’s using statement, or an import in Java™, Ruby, or Python™. using statements lexically bring modules into our name space. After a using clause, we can refer to a module by its shortened name (in this case System ). Toybox is the root module for Monkey C system modules; all the cool toys are kept in there. To print out values to the debug console, use: System.println( "Hello Monkey C!" ); System refers to the Toybox.System module we imported with the using statement. Unlike Java namespaces, modules in Monkey C are static objects that can contain functions, classes, and variables. The println() function should be familiar to Java programmers—it prints a string and automatically adds a new line. The System module has a number of useful functions: print and println send output to the console
 getTimer returns the current millisecond timer. The value is a 32 bit integer representing the number of milliseconds the system has been running. The value can be used for timing but is allowed to roll over.
 getSystemStats provides statistics from the runtime system
 exit will terminate your application
 error will exit your application while logging an error message
 
 Differences From Other Languages
 As Italian and Spanish derive from Latin, Monkey C derives heavily from other popular languages. C, Java™, JavaScript, Python™, Lua, Ruby, and PHP all influenced the design for Monkey C. If you are familiar with any of those languages, Monkey C should be easy to pick up. Java
 Like Java, Monkey C compiles into byte code that is interpreted by a virtual machine. Also like Java, all objects are allocated on the heap, and the virtual machine cleans up memory (Java through garbage collection, Monkey C through reference counting). Unlike Java, Monkey C does not have primitive types—integers, floats, and chars are objects. This means primitives can have methods just like other objects. While Java is a statically typed language, Monkey C is duck typed . In Java, the developer must declare the types for all parameters of a function, and declare the return value type. The Java compiler checks these at compile time to ensure type safety. Duck typing is the concept of “if it walks like a duck, and quacks like a duck, then it must be a duck” [1] . For example: function add( a, b ) { return a + b; } function thisFunctionUsesAdd() { var a = add( 1, 3 ); // Return 4 var b = add( "Hello ", "World" ); // Returns "Hello World" } The Monkey C compiler does not verify type safety, and instead causes a runtime error if a function mishandles a method. Monkey C modules serve a similar purpose as Java packages, but unlike packages, modules can contain variables and functions. It is common for static methods to exist in the module as opposed to a particular class. Lua/JavaScript
 The main difference between JavaScript or Lua and Monkey C is that functions in Monkey C are not first class. In JavaScript, a function can be passed to handle a callback: function wakeMeUpBeforeYouGoGo() { // Handle completion } // Do a long running thing, and pass callback to call when done. doLongRunningTask( wakeMeUpBeforeYouGoGo ); In Lua, to create an object, you bind functions to a hash table: function doSomethingFunction( me ) { // Do something here } // Constructor for MyObject function newMyObject() { local result = {}; result["doSomething"] = doSomethingFunction; } Neither of these techniques works in Monkey C, because functions are bound to the object they are created in. To create a callback in Monkey C, create a Method object . Method objects are a combination of the function and the object instance or module they originate from. Ruby, Python, and PHP
 Objects in Ruby and Python are hash tables, and have many of the properties of hash tables. Functions and variables can be added to objects at run time. Monkey C objects are compiled and cannot be modified at runtime. All variables have to be declared before they can be used, either in the local function, the class instance, or in the parent module. When importing a module, all classes inside the module have to be referenced through their parent module. You import modules, not classes, into your namespace. This is different than Monkey Typing, where a thousand monkeys over infinite time write the works of Shakespeare. &nbsp;↩


# [Objects and Memory](https://developer.garmin.com/connect-iq/monkey-c/objects-and-memory/)nMenu Monkey C Objects, Modules, and Memory
 Objects are created with the class keyword. Classes allow data and operations to be bound together on an object. In Monkey C, variables, functions, and other classes can be defined within a class. Constructors
 When an object is instantiated with the new keyword, the memory is allocated and the initialize method is called: class Circle { protected var mRadius; public function initialize( aRadius ) { mRadius = aRadius; } } function createCircle() { var c = new Circle( 1.5 ); } Within a method implementation you can refer to your current instance using either the self or me keywords. class A { public var x; public var y; public function initialize() { me.x = "Hello"; // Set current instance x variable self.y = "Hello"; // Set current instance y variable } } To instantiate an inner class of nested classes, you must first instantiate the outer class. However, unlike Java, nested classes in Monkey C do not have access to the members of the enclosing class. Inheritance
 Monkey C uses the extends keyword to support class inheritance: import Toybox.System; class A { function print() { System.print( "Hello!" ); } } class B extends A { } function usageSample() { var inst = new B(); inst.print(); // Prints "Hello!" } You can call superclass methods by using the super class’s symbol: import Toybox.System; class A { function print() { System.print( "Hello!" ); } } class B extends A { function print() { // Call the super class implementation A.print(); // Amend the output System.println( "Hola!" ); } } function usageSample() { var inst = new B(); inst.print(); // Prints "Hello! Hola!" } Data Hiding
 Class members have three levels of access — public , protected , and private . public is the default, but it can also be explicitly specified. When the public access modifier is used for an enum, variable, or function, those members are visible to all other classes. The private modifier specifies that the member can only be accessed in its own class. The protected modifier specifies that the member can only be accessed by its own class or one of its subclasses. The hidden keyword is synonymous with the protected keyword. import Toybox.System; class Foo { public var publicVar; protected var _protectedVar private var _privateVar; public function initialize() { publicVar = "a"; _protectedVar = "b"; _privateVar = "c"; } } class Bar extends Foo { public function initialize() { // Initialize the parent Foo.initialize(); publicVar = "b"; _protectedVar = "c"; // Error - can't access private member _privateVar = "d"; } } function usageSample() { var v = new Foo(); System.println( v.publicVar ); // Error - cannot access protected member System.println( v._protectedVar ); // Error - cannot access private member System.println( v._privateVar ); } Polymorphism
 Most object-oriented languages support a concept of polymorphic functions in which a function can have multiple definitions based on the input parameter quantity and type. Partially because of its duck-typed nature, Monkey C does not support this kind of runtime polymorphism. Because function parameters are duck typed, it is possible to implement some level of polymorphism using the instanceof operator: import Toybox.Lang; function aPolymorphicFunction(a) { switch(a) { case instanceof String: return doTheStringVersion(a); case instanceof Number: case instanceof Long: return doTheNumericVersion(a); default: throw new UnexpectedTypeException(); } } This kind of pattern works when the function expects the same number of inputs. If your function needs to expect multiple inputs, another pattern is to use the options dictionary. You can use symbols to define the keys to maximize processing efficiency: x = aPolymorphicFunction({ :param1=&gt;"Foo", :param2=&gt;"Bar" }) This pattern is good when you want to leave room for an API to expand in the future. Strong and Weak References
 Monkey C is reference counted, which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly which is important in low memory environments. The kryptonite of reference counting are circular references . A circular reference happens when a cycle is formed in the reference chain. For example, imagine object C references object A, object A references object B, and object B references object A. Now C gets invited to sit at the cool-kid table, so it dereferences A so it can hang out with its real friends. [1] This forms a roundabout to nowhere. The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other. The memory used by A and B are now unavailable to objects from the cool-kids table. Sometimes B really does need to reference A. In these cases, you can use a weak reference . A weak reference is an object that keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled. To create a weak reference you use the weak() method. Weak is a method in Lang.Object and is available to all Monkey C objects. // I would make a "Hans and Franz" reference but I // think certain advertising has made them uncool. var weakRef = obj.weak() If you are calling weak on one of the immutable types ( Number , Float , Char , Long , Double , String ), then it returns the object itself. Otherwise it will return a WeakReference instance. //! A weak reference is a loosely bound reference to //! another object. If all strong references have been //! freed, the get() method will return null. //! This allows the developer to avoid circular references. //! @since 1.2.0 class WeakReference { //! Return if the reference is still alive. //! @return true if object is still alive, false otherwise. //! When you are dead I will be STILL ALIVE //! I feel fantastic and I am STILL ALIVE function stillAlive(); //! Get the object referenced. //! @return Object referenced, or null if object is no //! longer alive. function get(); } You can use the stillAlive method to check if the reference has been cleaned up. Use get to create a strong reference to the object. Only keep the strong reference during the scope you need it! // This is a triumph... if( weakRef.stillAlive() ) { var strongRef = weakRef.get(); strongRef.doTheThing(); } Handles and Heap Allocation
 The heap memory limit varies on a per device basis. Starting with version 2.4.x, Connect IQ uses a dynamically allocated heap for memory handles. Each unique object takes up one memory handle. Object references do not have unique allocations and only reference the memory handle of the object. Older versions of Connect IQ have a smaller, static limit for objects defined by the device. Reaching the object limit in either version will cause a runtime error. Modules
 Modules in Monkey C allow for the scoping of classes and functions. Unlike Java packages, Monkey C modules have many of the same properties as classes. You can have variables, functions, classes, and other modules at the module level: module MyModule { class Foo { var mValue; } var moduleVariable; } function usageSample() { MyModule.moduleVariable = new MyModule.Foo(); } However, unlike classes in Monkey C, modules have no concept of inheritance or data hiding (the extends , private , and protected keywords are not supported for modules). Import and Using Statements
 You can bring a module into your scoping level with the import keyword. When you use import it will bring the module suffix and all classes in the module into the type namespace . This allows classes in a module to be accessed without the module suffix, making for easier typing. Function invocations still require the module suffix to be accessed. import Toybox.Lang; import Toybox.System; // Import lets you say goodbye to // module prefixes var globalX as Number or String = 0; function hasANumber() { globalX = 2; // Allowed globalX = "2"; // Allowed // Still require prefixes in code System.println("globalX = " + globalX); } You can also bring a module into your scoping level with the using keyword. using allows a module to be imported into another class or module by a symbol: using Toybox.System; function foo() { System.print( "Hello" ); } The as clause provides a way to assign a module to a different name within scope. This is useful for shortening module names or when you simply disagree with our naming scheme: using Toybox.System as Sys; function foo() { Sys.print( "Hello" ); } using statements are scoped to the class or module in which they are defined. The difference between import and using is subtle. import brings the module name and class names into the namespace, where using only brings the module name into the namespace. If you are using monkeytypes you should use import exclusively, as it will save you a lot of redundant module references. Finally, the as clause is only supported for using statements. Scoping
 Monkey C is a message-passed language. When a function is called, the virtual machine does a look up operation at runtime to find the function being called. Here is the hierarchy that it will search: Instance members of the class
 Members of the superclass
 Static members of the class
 Members of the parent module, and the parent modules up to the global namespace
 Members of the superclass’s parent module up to the global namespace
 For example, if function a() is called on an instance of Child() , it will be able to access non-member functions b() , c() , and d() when: b() is a member of the parent module of the object
 c() is a static member of the object
 d() is a member of the parent module of the parent module, also known as the globals module
 
 The code below tries to clarify: import Toybox.System; // A globally visible function function d() { System.print( "this is D!" ); } module Parent { // A module function. function b() { System.print( "This is B!" ); d(); // Call a globally visible function } // A child class of a Parent module class Child { // An instance method of Child function a() { System.print( "This is A!" ); b(); // Call a function in our parent module c(); // Call a static function within the class. d(); // Call a globally visible function. } // A static function of Child. // Note that static methods can't call instance method but still have // access to parent modules. static function c() { System.print( "This is C!" ); b(); // Call a method in the parent module. d(); // Call a globally visible function } } } Sometimes you want to run your search from the global namespace instead of your current scope. You can do this using the bling symbol $ . The bling symbol refers to global scope: function helloFunction() { System.println("Hello Hello"); } class A { function helloFunction() { System.println("Every time I say goodbye you say hello"); } function b() { // Call global helloFunction $.helloFunction(); // Call instance helloFunction helloFunction(); } } If you are referring to a global variable, using bling can improve runtime performance [2] : var globalScopedVariable = "Global String"; module A { class B { function c() { // To find globalScopedVariable, the VM will search at runtime: // instance B // instance B's superclass Toybox.Lang.Object // Module A // Module A's parent globals // and finally find globalScopedVariable. System.println(globalScopedVariable); // This will search only the global namespace for globalScopedVariable. // Thanks bling! System.println($.globalScopedVariable); } } } Because Monkey C is dynamically typed, referencing a global variable will search your Object’s inheritance structure and the module hierarchy before it will eventually find the global variable. Using the bling symbol we can search globals directly. Not that this ever happened to the author. &nbsp;↩ 
 Do not forget to match your bling with pieces of flair; you can’t have enough of either. &nbsp;↩


# [Functions](https://developer.garmin.com/connect-iq/monkey-c/functions/)nMenu Monkey C Functions
 Functions are the meat [1] of your program. Functions define discrete callable units of code. Monkey C functions can take arguments, but because Monkey C is a dynamically typed language the argument types is not declared; just its name. Also, it is not necessary to declare the return value of a function, or even if a function returns a value, because all functions return values. Functions can exist in a class or module, or appear in the global module. Variables, Expressions, and Operators
 The basic types supported by Monkey C are: Integers - 32-bit signed integers
 Floats - 32-bit floating point numbers
 Longs – 64-bit signed integers
 Doubles – 64-bit floating point numbers
 Booleans - true and false 
 Chars - Unicode characters
 Strings - strings of characters
 Objects – Instantiated objects (defined with the class keyword)
 Arrays - Allocated with the syntax new [X] where ‘X’ is an expression computing the size of the array
 Dictionaries - Associative arrays, allocated with the syntax {} 
 
 Keywords
 Here is a list of keywords in the Monkey C programming language. You cannot use any of the following as variables or symbols in your programs. The keywords native and alias are reserved, even though it is not currently used. true , false , null , NaN , new , and , and or might seem like keywords, but they are actually literals and operators; you cannot use them as identifiers in your programs. as const enum has module self using 
 break continue extends hidden private static var 
 ` case default finally if protected switch while 
 catch do for instanceof public throw 
 class else function me return try 
 Declaring Variables
 All local variables must be declared ahead of time using the var keyword. In the Monkey C language, all values (including numeric values) are objects. var n = null; // Null reference var x = 5; // 32-bit signed integers var y = 6.0; // 32-bit floating point var l = 5l; // 64-bit signed integers var d = 4.0d; // 64-bit floating point var bool = true; // Boolean (true or false) var c = 'x'; // Unicode character var str = "Hello"; // String var arr = new [20 + 30]; // Array of size 50 var dict = { x=&gt;y }; // Dictionary: key is 5, value is 6.0 var z = arr[2] + x; // Null pointer waiting to happen Monkey C supports the following operators: Precedence Operator Description 
 1 new creation 
 ! logical NOT 
 ~ bitwise NOT 
 ( ) function invocation 
 2 * multiplication 
 / division 
 % modulo 
 &amp; bitwise AND 
 &lt;&lt; left shift 
 &gt;&gt; right shift 
 3 + addition 
 - subtraction 
 | bitwise OR 
 ^ bitwise XOR 
 4 &lt; less than 
 &lt;= less than or equals 
 &gt; greater than 
 &gt;= greater than or equals 
 == equals 
 != not equals 
 5 &amp;&amp; logical AND 
 and 
 6 || logical OR 
 or 
 7 ?: conditional 
 Symbols
 Symbols are lightweight constant identifiers. When the Monkey C compiler finds a new symbol, it will assign it a new unique value. This allows symbols to be used as keys or constants without explicitly declaring a const or enum: var a = :symbol_1; var b = :symbol_1; var c = :symbol_2; Sys.println( a == b ); // Prints true Sys.println( a == c ); // Prints false Symbols can be useful when wanting to create keys without having to declare an enum: var person = { :firstName=&gt;"Bob", :lastName=&gt;"Jones" }; Constants
 Constants are named, immutable values declared with the const keyword. These are useful for storing unchanging values that may be used repeatedly throughout code. Constants must be declared at the module or class level; they cannot be declared within a function. Constants support the same types as listed for variables . It is important to note that with data structures like arrays, const functions similar to Java’s final keyword. For example, a const array prevents the array from being replaced by a new instance, but the elements of the array may be modified. const PI = 3.14; const EAT_BANANAS = true; const BANANA_YELLOW = "#FFE135"; Enumerations
 Enumerations are explicit or auto-incrementing constant mappings from symbol to integer. Unless explicity set (see the second example), each proceeding symbol is automatically assigned the value of its predecessor plus one, starting with 0 . So, in the following example, the symbol Monday is automatically assigned the value 0 , Tuesday is assigned 1 , and so on. These symbols can be used just like constant variables (which is essentially what they are). Enums must be declared at the module or class level; they cannot be declared within a function. enum { Monday, // Monday = 0 Tuesday, // Tuesday = 1 Wednesday // Wednesday = 2 // ...and so on } enum { x = 1337, // x = 1337 y, // y = 1338 z, // z = 1339 a = 0, // a = 0 b, // b = 1 c // c = 2 } Calling Methods and Functions
 To call a method within your own class or module, simply use the function call syntax: function foo( a ) { //Assume foo does something really impressive } function bar() { foo( "hello" ); } If calling on an instance of an object, precede the call with the object and a ‘ . ’. When accessing class members, public and protected variables should be accessed using either one of the following formats: var x = mMemberVariable; var y = self.mMemberVariable; Overridden parent member functions should be accessed using the following syntax: class A { function overridableMethod() { System.println("I am A!"); } } class B extends A { function overridableMethod() { System.println("B wins!"); A.overridableMethod(); } } The syntax of SuperClass.memberVariable is not supported in the Monkey C language. Always use self to access member variables of super classes. If Statements
 if statements allow branch points in your code: myInstance.methodToCall( parameter ); if ( a == true ) { // Do something } else if ( b == true ) { // Do something else } else { // If all else fails } // Monkey C also supports the ternary operator var result = a ? 1 : 2; The expression inside the if statement is required to be an expression; assignments are not allowed. Things that will evaluate to true are: true 
 A non-zero integer
 A non-null object
 
 Switch Statements
 Like if statements, switch statements also allow branch points in your code. Deciding whether to use if statements or a switch statement is based on readability and the expression that the statement is testing. A switch statement tests expressions based only on a single object. Like if statements, the expression inside the switch statement is required to be an expression; assignments are not allowed. You can have any number of case statements within a switch statement. Each case is followed by the object or instanceof object to be compared to and a colon: switch ( obj ) { case true: // Do something break; case 1: // Do something break; case "B": { // Do something break; } // Executed based on the type // instead of the value case instanceof MyClass: // Do something break; default: // If all else fails break; } // Monkey C also supports fall-through into the next case statement switch ( obj ) { case false: // Do something // Fall through and execute the code in the next case block case 2: { // Do something break; } case instanceof MyOtherClass: // Do something break; case "B": // Do something // Fall through and execute the code in the default block default: // If all else fails break; } The instanceof operator is discussed in more detail later in this guide. When the object being switched on is either equal to or an instance of the value defined in a case statement, the statements following that case will execute until a break statement is reached. Each break statement terminates the enclosing switch statement. Without a break statement, case statements fall through: all statements after the matching case label are executed in sequence, regardless of the expression of the subsequent case labels, until a break statement is encountered. A final break statement is not required because control flow will just naturally fall out of the switch statement. A switch statement can also have a single optional default case, which is not required to appear at the end of the switch statement. The default case handles all objects that are not explicitly handled by one of the case statements. Switch Block Variable Scoping
 The body of a switch statement is known as the “switch block”. Variables declared within the switch block will be scoped at the switch block level. Variables defined within curly braces of a case block will be scoped at that code block level. Additionally, due to the nature of fall-through cases, all variables defined at the switch block level must be initialized before being used in any subsequent case statements. For instance: switch ( obj ) { case true: var aaa = 1; // Scoped at the switch block level ... case 1: var zzz = aaa; // Results in a compiler error because aaa was not initialized in this case block ... break; case "B": { var aaa = true; // Scoped at the code block level within the curly braces, no scoping conflict with variable aaa at the swtich block level ... break; } case instanceof MyClass: var aaa = "Hello!" // Results in a compiler error because aaa has already been defined in the switch block ... default: aaa = 0; // aaa was defined in the first case and initialized at the beginning of the default case, no errors! var good = aaa; ... break; } Loops
 Monkey C supports for loops, while loops, and do/while loops. while and do/while loops have a familiar syntax: // do/while loop do { // Code to do in a loop } while( expression ); // while loop while( expression ) { // Code to do in a loop } Loops must have braces around them because single-line loops are not supported: // Monkey C does allow for variable declaration in for loops for( var i = 0; i &lt; array.size(); i++ ) { // Code to do in a loop } Control within loops can be managed by using the break and continue statements. These should also have familiar behavior: // This for loop should only print 5, 6, and 7. for (var i = 0; i &lt; 10; i += 1) { if (i &lt; 5) { continue; } System.println(i); if (7 == i) { break; } } Returning Values From Functions
 All functions return values in Monkey C. You can explicitly set the return value by using the return keyword: return expression; The expression is optional. Functions without a return statement automatically return the last value operated on. Instanceof and Has
 As a duck-typed language, Monkey C gives the programmer great flexibility, but the trade off is that the compiler cannot perform the type checking like in C, C++ or Java. Monkey C provides two tools to do runtime type checking— instanceof and has . The instanceof operator offers the ability to check if an object instance inherits from a given class. The second argument is the class name to check against: var value = 5; // Check to see if value is a number if ( value instanceof Toybox.Lang.Number ) { System.println( "Value is a number" ); } The has operator lets you check if a given object has a symbol, which may be a public method, instance variable, or even a class definition or module. The second argument is the symbol to check for. For example, assume we have magnetometer libraries in Toybox.Sensor.Magnetometer , but not all products have a magnetometer. Here is an example of changing your implementation based on those criteria: var impl; // Check to see if the Magnetometer module exists in Toybox if ( Toybox has :Magnetometer ) { impl = new ImplementationWithMagnetometer(); } else { impl = new ImplementationWithoutMagnetometer(); } Monkey C’s object-oriented design patterns in conjunction with the has and instanceof operator enables software that has implementations for many devices in one code base. Callbacks
 Functions in Monkey C are not first class, meaning you cannot pass them as objects directly for use in other functions. However, using the method() function inherited from Toybox.Lang.Object , a class instance can create a Method object, which provides a way to invoke it as a callback method. class Foo { function operation(a, b) { // The code here is really amazing. Like mind blowing amazing. You wish this method was in your program. } } function usageSample() { // Create a new instance of Foo var v = new Foo(); // Get the callback for the operation method from the instance of Foo. var m = v.method(:operation); // Invoke v's operation method. m.invoke(1,2); } A Method object will invoke a method on the instance of the object it came from. It keeps a strong reference to the source object. Unlike classes, Modules do not inherit from Object so do not have access to the method() function. However, a new instance of Method can be created, which allows module-level functions to be invoked as callbacks in a similar fashion: import Toybox.Lang; module Foo { function operation() { // Do something } } function moduleSample() { var v = new Method(Foo, :operation); v.invoke(); } Tofu for the vegetarians, BBQ for Kansans… &nbsp;↩


# [Containers](https://developer.garmin.com/connect-iq/monkey-c/containers/)nMenu Monkey C Containers
 Monkey C has two container types built into the language: Arrays and Dictionaries. Arrays
 Arrays in Monkey C, like variables, are typeless, it is not necessary to declare a data type. There are two forms for creating a new array. To create an empty array of a fixed size , use this: // Create a typeless array var untypedArray = new [size]; // Create a typed array var typedArray = new Array&lt;Number&gt;[size]; To pre-initialize an array, this syntax can be used: // New array. Will be typed as a Tuple // [Number, Number, Number, Number, Number] var untypedArray = [1, 2, 3, 4, 5]; // New typed array var typedArray = [1, 2, 3, 4, 5] as Array&lt;Number&gt;; Elements are expressions, so multidimensional arrays can be created using this syntax: var array = [ [1,2], [3,4] ]; Monkey C does not have a direct way of creating an empty two-dimensional array, one may be initialized with this syntax: // Shout out to all the Java programmers in the house var array = new [first_dimension_size]; // Initialize the sub-arrays for( var i = 0; i &lt; first_dimension_size; i += 1 ) { array[i] = new [second_dimension_size]; } Dictionaries
 Dictionaries, or associative arrays, are a built-in data structure in Monkey C: var dict = { "a" =&gt; 1, "b" =&gt; 2 }; // Creates a dictionary System.println( dict["a"] ); // Prints "1" System.println( dict["b"] ); // Prints "2" System.println( dict["c"] ); // Prints "null" To initialize an empty dictionary, use the following syntax: var x = {}; // Empty dictionary A type suffix can be added when creating new Dictionary objects: var x = {} as Dictionary&lt;Symbol, String&gt;; // Valid x[:option] = "value"; // Invalid x["option"] = "value"; By default, objects hash on their reference value. Classes should override the hashCode() method in Toybox.Lang.Object to change the hashing function for their type: class Person { // Return a number as the hash code. Remember that the hash code must be // the same for two objects that are equal. // @return Hash code value function hashCode() { // Using the unique person id for the hash code return mPersonId; } } Dictionaries automatically resize and rehash as the contents grow or shrink. This makes them extremely flexible, but it comes at a cost. Insertion and removal of the contents can cause performance problems if there is accidental or excessive resizing and rehashing. Also, because hash tables require extra space for allocation, they are not as space-efficient as either objects or arrays.


# [Monkey Types](https://developer.garmin.com/connect-iq/monkey-c/monkey-types/)nMenu Monkey C Monkey Types
 Monkey Types is the gradual type system for the Monkey C language. The type system is designed to recognize Monkey C’s historically duck-typed nature but add the necessary components to type check your applications at compile time. Monkey Types has the following goals: Compatibility - Breaking changes to the Monkey C language would require rework to thousands of Connect IQ apps. Monkey Types extends the Monkey C grammar but avoids breaking changes. Monkey Types is also designed to not rely on additional run time information. Because of this, you can use Monkey Types for apps that run on all Connect IQ compatible devices.
 Ease of Use - The philosophy of Monkey C is to be the language you didn’t know you already knew . We want the experience of writing Monkey C to be like deja-vu. Likewise, Monkey Types borrows heavily from Kotlin, Swift, and Typescript in its design.
 Flexibility - Monkey Types is a gradual type system. You can leave the type scaffolding off if you choose, or you can strictly type your app.
 The Connect IQ type checker is disabled by default and is enabled with the -l compiler option. There are four levels of type checking: Option Level Description 
 -l 0 Silent No type checking; keep everything dynamically typed 
 -l 1 Gradual Type check any statement where typing can be inferred, otherwise stay silent 
 -l 2 Informative Type check only what has been typed, warn about ambiguity 
 -l 3 Strict Do not allow compiler ambiguity 
 Let’s cover the new syntax available for communicating type information to the type system. The as Clause
 Monkey Types introduces a new keyword as . You use as to bind a type to a member variable, module variable, function argument, or function return value. Locals are always type inferred at assignment. Once a type has been bound to a value, the compiler will only allow values of that type to be assigned. using Toybox.Lang; using Toybox.System; var globalX as Lang.Number = 0; function hasANumber() { globalX = 2; // Allowed globalX = "2"; // Not allowed System.println("globalX = " + globalX); } In this example we are declaring that global variable globalX will only accept values of Toybox.Lang.Number . Once that has been declared, the compiler will only allow values of that type to be assigned to globalX . Since Monkey C is a duck-typed language, only allowing a single type to be bound to a variable would be overly restrictive. An as clause is allowed to have an or clause attached if a variable accepts multiple types. using Toybox.Lang; using Toybox.System; var globalX as Lang.Number or Lang.String = 0; function hasANumber() { globalX = 2; // Allowed globalX = "2"; // Allowed System.println("globalX = " + globalX); } The import Statement
 In traditional Monkey C, the using statement brings a module suffix into the namespace of the file being processed. To access any functions, variables, or class definitions, the module suffix must be referenced. For adding type information, all that module prefixing is annoying. Monkey Types introduces the import statement. When you use import it will bring the module suffix and all classes in the module into the type namespace . This allows classes in a module to be accessed without the module suffix, making for easier typing. Functions still require the module suffix to be accessed. import Toybox.Lang; import Toybox.System; // Import lets you say goodbye to // module prefixes var globalX as Number or String = 0; function hasANumber() { globalX = 2; // Allowed globalX = "2"; // Allowed // Still require prefixes in code System.println("globalX = " + globalX); } Note import does not support using as for renaming modules in a source file [1] . Named Versus Anonymous Types
 As you can see from the above example, the type system can allow for complicated type definitions. There are times where a type pattern is repeated that you just want to refer to it by a name. A typedef statement allows you to create a named type in the application namespace. For example, the following would create a poly type named Numeric in the global namespace. The function add then binds Numeric to parameters a and b and its return value by having the as clauses refer to the Numeric type declaration. import Toybox.Lang; typedef Numeric as Number or Float or Long or Double; function add(a as Numeric, b as Numeric) as Numeric { return a + b; } If you do not wish to name your type declarations, you can always use the as clause to build the type declaration in line as an anonymous type. Types
 Monkey Types allows you to add a layer of type scaffolding to your Monkey C code. The type system allows for a lot more than associating variables with classes. This section will overview the type declarations you can use. Any
 Any variable, function argument, or function return value that does not have a type bound to it is of type Any. The Any type can be anything, including nothing. Values of type Any follow the traditional duck type rules of Monkey C. To bind Any to a value, simply do not add an as clause to it’s declaration. There is no keyword to bind Any to a value. Void
 The void type is only for return values, and communicates that a function does not allow return values. It also communicates that a function should not expect a return value by calling this function. import Toybox.Lang; function doNothing() as Void { // Compiler error - this is failing to // do nothing. return true; } function doSomething() as String { // Compiler error - cannot assign value // from a function that returns nothing var x = doNothing(); // Compiler error - doSomething should // return a String } Concrete
 Concrete types are a single reference to a declared class in the program namespace. This is the most traditional and most familiar use of typing. If a value is bound to a concrete type, it will only accept values of that class or any derived classes. import Toybox.Lang; import WoolMarket; class Wool { public var bagsFull; public function initialize(bags as Number) { bagsFull = bags; } } class Sheep { public var wool as Wool; public function initialize() { wool = new Wool(1); } } class BlackSheep extends Sheep { public function initialize() { Sheep.initialize(); wool = new Wool(3); } } function processSheep(baa as Sheep) { if(baa.wool != null) { WoolMarket.sellWool(baa.wool); } } function example() { // Allowed processSheep(new Sheep()); processSheep(new BlackSheep()); // Not allowed processSheep(new Wool()); } Note that concrete types do not implicitly accept null as a value. If you want a value to also accept null you must make a poly type (see Null for more information). Poly
 Poly types allow the concatenation of multiple types into a single type. This allows for the type system to model the duck-type nature of Monkey C. To create a poly type, you simply use the or clause when defining your type. A poly type will accept: A value whose type is bound to one of the types within the poly type
 A value bound to a poly type whose types are within the definition of the destination type
 import Toybox.Lang; typedef Addable as Number or Float or Long or Double or String; typedef Numeric as Number or Float or Long or Double; function add(a as Addable, b as Addable) as Addable { return a + b; } function subtract(a as Numeric, b as Numeric) as Numeric { return a - b; } function doWork() { // Allowed var x as Addable = add("1", "2"); // Not allowed; Addable has String which is // not within Numeric var y as Numeric = subtract(x, 2); } Interface
 An interface type requires a class to contain a set of member declarations. The members can be member variables and functions. import Toybox.Lang; typedef LittleBoys as interface { var frogs as Array&lt;Frogs&gt;; var snails as Array&lt;Snails&gt;; var puppyDogTails as Array&lt;PuppyDogTails&gt;; }; // Implements LittleBoys interface class MaleChild { var frogs as Array&lt;Frogs&gt;; var snails as Array&lt;Snails&gt;; var puppyDogTails as Array&lt;PuppyDogTails&gt;; } Note that the class does not require additional decoration to implement the interface. This allows anonymous interfaces to be defined within function arguments. // Processing function example(you as interface { var frogs as Array&lt;Frogs&gt;; }) Container
 The Monkey C language has two native container types, Array and Dictionary . While the Monkey Types system does not support generics, it does allow for the developer to type the value type of an Array or the key and value type of a Dictionary . import Toybox.Lang; typedef ContainerA as Array&lt;Number&gt;; typedef ContainerB as Dictionary&lt;String, Number&gt;; Container types only match other container types if both the key and value types are equivalent. An Array&lt;String&gt; only matches an Array&lt;String&gt; and not an Array&lt;String or Number&gt; . Monkey C does not infer container types at this time, so you will need to declare your containers. If you want to create a new typed array or dictionary you can use the following syntax: class ContainerClass { // Array of 10 items that takes only numbers var typedArray as Array&lt;Number&gt; = new Array&lt;Number&gt;[10]; // Initialized array var initializedArray as Array&lt;Number&gt; = [1, 2, 3, 4, 5] as Array&lt;Number&gt;; // Initialized dictionary var initializedDictionary as Dictionary&lt;String, String&gt; = {"this"=&gt;"that"} as Dictionary&lt;String, String&gt;; } Tuples
 A common pattern in Monkey C is to use arrays as structured groupings. Monkey types allows modeling an array by binding the indexed items to types. Think of Tuple types like Dictionary types, except the key is implied by the order. In the following example, the array being returned is automatically typed as a Tuple of types [ StartView, StartDelegate] . This is typed against the allowed return value [Views, InputDelegates] and found to match: function getInitialView() as [Views] or [Views, InputDelegates] { return [ new StartView(), new StartDelegate() ] ; } The rules of Tuple type A matching Tuple type B are as follows: Tuple A and B must be the same length
 For every index, every type in A must be an instance of B
 
 Arrays created with the [ value, value...] syntax will now be typed as a Tuple instead of an Array&lt;Any&gt; . You can use Container types if that better matches the pattern you are implementing, but Tuples have a natural compatibility with Container types. Tuples of type [A, B, C] shall be instance of Array&lt;A or B or C&gt; if the types A, B, and C are in the polytype definition of the container type. function sumArray(x as Array&lt;Numeric&gt;) as Number { var result = 0; for (var i = 0; i &lt; x.size(); i++) { result += x[i]; } return result; } function sumThisTuple() as Number{ // This should pass type checking because the // Tuple [Number, Number... ] should be an instanceOf Array&lt;Numeric&gt; return sumArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); } Tuple types are also more mutable. As the underlying array changes, they are modified as long as the type system can keep up. The type system will not track changes to the tuple’s types when passed as an argument to another method. function foo(x as [Number, Number, Number]) as [Number, Number, Number] { x[1] = "Hello"; // Allowed, type is now [Number, String, Number] return x; // Error, type mismatch } Dictionary
 A common pattern in Monkey C is to use an options dictionary as an argument. This allows for extensible APIs. Monkey Types allows modeling an options dictionary by binding key literals to types. import Toybox.Lang; function doWork(options as { :option1 as String, :option2 as { "name" as String, "value" as Number } }) If a dictionary is declared inline, the compiler will track the types bound to the values, and then type check to see if all the value types match. It will not require all keys to be provided, and it will not error if additional keys are added. doWork({:option1=&gt;"x", :option3=&gt;true}) Enumerations
 Enumerations can now be named types by appending a name to the declaration. Enumeration values will be bound to both their enumeration type as well as their value type. import Toybox.Lang; enum Dog { SPOT = "Spot", LUKE = "Luke", POCO = "Poco", COMMODORE = "Commodore", BINGO = "B_I_N_G_O" } function getDogName(dog as Dog) as String { // Return the dog name return dog.toString(); } Callback
 The base object of Monkey C contains the method method to create Method callback objects [2] . The callback type allows you to type Method objects based on what the expected parameters and return values are. import Toybox.Lang; function doWork( x as Method(a as Number) as String ) as String { return x.invoke(2); } Null
 Monkey Types treats Null as its own unique type. More importantly, Monkey Types requires explicit declaration if null is an allowed value. function doWork() as Number or Null The ? can be used with single type declarations to make it a null accepting poly type. function doWork() as Number? Type Matching and Ambiguity
 Because of the duck type nature of Monkey C, ambiguity is inherit to Monkey Types. Ideally, type systems would have very clear rules for if a type does or doesn’t match, but Monkey Types has True, False, and Maybe [3] . Assuming we have the following: var a as A; var b as B; a = b; // Is this assigment allowed? You can use the following table A↓ B→ Any Concrete Poly Interface Container Dictionary Enum Callback Null 
 Any True True True True True True True True True 
 Concrete Maybe True if B is or extends A Maybe if one of the poly types in B matches A, False otherwise False Maybe if A is a Dictionary or Array Maybe if A is a Dictionary, False otherwise True if enum value type matches A, False otherwise False False 
 Poly Maybe True if B is a type within A, False otherwise True if all references exist in both A and B. Maybe if there are some types in B not in A. False if no matching types between B and A True if B is a type within A, False otherwise True if B is a type within A, False otherwise True if B is a type within A, False otherwise True if B is a type within A, False otherwise True if B is a type within A, False otherwise True if B is a type within A, False otherwise 
 Interface Maybe True if B is an object that contains all members of interface A, False otherwise Maybe if the poly contains a matching type True if B’s interface contains all members in A. True if classes Array or Dictionary contains all members of interface, False otherwise True if class Dictionary contains all members of interface, False otherwise False False False 
 Container Maybe False Maybe if one of the poly types in B matches A, False otherwise False True if container type and key/value types match exactly, False otherwise False False False False 
 Dictionary Maybe False Maybe if one of the poly types in B matches A, False otherwise False True if all keys match the key type and values match the value type (if applicable), False otherwise True if all keys match the key type and values match the value type (if applicable), False otherwise False False False 
 Enum Maybe True if value type of enum value B matches concrete type A Maybe if one of the poly types in B matches A, False otherwise False False False True if enum types match, false otherwise False False 
 Callback Maybe False Maybe if one of the poly types in B matches A, False otherwise False False False False True if function signatures match, False otherwise False 
 Null Maybe False Maybe if one of the poly types in B matches A, False otherwise False False False False False True 
 The type checker can run at three different levels based on your level of comfort with ambiguity. Silent - Type match failures are marked as errors, but ambiguity is ignored
 Warning - Type match failures are marked as errors, and ambiguity is marked as a warning
 Error - Type match failures and ambiguity are marked as errors
 Compiling a code base with ambiguity muted can find obvious type errors, while compiling code when erroring on ambiguity requires adding type scaffolding throughout the code. Monkey Types is designed to allow you to build towards aggressive typing if you choose to, while still adding value if you don’t. Typing Within Functions
 Up until now we have been explicitly adding type scaffolding. While this makes for very readable and explicit code, it can add lots of boilerplate to implementation. Unlike with class instance variables, the Monkey Types system will infer the type of a local variable by tracking assignments. import Toybox.Lang; import OldMacDonaldsFarm; function handleDog(dog as Dog, here as Array, there as Array, everywhere as Array) { here.add(dog.woofWoof()); there.add(dog.woofWoof()); everywhere.add(dog.woofWoof()); } function handleCat(cat as Cat, here as Array, there as Array, everywhere as Array) { here.add(cat.meowMeow()); there.add(cat.meowMeow()); everywhere.add(cat.meowMeow()); } function eieio() { var here = [], there = [], everywhere = []; // Animal will be typed as a Dog based // on the assignment. No need to declare // it's type var animal = new OldMacDonaldsFarm.Dog(); // Allowed, animal is currently assigned a Dog value handleDog(animal, here, there, everywhere); // Animal will now be typed as a Cat based on // the assignment animal = new OldMacDonaldsFarm.Cat(); // Allowed, animal is currently assigned a Cat value handleCat(animal, here, there, everywhere); } The inference will follow through branches. If the type is unclear based on which branch is taken, the type system will make a poly type of the options until the next assignment. import Toybox.Lang; function process(a as Boolean) as Boolean? { var x = null; if(a) { x = true; } // At this point, x is now the poly type // Boolean or Null return x; } When a value has a known type definition, the type checker will validate if method calls are allowed. import Toybox.Lang; class A { function foo() {}; function bar() {}; } function process() { var a = new A(); a.foo(); // Allowed a.bar(); // Allowed a.fonz(); // Not allowed } With container types, it is also possible to bind a type to the initialized value. This will put controls on what can be assigned to the container, but allow the local to have any value. import Toybox.Lang; function example() { var a = {} as Dictionary&lt;String, String&gt;; a["key"] = "value" // &lt;-- Assignments to a's value must obey type a = null; // &lt;-- a is Any and can be assigned to null } Return Values and Void
 By default functions return Any. If you bind a type to a function return value, the type checker will ensure that you return values of that type. import Toybox.Lang; function isTrue() as Boolean { return "true"; // Not allowed } If your function does not have a return value, you can use the Void type. This will ensure the function doesn’t return values and error if a function tries to assign the return value of the function. Any and Type Ambiguity
 Any function parameter without a bound type will be of type Any. The ambiguity of the parameter will percolate to any member it interacts with in an expression. If you provide all type definitions, type checking can protect them from many kinds of common errors. However, just a little ambiguity can prevent any level of checking. Take this example where a function has a result check but does not have a argument type for a . import Toybox.Lang; function foo(a) as Integer? { // a is of type Any, so Monkey Types can't identify what doThis() is being called var x = a.doThis(); // x is of type Any, so we can't know what the result type is var y = x + 3; // What is Y? What is Why? What is Love? return y; } Because a is Any, Monkey Types can’t make any determination on any members of it, and by proxy Monkey Types can’t make determination on the results of accessing those members. Type Casting
 The as keyword can also be used in an expression to type cast a value to another type. This can be useful if the type is not clear to the type system. import Toybox.WatchUi; function process(a as View) { (a as MyView).specialMyViewMethod(); } Runtime Type Checking
 One of the goals of Monkey Types was to not add any runtime overhead. This allows Monkey Types to work on all Connect IQ compatible products out of the gate, but it does add a cost when it comes to runtime type checking. Put simply: while at compile time you have access to an expressive type system, at runtime instanceof and has have the same limits as they had before. For cases involving poly types of concrete types this can work fine. import Toybox.Lang; function example(x as Number or Float) as Boolean { switch(x) { case instanceof Number: doNumberImpl(x); break; case instanceof Float: doFloatImpl(x); break; } } Unfortunately not every scenario can be resolved this way. For example, lets say we had the following scenario: typedef Nimble as interface { function isNimble() as Boolean; }; typedef Quick as interface { function isQuick() as Boolean; }; function handleCandleStick(jack as Nimble or Quick) { if(jack instanceof Nimble and jack instanceof Quick) { if(jack.isNimble() and jack.isQuick() and jack has :jumpOverCandleStick) { jack.jumpOverCandleStick(); } } } In the case of handleCandleStick the interfaces Nimble and Quick are lexical types and only exist at compile time. This will cause a compiler error because instanceof can only be used on concrete classes and not lexical types. In this case we can use has to resolve this issue. function handleCandleStick(jack as Nimble or Quick) { if(jack has :isNimble and jack has :isQuick and jack has :jumpOverCandleStick) { if(jack.isNimble() and jack.isQuick()) { jack.jumpOverCandleStick(); } } } If-Splitting
 In languages like Java, an object’s type is assumed to be whatever it was declared to be. This can lead to some very redundant casting or generation of lots of unnecessary locals to communicate to the Compiler that something isn’t what it was declared to be. public boolean foo(SomeInterfaceType x) { if(x instanceof SomeConcreteType) { // My life will just be easier if I make // a new variable, even though it should // be possible to assume that x is // a SomeConcreteType SomeConcreteType y = (SomeConcreteType)x; // Do operations on y } } The Monkey C type system will take advantage of if-splitting, where the branch expression causes the types for variables to mutate within the true and false cases. import Toybox.Lang; public function foo(x as Number?) as Boolean { if(x != null) { // Within this block assume x is Number and not null } else { // Within this block assume x is null } } The ==, !=, and instanceof operators will mutate the types based on the following rules type == != instanceof !instanceof 
 Any Ignore Ignore Mutate type to instanceof type Ignore 
 Concrete Ignore Ignore Mutate type to instanceof type Ignore 
 Poly If == is null , mutate to Null type if != is null , mutate to poly type minus null . Mutate type to instanceof type Mutate type to poly type minus type from instanceof 
 Interface Ignore Ignore Mutate type to instanceof type Ignore 
 Container Ignore Ignore Ignore Ignore 
 Dictionary Ignore Ignore Ignore Ignore 
 Enum Mutate to enum value type Ignore Ignore Ignore 
 Callback Ignore Ignore Ignore Ignore 
 Null Ignore Ignore Ignore Ignore 
 Expressions can also be modified using the &amp;&amp; and || operators. With the &amp;&amp; operator, the mutation will carry through the expression, being further modified as the expression continues. import Toybox.Lang; typedef Addable as Number or Float or Long or Double or String; public function foo(x as Addable?) { // In the first clause, x is modified to remove the null // from the poly type. In the second clause, the new polytype // is modified to be a String concrete type. if(x != null &amp;&amp; x instanceof String) { // Within this block assume x is a string } } With || operators, a new poly type is created with the results of both operations import Toybox.Lang; typedef Addable as Number or Float or Long or Double or String; public function foo(x as Addable?) { if(x instanceof Number || x instanceof Float) { // Within this block assume x is a Number or Float } } When if-splitting on member variables, all type mutations will be removed if a function is invoked. Typing Modules and Classes
 Class member variables are bound to type Any by default. Unlike local variables, member variables are not type inferenced based on assignment. Adding type scaffolding to your member variables and names to your enumerations will allow for stronger type checking. Constants are typed based on assignment. class Example { // Member variable private var _x as Number = 0; // Enum values can be explicitly assigned, or by default will // be numerically incremented values. enum NamedEnum { NAMED_ENUM; } // Constants assume their type by assignment private const _constant = "Constant"; } If you add type scaffolding, you must either initialize the variable or allow it to be null . The below example will cause a compiler error: import Toybox.Lang; import Toybox.System; // Don't shoot class Messenger { private var _message as String; public function shareTheMessage() as Void { System.println(_message); } } The reason for the error is that _message is declared as a String, but left alone it’s initialized as null . Module variables either have to be initialized at declaration or allowed to be null , while object members can be initialized in the initialize function, as well. The following would address the error: import Toybox.Lang; import Toybox.System; // Don't shoot class Messenger { private var _message as String; public function initialize() { // Initialize message _message = ""; } public function shareTheMessage() { System.println(_message); } } Types and Inheritance
 When extending classes, the type system will use the following rules: If you extend a function from a parent with the same number of arguments but do not add type decoration, the types for the arguments and return value will be transferred verbatim from the parent implementation
 If you extend a function from a parent with the same number of arguments and add type decoration, you must match the number of arguments and type decoration exactly or the compiler will error
 This allows for existing Monkey C code that extends Toybox types to take advantage of type checking without having to add any type decoration. Application Scope Type Checking
 The type checker attempts to validate that any member fetched from a module or class is available in all of the same application scopes as the caller. If the developer is confident their code is application scope safe and the type checker still complains, this check can be disabled for background or glance scopes using the annotations :typecheck(disableBackgroundCheck) or :typecheck(disableGlanceCheck) , respectively. To disable checks for both background and glance scopes, use the annotation :typecheck([disableBackgroundCheck, disableGlanceCheck]) . It is understood that this is controversial. First, as has a whole new meaning now in the grammar, and using it for module renaming is confusing. Also, renaming modules in Monkey C has made it really difficult to write good shareable example code because everyone renames every module to their own preference. Yes, Gregorian is a big word and is annoying to type, but thats what we have auto-complete for. &nbsp;↩ 
 The method method that returns Method should not be confused with “The Method Method”, my upcoming self help book on evaluating self help books. &nbsp;↩ 
 I just met you | and this is crazy | but I’m an Any | so type match? Maybe… &nbsp;↩


# [Exceptions and Errors](https://developer.garmin.com/connect-iq/monkey-c/exceptions-and-errors/)nMenu Monkey C Exceptions and Errors
 Monkey C supports structured exception handling for non-fatal errors from which there can be recovery. The syntax should be familiar for Java and Javascript developers: try { // Code to execute } catch( ex instanceof AnExceptionClass ) { // Code to handle the throw of AnExceptionClass } catch( ex ) { // Code to catch all execeptions } finally { // Code to execute when } You can use the throw keyword to throw an exception. Creating an Exception
 If you are creating your own exception, follow these rules: Extend Toybox.Lang.Exception 
 Initialize the superclass in the initializer
 Assign a string message to the mMessage member variable
 
 For example, an app specific exception can be defined as follows: class AppSpecificException extends Lang.Exception { //! Constructor //! @param msg Message explaining cause function initialize(msg) { Exception.initialize(); self.mMessage = msg; } } Errors
 Because Monkey C uses dynamic typing, there are many errors for which the compiler cannot check. If the error is of high enough severity, it will raise an fatal API error and cause your app to terminate at runtime. These errors cannot be caught. Array Out Of Bounds An attempt is being made to reference an array outside of its allocated bounds Circular Dependency There is a loop in the dependency graph of a module or object that prevents a module or object from being constructed Communications Error An error has occurred in BLE communications File Not Found The app file could not be found, which is usually caused when trying to load a resource from the app file Illegal Frame The return address on the stack is corrupted Initializer Error An error occurred in an initializer Invalid Value An argument passed to a function or method is invalid Null Reference A value is being requested from a null value Out of Memory Indicates no more system memory is available for allocation Permission Required An attempt was made to use a restricted API without permission Stack Underflow The stack pointer went past the bottom of the stack memory limit Stack Overflow The stack pointer went past the top of the stack memory limit Symbol Not Found An attempt was made to access a variable or method that does not exist in the specified object or method System Error A generic error used by the Toybox APIs for fatal errors Too Many Arguments Too many arguments used by a method, which are currently limited to 10 arguments Too Many Timers Too many Timer::Timer objects for the target device were started Unexpected Type Indicates an operation being done on a variable that is unsupported by the type; for example, trying to perform a bitwise OR on two string Unhandled Exception An Exception was thrown but was not caught by an exception handler Watchdog Tripped A Monkey C function has executed for too long; watchdogs prevent a Monkey C program from hanging the system via an infinite loop


# [Annotations](https://developer.garmin.com/connect-iq/monkey-c/annotations/)nMenu Monkey C Annotations
 Monkey C allows associating symbols with class or module methods and variables. These symbols are currently written into the debug.xml file generated by the compiler, but may be used in the future to add new features without changing the Monkey C grammar: (:debug) class TestMethods { (:test) static function testThisClass( x ) } The following annotations have special meanings to the Monkey C compiler: :background Denotes code blocks available to the Background process. :debug Code blocks decorated with this annotation will not be included in release builds at compile time. :glance Denotes code blocks available to when running in Glance Mode. :release Code blocks decorated with this annotation will not be included in debug builds at compile time. :test Denotes test cases that are used as Run No Evil unit tests and are excluded from the application at compile time. :typecheck Code blocks decorated with this annotation can direct the type checker to perform / avoid certain checks. :initialized Member variables decorated with this annotation directs the type checker that it is safe to assume the variable will be initialized before it is referenced.


# [Coding Conventions](https://developer.garmin.com/connect-iq/monkey-c/coding-conventions/)nMenu Monkey C Coding Conventions
 Here are guidelines for Monkey C code: Naming
 Modules and Classes are camel-cased with the first letter in upper case.
 Functions are camel-cased with the first letter always being lower case.
 Private class member variables are camel cased with the first character being an underscore (_) and then the first letter lower case.
 Public class member variables are camel cased with the first letter lower case.
 Module variables should be camel cased with a lower cased first letter
 Enums must have a common prefix, e.g. COLOR_RED , COLOR_BLUE .
 In POMO (Plain Old Monkey C Objects) it is okay to have all public members.
 
 Source
 Put one class per Monkey C source file.
 Monkey C code should use spaces aligned four spaces per indent level. The Monkey C editor will automatically convert spaces to tabs and remove trailing white space.
 When defining modules, classes, functions, and enums, put the opening brace on the same line as the definition and the closing brace aligned with the first character as the definition.
 
 Definitions
 Avoid pure global variables when possible.
 Because modules are not purely lexical and have runtime memory cost, putting class definitions into the global module is acceptable.
 Avoid having public static members in class definitions; instead move those definitions into the parent module.
 In the first line of your class initialize function, always call the superclass initialize.
 
 Sample
 Here is a sample: class SampleName extends Toybox.Application.AppBase { public var publicVar; private var _privateVar; function initialize() { AppBase.initialize(); } // onStart() is called on application start up function onStart(state) { } // onStop() is called when your application is exiting function onStop(state) { } // Return the initial view of your application here function getInitialView(){ return [new SampleNameView(), new SampleNameDelegate()]; } }


# [Compiler Options](https://developer.garmin.com/connect-iq/monkey-c/compiler-options/)nMenu Monkey C Compiler Options
 The following are command line options for monkeyc : Short Option Long Option Argument Description 
 -d --device Device identifier Required for building a device executable. Specifies the device to target. 
 -e --package-app None Specifies that output is an IQ &nbsp;file for uploading to the app store. 
 -f --jungles Colon separated list of paths to jungle files Required . Each jungle specifies a project to include, which can include one app project and multiple monkey barrel projects. 
 -g --debug None Prints the debug output. 
 -h --help None Prints the help information. 
 -k --profile None Includes profiler information in the executable. When an executable with profiler information runs on device, the device will generate profiler information that can be analyzed in the simulator. 
 -l --typecheck 0 &nbsp;= off, 1 &nbsp;= gradual, 2 &nbsp;= informative, 3 &nbsp;= strict See the Monkey Types &nbsp;section for more information. 
 -o --output File to output Required . Specifies the output of the compiler. 
 -O --optimization 0 &nbsp;= None, 1 &nbsp;= Basic, 2 &nbsp;= Fast Optimizations, 3 &nbsp;= Slow Optimizations, p &nbsp;= Performance Optimizations, z &nbsp;= Code Space Optimizations Default is 1 &nbsp;for building in debug, and 2 &nbsp;for building in release. The numeric level can be suffixed with the letters, so -O 2pz &nbsp;is an allowed argument. 
 -r --release None Do not include debug information in PRG. 
 -t --unit-test None Include unit tests in the build. 
 -v --version None Prints the compiler version. 
 -w --warn None Off by default. Displays build warnings generated by the compiler. 
 -y --private-key Path to developer key Required . Specifies the developer key to use for signing the PRG or IQ file. 
 Debug Logging
 If you encounter a bug with the monkeyc compiler you will need to generate logs to provide with your report. Here are the options to create debug logs: Long Option Argument Description 
 --debug-log-level 0 &nbsp;= Errors, 1 &nbsp;= Basic Debug, 2 &nbsp;= Intermediate Debug, 3 &nbsp;= Verbose Debug Specifies the verbosity level for the output. 
 --debug-log-output Path to log file to generate Specifies the path to the log file to create 
 --debug-log-device Device identifier Allows limiting logs to a specific device when building a Monkey Barrel. 
 Be aware that the log levels include increasingly more information about your source project. If you want to keep your project information private, limit the logging level to 1 or less. More verbosity will make it easier for Garmin to debug any issues. Feature Control Options
 These options are used for controlling different features: Long Option Argument Description 
 --disable-api-has-check-removal None Disables optimizing out API has checks. 
 --disable-v2-opcodes None Disables the generation of V2 opcodes. 
 Private Options
 These options are typically already set and should not be necessary to use: Short Option Long Option Argument Description 
 -a --apidb Path to api.db Specifies path to API linking information. 
 -b --apimir Path to api.mir Specifies path to API type information. 
 -i --import-dbg Path to api.debug.xml Path to the API debug information. 
 -p --project-info Path to projectInfo.xml Path to SDK project definitions.


# [Core Topics](https://developer.garmin.com/connect-iq/core-topics/)nMenu Core Topics Overview
 This section covers the core topics of the Connect IQ platform. Connect IQ System
 Topic Section API API Level 
 Application Manifest Manifest 1.0.0 
 Application Permissions Permissions 1.0.0 
 Application Module Application Module Application.AppBase 1.0.0 
 System Module System Toybox.System 1.0.0 
 Properties Properties Application.Properties 1.0.0 
 Settings Settings Application.Properties 1.0.0 
 Persisting Data Persisting Data Application.Properties , Application.Storage 1.0.0 
 Build Configuration Build Configuration 1.0.0 
 Security Security 1.0.0 
 Intents Intents Toybox.System 2.2.0 
 Background Services Background Services Toybox.Background , System.ServiceDelegate 2.3.0 
 User Interface
 Topic Section API API Level 
 Views Views WatchUi.View 1.0.0 
 Drawables Drawables WatchUi.Drawable 1.0.0 
 Resources Resources WatchUi.BitmapResource , WatchUi.FontResource , WatchUi.AnimationResource 1.0.0 
 Localized Strings Strings 1.0.0 
 Graphics Graphics Toybox.Graphics Graphics.Dc 1.0.0 
 Input Handling Input Handling WatchUi.InputDelegate , WatchUi.BehaviorDelegate 1.0.0 
 Selectables and Buttons Selectables WatchUi.Selectable , WatchUi.Button 2.1.0 
 Layers Layers WatchUi.Layer 3.1.0 
 Animations Animation WatchUi.AnimationLayer 3.1.0 
 Watch Face and Data Field on Device Settings On Device Settings WatchUi.getSettingsView 3.2.0 
 Antialiased Draw Primitives Antialiasing Dc.setAntiAlias() 3.2.0 
 Layouts
 Topic Section API API Level 
 Creating a Layout Creating a Layout 1.0.0 
 Label Label WatchUi.Text 1.0.0 
 Drawables Drawables WatchUi.Drawable 1.0.0 
 Drawable Lists Drawable Lists WatchUi.Drawable 1.0.0 
 Shapes Shapes WatchUi.Drawable 1.0.0 
 Bitmaps Bitmaps WatchUi.Bitmap 1.0.0 
 Custom Drawables Custom Drawables WatchUi.Drawable 1.0.0 
 Text Area Text Area WatchUi.TextArea 3.1.0 
 Views
 Topic Section API API Level 
 Views Views WatchUi.View 1.0.0 
 Confirmation Dialog Confirmation Dialog WatchUi.Confirmation , WatchUi.ConfirmationDelegate 1.0.0 
 Generic Picker Generic Picker WatchUi.Picker 1.0.0 
 Progress Bar Progress Bar WatchUi.ProgressBar 1.0.0 
 Menu Menu WatchUi.Menu , WatchUi.MenuInputDelegate 1.0.0 
 Menu2 Menu2 WatchUi.Menu2 , WatchUi.Menu2InputDelegate 3.0.0 
 Map Views Mapping WatchUi.MapView , WatchUi.MapTrackView 3.0.0 
 Glances Glances WatchUi.GlanceView 3.1.0 
 Alerts Alerts WatchUi.DataFieldAlert 3.2.0 
 Communication
 Topic Section API API Level 
 Mobile SDK iOS , Android Communications.registerForPhoneAppMessages() , Communications.transmit() 1.0.0 
 JSON REST Requests JSON REST Requests Communications.makeWebRequest() 1.1.0 
 OAUTH OAUTH Communications.makeOAuthRequest() 1.3.0 
 Opening Web Pages on Mobile Open Web Page Communications.openWebPage() 1.3.0 
 Downloading Content Downloading Content Toybox.PersistedContent 2.2.0 
 Downloading over Wi-Fi Wi-Fi Bulk Downloads Communications.SyncDelegate 3.1.0 
 Low Power Wireless Communication
 Topic Section API API Level 
 ANT Generic ANT Channels Toybox.Ant 1.0.0 
 ANT Burst Data Burst Data Ant.BurstPayload 2.2.0 
 ANT Plus Ant Plus Toybox.AntPlus 2.2.0 
 Bluetooth Low Energy Bluetooth Low Energy Toybox.BluetoothLowEnergy 3.1.0 
 Sensors
 Topic Section API API Level 
 Activity Recording Activity Recording Toybox.ActivityRecording , Toybox.FitContributor 1.0.0 
 FIT Developer Fields Developer Fields Toybox.ActivityRecording , Toybox.FitContributor 1.0.0 
 Heart Rate Sensors Sensor.enableSensorEvents() 1.0.0 
 Temperature Sensors Sensor.enableSensorEvents() 1.0.0 
 Altitude Sensors Sensor.enableSensorEvents() 1.0.0 
 Pressure Sensors Sensor.enableSensorEvents() 1.0.0 
 Oxygen Saturation Sensors Sensor.enableSensorEvents() 3.2.0 
 Body Battery Body Battery SensorHistory.getBodyBatteryHistory() 3.3.0 
 Stress Stress SensorHistory.getStressHistory() 3.3.0 
 Positioning Positioning Toybox.Positioning 1.0.0 
 Accelerometer Accelerometer Sensor.registerSensorDataListener() 2.3.0 
 Magnetometer Magnetometer Sensor.registerSensorDataListener() 3.3.0 
 Gyroscope Gyroscope Sensor.registerSensorDataListener() 3.3.0 
 Weather Weather Toybox.Weather 3.2.0 
 Developer Lifecycle
 Topic Section API API Level 
 Libraries (Monkey Barrels) Shareable Libraries 1.0.0 
 Debugging Testing and Debugging 1.0.0 
 Unit Testing Unit Testing Toybox.Test 2.1.0 
 Publishing to the Store Publishing to the Store 1.0.0 
 Beta Apps Beta Apps 1.0.0 
 Trial Apps Trial Apps 2.3.0 
 Exception Reporting Exception Reporting Tool 3.1.0


# [Manifest and Permissions](https://developer.garmin.com/connect-iq/core-topics/manifest-and-permissions/)nMenu Core Topics Manifest File and Permissions
 All Connect IQ apps require a manifest file. The manifest file is an XML file that specifies application properties like the application type and the supported products. The manifest file is generated automatically when you create a project. All the sections of the manifest.xml can be edited in the Monkey C Extension manifest editor. The Edit as XML option will allow you access to the underlying definitions. Application Attributes
 The application element has a number of important attributes. The id field is a 128-bit UUID identifier. Unique identifiers can be generated with the UUID Generator or with standard tools. The entry attribute must specify the Application.AppBase object for your application. The name and launcherIcon attributes must specify a resource ID that is defined in the app resources. The name must reference a string entry in your strings resources, and the launcherIcon must reference a bitmap resource. See the Resources for more information. Note that the icon resource should not be re-used within your application; use a duplicate resource if you want to use the icon within the app. If you specify a launcherIcon , the system will resource compiler will auto size the resource to match the product icon size. If a launcherIcon isn’t specified, a default icon will be compiled into the application. The type field specifies what kind of application you are developing. Currently, Connect IQ supports five types of apps: watchface 
 datafield 
 widget 
 watch-app 
 audio-content-provider-app 
 The app type specified in the manifest file determines where your app appears on the device and which APIs the app can use. The minApiLevel field specifies the minimum Connect IQ API level that your app is compatible with. It serves to prevent you from targeting incompatible devices. The Monkey C extension allows you to select a minimum API level when creating a new app or editing the properties of an existing one. The micro version is written out to the manifest at version 1 (1.2.1 for example), but only the major and minor versions are considered when determining device support. Every application must include an AppBase object, which serves as the entry point for your application. The Monkey C extension will generate an AppBase object when a project is created. An AppBase object should override AppBase.getInitialView() to provide the view object to initially push. An array must be returned with either a view and a delegate, or just a one element array with the WatchUi.View object: return [ new MyView(), new MyDelegate() ]; Products
 Garmin makes a wide variety of products for many use cases, and Monkey C makes it easy to write for all our Connect IQ compatible devices. Monkey C asks the developer which Connect IQ devices they choose to support because it is impossible to know whether a future product may be incompatible with your app. As new Connect IQ compatible products appear on the market, the simulator will be updated to support them so developers can decide whether to support them. Products supported by an app are listed in the products block of the manifest file: &lt;iq:products&gt; &lt;iq:product id="round-watch"/&gt; &lt;/iq:products&gt; Permissions
 Certain modules expose personal information about the user or expose communication to the internet. To use these modules, permission must be requested from the user at the time of installation. To request permission, the module name must be added to the permissions list of the manifest file. More modules may be added to this list as modules are added to the API. To request permission, use the following syntax in the manifest file: &lt;iq:permissions&gt; &lt;iq:uses-permission id="Sensor"/&gt; &lt;/iq:permissions&gt; The following permissions are available: Permission Applicable Modules API Level Watch Face Data Field Widget App Audio Content Provider 
 Ant Ant 1.0.0 x x x x 
 Background Background 2.3.0 x x x x x 
 BluetoothLowEnergy BluetoothLowEnergy 3.1.0 x x x x 
 Communications Communications , Authentication 1.0.0 x [1] x [1] x x x 
 ComplicationProvider Complications 4.1.0 x x 
 ComplicationSubscriber Complications 4.1.0 x 
 Data Field Alert DataFieldAlert 3.2.0 x 
 Fit ActivityRecording , FitContributor 1.0.0 x 
 PersistedContent PersistedContent 2.2.0 x x x 
 Positioning Positioning.getInfo() , Positioning.enableLocationEvents() 1.0.0 x [2] x [2] x x x [2] 
 Sensor Sensor 1.0.0 x x x x 
 SensorHistory SensorHistory 2.1.0 x x x 
 SensorLogging SensorLogging 2.3.0 
 UserProfile UserProfile 1.0.0 x x x x x 
 Some products provide separation between activities and apps. If your app has the Fit permission, it will show in the Activities list. Languages
 Connect IQ apps can be localized across over 30 languages, and the languages your app support can impact what regions of the world your app is available in. In the manifest you can declare the languages your app supports, which will be used when exporting your application to the store. See Resources for more information. Dependencies
 If your app links to other libraries, they must be declared in the manifest: &lt;iq:barrels&gt; &lt;iq:depends name="Barcode" version="2.0.0"/&gt; &lt;/iq:barrels&gt; The options for each barrel are as follows: Option Type Value 
 name string The declared namespace Module name for the monkey barrel. 
 version a.b.c.d (Optional) The declared version number for the monkey barrel. 
 a , b and c must be numbers. d is an optional alpha-numeric string of A-Z , a-z , 0-9 , and _ . If a version is specified, the build system will enforce that library version being used. These rules can be modified with the following options: Format Meaning Example Valid Version Invalid Version 
 Exact An application links to a specific version of a library version="1.2.3" Version 1.2.3 Any other version 
 Greater or Equal An application links to a library that matches or exceeds the version. version="&gt;=1.2.3" Version 1.2.3 or greater. Versions 1.2.2 or less. 
 Pessimistic The application links to a library with a matching major and minor version, but the micro version must match or be greater than the specified version. version="~&gt;1.2.3" Versions 1.2.3 , 1.2.4 , 1.2.5 , etc. Versions 1.2.2 , 1.3.1 , etc. 
 Whatever The version of the link library will not be enforced at build time. No version attribute specified. Any N/A 
 The version can be prefixed with &gt;= to indicate a minimum supported version. See Shareable Libraries for more information. Communication requires the background permission to be enabled, but Authentication does not &nbsp;↩ 
 Only widgets and apps are allowed to call enableLocationEvents &nbsp;↩


# [Application and System Modules](https://developer.garmin.com/connect-iq/core-topics/application-and-system-modules/)nMenu Core Topics Application and System Modules
 Every application has to have a class that extends Application.AppBase . This object, known as the application object, is the handler for application lifecycle events. The Application object must be specified in the application manifest.xml . This is used by the build tools to denote which class to load at startup. See the Manifest and Permissions section for more information. Install and Uninstall
 Since API level 3.0.0 Your AppBase has two handlers that are called on during installations and updates: API Description API Level 
 AppBase.onAppInstall() Callback method that is triggered in the background when the app is installed 3.0.0 
 AppBase.onAppUpdate() Callback method that is triggered in the background when the app is updated 3.0.0 
 Both of these require that your application has the Background permission. Potential use cases include registering a background service on install or starting an authentication method. These methods are not guaranteed to run. Do not depend on them for essential functionality. Application Lifecycle
 Since API level 4.2.0 There are four main application lifecycle states: launched, active, inactive, and suspended Launch
 After your application is loaded, your application object will be instantiated. From that point forward it will be available throughout the application by calling Application.getApp() . After you application object is instantiated, the AppBase.onStart(state) function will be called. This is your opportunity to initialize the application and restore state. If your application is launched via an System.Intent , the state parameter will contain arguments passed via the intent. Do not attempt to push a View instance at this time. See the Intents section for more information. Once your application is loaded, the system will request the initial view for your application. Depending on what functionality your application implements, you may have to implement several of the following handlers: AppBase.getInitialView() : The primary method for app startup. Return the base view for your watch face, data field, widget, or device app.
 AppBase.getGlanceView() : If your are implementing a widget that has a glance, this will be called when the user goes to browse your glance in the glance list. See the Glances section for more information.
 AppBase.getGoalView() : If your watch face is overriding the goal views, this gives you an opportunity to present your goal view.
 AppBase.getPlaybackConfigurationView() : If you are implementing an audio content provider, this method is called when you need to present playback options to the user.
 
 All of these functions return an array: The first item is the View instance, and the second is the WatchUi.InputDelegate instance that handles the input for the view. Apps will behave differently when they are launched from the glance list versus the activity menu. If an app is launched from the glance list, a timeout will be applied to the app. If the user does not exit the app within a given time frame, the system will terminate the app and return to the home screen. If an app is launched from the activity menu, however, it will not time out, and the user must explicitly exit your application. You can detect which way the user enters your application using the following method: class MySuperApp extends Application.AppBase { // if state contains the :resume key and the value // is true, then restore app state function onStart(state) { if ((state != null) &amp;&amp; (state.get(:launchedFromGlance)) { // Launched from glance } else { // Launched from activity menu } } } Active, Inactive, and Suspended
 Since API level 4.2.0 Some devices have a task switcher that makes it easy to switch between activities and apps on the device. This can switch your app from active to inactive . To take full advantage of the task switcher, you need to utilize the full app lifecycle. State Description 
 Active AppBase.onActive() is called when your app is transitioning from the inactive to active state. Active apps have access defined by the app type. When transitioning from inactive to active, access to sensors, ANT/BLE, will be restored. 
 Inactive AppBase.onInactive() is called when transitioning from the active to inactive state. 
 Based on the state your app is running in, you will have different levels of access to system resources: State Active Inactive 
 Activity With permission, you may be allowed to start and stop activity recording. If the app is recording an activity, recording will continue. If the app is not recording, it is not allowed to start or stop activity recording. 
 GPS GPS access may be denied if another app is recording an activity. If the app is recording an activity and receiving position events, it will continue to receive events in the inactive state. If the app is not recording an activity, it is blocked from modifying the GPS state. 
 ANT ANT access may be denied if another app is recording an activity. If the app is recording an activity, ANT access is permitted. If the app is not recording an activity, all open channels will be closed and will be reopened when transitioning from inactive to active. 
 High Frequency Sensors (Accelerometer, Magnetometer, Gyro) If the app is recording an activity, access is permitted. If the app is not recording an activity, access may fail in a non-fatal way. If the app is recording an activity, access will be permitted. Otherwise, measurements can be retrieved at a maximum of 10 hz. 
 Sensors If the app is recording an activity, access is permitted. If the app is not recording an activity, access may fail in a non-fatal way. If the app is recording an activity, access will be permitted. Otherwise, sensor access will be limited. 
 Attention Access is allowed. Access is denied. 
 There may be scenarios where the user has launched more apps than the system has resources to support. If your app is not active but is still running, the system may terminate your app to free up resources. When this happens, your AppBase.onStop() will be called with a :suspend option to inform you that you are being terminated. You can use this call to persist your state for when you are resumed. When the user returns to your application, you will be called with a :resume option on your AppBase.onStart() . You can then restore your state from storage: class MyApp  extends Application.AppBase { // if state contains the :resume key and the value is true // then restore app state function onStart(state) { if ((state != null) &amp;&amp; (state.get(:resume)) { restoreState(); } } // if state contains the :suspend key and the value is // true, then save app state function onStop(state) { if ((state != null) &amp;&amp; (state.get(:suspend)) { saveState(); } } } If you do nothing, the user will return to your app as if it was just launched. App Termination
 When your application is terminated, the AppBase.onStop() function is called. This gives your application the option to save state before termination. System
 The Toybox.System module provides access to the device state, settings, and metadata [1] . Here you can get runtime information about the device that is running your app, and exercise some execution control. API Description API Level 
 System.error() Write an error to the console and exit the system 1.0.0 
 System.exit() End execution of the current app 1.0.0 
 System.exitTo() Exit the current app and launch a new app 2.2.0 
 System.getClockTime() Get the current clock time 1.0.0 
 System.getDeviceSettings() Get the user settings for the device as well as the device metadata [2] 1.0.0 
 System.getSystemStats() Get runtime statistics for your current runtime 1.0.0 
 System.isAppInstalled() Query the system to see if another app is installed 3.2.0 
 System.print() , System.println() Writes a message to the console or application log 1.0.0 
 I don’t care if they changed their name; “Meta” can’t take “meta” away from us, which admittedly is kind of meta &nbsp;↩ 
 Connect IQ’s hottest API is getDeviceSettings() . This API has everything: user alarms, device settings, connection state, units, Connect IQ API level, monkeys… &nbsp;↩


# [Persisting Data](https://developer.garmin.com/connect-iq/core-topics/persisting-data/)nMenu Core Topics Persisting Data
 Connect IQ is also able to save data from within an app at runtime. For example, an app may need to obtain or calculate data and store it for later use. This is accomplished by the use of Storage, Properties, and Settings. Storage represents data written to disk so it may persist across executions of an application.
 Properties are constant values defined at build time and included in the executable that are useful for product-specific values that shouldn’t be defined in code. Properties may also define the default Settings values.
 Settings are user-editable values modified through Garmin Connect Mobile and Garmin Express. Default settings values are defined by Properties.
 
 Storage
 Storage is used for saving and retrieving data from the file system of the device at run time as defined by the developer. This data is only available to the application and is not accessible by the end user. For example, this feature could be used to store a location from when an app was last used. The next time the app is launched, Storage can provide the last known location to the app. The following data types may be stored: Number 
 Float 
 Long 
 Double 
 Char 
 String 
 Boolean 
 Array 
 Dictionary 
 
 It is important to note that an Array or Dictionary may only contain the data types listed above. For example, it is not possible to store a Symbol in an Array or Dictionary in Storage. Accessing Properties and Settings: Object Store
 Prior to API level 2.4.0, all content was persisted in the object store. If your app runs on Connect IQ System 1 devices, you will need to use AppBase.getProperty() and AppBase.setProperty() to persist data. These functions allow access to both settings and persisted data. The object store is a Dictionary that lives in memory until your app terminates, at which point it is saved to disk. Because the object store costs against your runtime memory, do not use these methods unless you are running on System 1 devices. API Purpose API Level 
 AppBase.getProperty() Retrieve information by key from the object store 1.0.0 
 AppBase.setProperty() Store information by key in the object store 1.0.0 
 Accessing Storage: Application.Storage 
 Since API level 2.4.0 The Application.Storage module manages persistent key-value pair data storage. Information is automatically saved on disk when Storage.setValue() is called. Keys and values are limited to 8 KB each, and a total of 128 KB of storage is available. For example, an application might save a location for later use with the code below: Storage.setValue("location", locationValue.toDegrees()); The next time the application is launched, the stored location value can be retrieved and displayed: var myLastLocation = Application.Storage.getValue("location"); dc.drawText(x, y, Graphics.FONT_SMALL, "Last location: " + myLastLocation, Graphics.TEXT_JUSTIFY_LEFT); API level 3.2.0 introduced the ability to access the Storage module from background processes. The background process can modify storage using Storage.setValue() , Storage.deleteValue() and Storage.clearValue() . When the storage is written from the background process, AppBase.onStorageChanged() callback will be invoked for the foreground process if the background and foreground process are active at the same time and vice-versa. The application would then have to reload data from storage to reflect updated information. API Purpose API Level 
 Storage.getValue() Retrieve information by key from persisted storage 2.4.0 
 Storage.setValue() Store information by key in persisted storage 2.4.0 
 Accessing Properties and Settings: Application.Properties 
 Since API level 2.4.0 The Application.Properties module provides an interface for accessing the values and properties of settings. Information is automatically saved on disk when AppBase.onStop() is called. To get or set a property value use the Properties.getValue() or Properties.setValue() methods, respectively: // Set an Object Store app setting Properties.setValue("mySetting", mySetting); // Get an Object Store app setting value var mySetting = Properties.getValue("mySetting"); API Purpose API Level 
 Properties.getValue() Retrieve information by key from properties. Property values must be defined in a resources xml file in a &lt;properties&gt; element. If a key that is not present in application properties is passed to Properties.getValue() , an exception will be thrown 2.4.0 
 Properties.setValue() Store information by key in persisted storage. Property values must be defined in the resource xml file in a &lt;properties&gt; element. If a key that is not present in application properties is passed to Properties.setValue() , an exception will be thrown 2.4.0 
 Which API Should I Use?
 If your app runs on devices at API level 2.4.0 or above, Storage offers a superior solution for persisting application data compared to the Object Store. Using the newer APIs in an existing app is simply a matter of updating code to call the new methods. However, there are a couple of important things of which to be aware: Object Store data files are not converted to the new format. If an app used storage prior to API level 2.4.0, existing properties will not automatically migrate to the new file format used by the Storage module. If a conversion is needed, an app must include a routine to get the data from the old files and store it in the new format. 
 Properties will throw an exception if attempting to write to an undefined property. Prior to API level 2.4.0, an attempt to write to an undefined property would result in a value written to storage (the .STR file) since getProperty() and setProperty() were overloaded to function with each of Storage, Properties, and Settings. This behavior will no longer occur when using the Properties module since it is distinct from Settings . Instead, an InvalidKeyException is thrown. 
 To maximize the number of supported devices, use a has check to see if the Storage API is available and then call the appropriate methods based on what the device supports: if ( Toybox.Application has :Storage ) { // use Application.Storage and Application.Properties methods } else { // use Application.AppBase methods } For more, see the ApplicationStorage sample app distributed with the SDK.


# [Backgrounding](https://developer.garmin.com/connect-iq/core-topics/backgrounding/)nMenu Core Topics Background Services
 Since API level 2.3.0 Applications can register for background services. Services can be registered to run when various events occur. These events include when the user reaches goal targets, when sleep and wake times occur, when a steps threshold is reached, or at a scheduled time. Modules available to background processes differ from those of their parent application. Services may be terminated at any time free memory for foreground applications. Services will also be terminated automatically if the do not exit properly within 30 seconds of opening. Registering for Events
 When your application runs you can register for events your application can subscribe to by using calls in the Toybox.Background module. Event Description Register With API Level 
 Activity Completed Wakes your background service when the user completes an activity registerForActivityCompletedEvent 3.1.0 
 Goal Wakes your background service when the user meets one of their activity goals registerForGoalEvent 2.3.0 
 OAUTH Response Wakes your background service when the user completes the OAUTH flow registerForOauthResponseEvent 2.3.0 
 Phone App Message Wakes your background service when your app receives a message from the Mobile SDK registerForPhoneAppMessageEvent 3.2.0 
 Sleep Wakes your background service at the time the user has configured as their sleep time registerForSleepEvent 2.3.0 
 Steps Wakes your background service every 1000 steps taken by the user registerForStepsEvent 2.3.0 
 Temporal Allows your service to be woken at a specific time or repeatedly at a certain interval (up to every five minutes) registerForTemporalEvent 2.3.0 
 Making a ServiceDelegate 
 When background services are started, the AppBase.getServiceDelegate() is called. This method returns a System.ServiceDelegate and the method corresponding to the event that triggered is invoked. Once a background service has finished any necessary tasks, it should exit using the Background.exit() method. This method takes a argument containing data to be sent to the main process. Use null to provide no data. Application Scope
 Background services are allowed to run at any time, including while the user is in an activity. In order to achieve this, the memory pool made available to background services is much smaller than what is available for the application. In many instances, the executable code of your application will be larger than the memory pool available. The Connect IQ compiler allows you to select what code is necessary for running in the background with the :background annotation. Only modules, classes, functions and member variables decorated with the :background annotation will be compiled into your background service. This means you must decorate all related code with the annotation (including your Application class). import Toybox.Application; import Toybox.Background; import Toybox.System; import Toybox.Time; // Because this is referenced in the application object // constructor, it must be marked as background. (:background) var globalMember; // Your application object has to be marked as background // so that the service delegate can be referenced (:background) class MyApp extends Application.AppBase { // Constructor. Remember everything referenced in this function // must be marked as background public function initialize() { // Register to run every five minutes if(Background.getTemporalEventRegisteredTime() != null) { Background.registerForTemporalEvent(new Time.Duration(5 * 60)) } // Initialize a global member $.globalMember = true; } public function getServiceDelegate() as [System.ServiceDelegate] { return [new MyServiceDelegate()]; } } // Your service delegate has to be marked as background // so it can handle your service callbacks (:background) class MyServiceDelegate extends System.ServiceDelegate { public function onTemporalEvent() as Void { // Do fun stuff here } } If your type check level is at gradual or above, the compiler will detect if your background service or any objects referenced is attempting to reference something not marked as background. See Monkey Types for more information. The resource compiler can control the scope level of your resources as well. See the Resources section for more information. Simulating Background Services
 In the Connect IQ simulator, an option has been added under the Simulation menu, which allows manually triggering background services. When manually triggering a service, the background service for the most recently run application will be loaded, and the corresponding call in the ServiceDelegate will be triggered regardless of whether the application has registered for that event.


# [Glances](https://developer.garmin.com/connect-iq/core-topics/glances/)nMenu Core Topics Glances
 Since API level 3.1.0 The intention of widgets was to make various kinds of information that are important to the user available at a glance. While the app carousel does allow quick navigation, navigating the loop may require launching numerous applications to get to what you’re looking for. It also dedicates the entire screen for a given context. Glances, introduced with the fēnix® 6 device, turn the presentation of widgets into a dashboard. Instead of a carousel, the user is presented with a list of metrics. Selecting a list item will launch the widget. API level 3.1.0 added the ability for developers to support this feature. Relevant APIs
 API Purpose API Level 
 AppBase.getGlanceView() Called by the system to retrieve your glance 3.1.0 
 WatchUi.GlanceView Implementation of your application glance view on the glance list 3.1.0 
 How to Enable Glance Support in Widget
 The WatchUi.GlanceView allows an app to implement a Glance. Think of the GlanceView as a small canvas to present an executive summary from your widget. The GlanceView is similar to other WatchUi.View objects but should only be used for implementing a Glance. Override the AppBase.getGlanceView() and return your implementation of GlanceView to add Glance support. In devices before API level 4.0.0 if a widget doesn’t override getGlanceView() , default GlanceView will be used, which simply shows the name of the widget. In API level 4.0.0 and above, apps and widgets must implement a glance view to appear in the glance list. Glance Page How Widgets Start on “Glance Page”
 When a widget is shown as part of the “Glance Page”, it will be started in Glance mode with limited memory allocated (32KB for most devices). Similar to background services , developers can use the :glance annotation to indicate which modules and / or classes are necessary when running a Widget in Glance mode. Just like background services using the annotation selectively allows developers to limit memory usage when running in glance mode. When designing widgets and widget glances, it’s best to think of them as somewhat independent items that will function together. There is no guarantee that a widget will always start in glance mode, for example, before transitioning to its standard widget mode. Glance Lifecycle
 Depending on a device’s resource limitations, GlanceView can be updated in two different ways. Live UI Update
 Devices that have ample resources [1] will start the Widget in Glance mode, and keep it alive. The provided GlanceView will be updated as needed by the system, and calls to WatchUi.requestUpdate() will trigger a View update as expected. Note: It’s highly recommended that the update rate should be kept under 1HZ to provide a better scrolling experience. Background UI Update
 Devices that have less memory [2] will start the app only when the system deems it appropriate, and calls to WatchUi.requestUpdate() will have no effect. Such a device could update their glance view when it becomes visible (activated) and at least 30 seconds since last update. During a background update, the Widget and its GlanceView will run through a complete life cycle. The AppBase functions onStart() , getGlanceView() will be called to start the app and retrieve the view. Once the GlanceView has been retrieved, the View functions onLayout() , onShow() , onUpdate() and onHide() will be called. The AppBase.onStop() function will be called upon app termination, and the app will be shut down. All content that is rendered to the Dc passed to View.onUpdate() will be cached on the filesystem and used to display until the next time the system decides to do an update. Best Practices
 Most functionality supported in Widget is still supported when running as a Glance, such as accessing application storage and making web requests. However, developers should focus on making GlanceView quick to load and moving CPU intensive work to a Background service. Music-capable wearables never skip leg day &nbsp;↩ 
 Non-music wearables are on RAM keto &nbsp;↩


# [Properties and App Settings](https://developer.garmin.com/connect-iq/core-topics/properties-and-app-settings/)nMenu Core Topics Properties and Settings
 The app settings framework enables app developers to present options to end users for their apps within Garmin Connect and Garmin Express. This will allow app customization and setup, especially for watch faces and data fields, that have no way to receive user input on Garmin devices. Properties
 An app property is a key and value that is built into the app at compile time. Properties are defined in application resources, and follow the rules of resource overrides. &lt;properties&gt; &lt;property id="appVersion" type="string"&gt;1.0.0&lt;/property&gt; &lt;/properties&gt; The id is a string identifier. The type must be one of the following: Value Notes 
 number , long , float , double Numeric values 
 boolean Boolean value 
 string String value 
 array Array values cannot be initialized in properties, but defaults can be programmed in app settings 
 When your app is installed the properties are initialized to the values programmed into resources. The property values can be fetched and modified via the following APIs: API Notes API Level 
 AppBase.getProperty() Get a property by its name 1.0.0 
 AppBase.setProperty() Modify a property value 1.0.0 
 Properties.getValue() Get a property by its name 2.4.0 
 Properties.setValue() Modify a property value 2.4.0 
 Settings
 App settings allow the user to modify app properties using their mobile device. The app settings can be modified in the Connect IQ Store app, the Garmin Connect app, or Garmin Express. An app setting is composed of a property and an associated setting. The property is used to store the underlying setting value. The setting is used to describe how the property should displayed to the end user. You can define a property as a default value and not define an associated setting but you cannot define a setting without tying it to a property. Settings are also defined as a resource. Use the &lt;setting&gt; tag to define a setting. &lt;settings&gt; &lt;setting propertyKey="@Properties.appVersion" title="@Strings.AppVersionTitle"&gt; &lt;settingConfig type="alphaNumeric" readonly="true" /&gt; &lt;/setting&gt; &lt;setting propertyKey="@Properties.myString" title="@Strings.MyStringTitle" prompt="@Strings.MyStringPrompt"&gt; &lt;settingConfig type="list"&gt; &lt;listEntry value="0"&gt;@Strings.HelloWorld&lt;/listEntry&gt; &lt;listEntry value="1"&gt;@Strings.Ackbar&lt;/listEntry&gt; &lt;listEntry value="2"&gt;@Strings.Garmin&lt;/listEntry&gt; &lt;/settingConfig&gt; &lt;/setting&gt; &lt;setting propertyKey="@Properties.myNumber" title="@Strings.MyNumberTitle" prompt="@Strings.MyNumberPrompt"&gt; &lt;settingConfig type="numeric" errorMessage="@Strings.MyNumberError" /&gt; &lt;/setting&gt; &lt;setting propertyKey="@Properties.screenSleep" title="@Strings.ScreenSleepTitle"&gt; &lt;settingConfig type="boolean" /&gt; &lt;/setting&gt; &lt;setting propertyKey="@Properties.username" title="@Strings.UsernameTitle"&gt; &lt;settingConfig type="alphaNumeric" required="true" /&gt; &lt;/setting&gt; &lt;/settings&gt; The table below shows all of the valid attributes for a setting. Attribute Value Notes 
 propertyKey The key of the property that this setting will manage. An error will be thrown at compile time if the property key can’t be found. Required 
 title The title to display in Garmin Connect Mobile/Garmin Express when displaying the list of settings/value of the setting. This must reference a string resource ID. Required 
 prompt The message to display when prompting the user to set the value. This must reference a string resource ID. Optional. Some settings will not display a prompt even if it’s provided (for example, readonly or boolean settings displayed as an on/off switch). 
 helpUrl A URL to a web page which will provide help for the user. This has been deprecated. Optional 
 maxLength The maximum number of elements allowed in an array setting Optional 
 A &lt;settingConfig&gt; , a child element of a &lt;setting&gt; , provides additional details about the setting. The valid attributes are given in the table below. Attribute Value Valid Values Notes 
 type The display type of the setting. list , boolean , numeric , alphaNumeric , phone , email , url , date or password A value of list will require child &lt;listEntry&gt; elements to define the options which should be available within the list. 
 readonly If the setting is read only or not. This attribute is valid for all types except list and password . true or false Optional. Defaults to false . 
 required If the field is required. true or false Optional. Defaults to false . 
 min The minimum value to allow. An integer value Optional. Only valid for a type value of numeric or date . 
 max The maximum value to allow. An integer value Optional. Only valid for a type value of numeric or date . 
 maxLength The maximum allowed value length. An integer value Optional. Only valid for settings whose associated property’s type is string . 
 errorMessage An error message to display if the value a user enters isn’t valid based on the type , min , max and maxLength values. A reference to a string resource. 
 id In array settings, an identifier that is used to mark a field inside the object setting. A string identifier This is only used with array settings 
 &lt;settingConfig&gt; types are only valid for certain property types: Property Type Valid settingsConfig Types 
 string alphaNumeric , phone , email , url , password 
 number list , numeric , date 
 float numeric 
 long numeric 
 double numeric 
 boolean boolean 
 The &lt;listEntry&gt; element is defined in the table below. Its value must be a reference to a string resource. Attribute Value Notes 
 value The value to save if this item is selected by the user. The type of the value should match the property it’s being saved to. If it doesn’t match a compile time error is thrown. 
 See the Object Store and Application Properties on how to read these value at runtime. Groups
 The &lt;group&gt; tag allows settings to be grouped together. This lets you visually separate related settings from non-related ones. A group contains the settings it groups together. A group is not allowed to contain a group. Here is a simple example of a group definition: &lt;settings&gt; &lt;group id="groupName" title="@Strings.group1Title" description="@Strings.group1Description"&gt; &lt;setting propertyKey="@Properties.number_prop" title="@Strings.number_title"&gt; &lt;settingConfig type="numeric" /&gt; &lt;/setting&gt; &lt;setting propertyKey="@Properties.long_prop" title="@Strings.long_title"&gt; &lt;settingConfig type="numeric" /&gt; &lt;/setting&gt; &lt;/group&gt; &lt;/settings&gt; Here are the options for groups: Attribute Values Notes 
 id String Identifier for the group 
 title String Title for the group. This is shown as a list item in mobile. 
 description String Description text for the group. This should describe the context of the group of settings 
 enableIfTrue Property identifier Allows a group to be disabled if a boolean setting is not checked. This allows for settings to appear if the user enables a feature. 
 Array Settings
 There are times when it can be helpful to allow the user to manipulate one or more related items. For example, let’s say that your app can support more than one kind of activity type, and each activity type has a different set of heart rate zones. The user may only have two or three activity types, but your app supports 50 different ones. Array settings allow you to define a set of settings that are added and removed as a group. This allows the user to create a variable list (up to a maximum size) of objects that can be read at runtime. To create a variable list, the property referenced must be of type array . The setting definition is then a set of settings [1] : &lt;setting propertyKey="@Properties.ActivityHrZones" title="Activities" maxLength="4"&gt; &lt;setting title="@Strings.activityType" type="number"&gt; &lt;settingConfig id="activityType" type="list"&gt; &lt;listEntry value="0"&gt;@Strings.Running&lt;/listEntry&gt; &lt;listEntry value="1"&gt;@Strings.Cycling&lt;/listEntry&gt; &lt;listEntry value="2"&gt;@Strings.Swimming&lt;/listEntry&gt; &lt;/settingConfig&gt; &lt;/setting&gt; &lt;setting title="@Strings.Zone1"&gt; &lt;settingConfig id="zone1" type="number"/&gt; &lt;/setting&gt; &lt;setting title="@Strings.Zone2"&gt; &lt;settingConfig id="zone2" type="number"/&gt; &lt;/setting&gt; &lt;setting title="@Strings.Zone3"&gt; &lt;settingConfig id="zone3" type="number"/&gt; &lt;/setting&gt; &lt;setting title="@Strings.Zone4"&gt; &lt;settingConfig id="zone4" type="number"/&gt; &lt;/setting&gt; &lt;setting title="@Strings.Zone5"&gt; &lt;settingConfig id="zone5" type="number"/&gt; &lt;/setting&gt; &lt;!-- The defaults is where you program the initial values --&gt; &lt;defaults&gt; &lt;entry&gt; &lt;default id=”activityType”&gt;0&lt;/default&gt; &lt;default id="zone1"&gt;89&lt;/default&gt; &lt;default id="zone2"&gt;109&lt;/default&gt; &lt;default id="zone3"&gt;125&lt;/default&gt; &lt;default id="zone3"&gt;144&lt;/default&gt; &lt;default id="zone5"&gt;160&lt;/default&gt; &lt;/entry&gt; &lt;/defaults&gt; &lt;/setting&gt; When you query the property, it will be an array of Dictionary objects, with each id key associated with the value. You can use maxLength to set an upper bound to the number of elements. Each settingConfig must have an id field. The &lt;defaults&gt; tag allows you to program the initial value when your app is first installed. Each &lt;default&gt; tag must reference the identifier with the id attribute. Changing Settings Within Garmin Connect Mobile/Garmin Express
 End users will be able to view the settings you define within the Garmin Connect or Garmin Express UI. When app settings are changed while an app is running the AppBase.onSettingsChanged() function is called. Apps can override this function and update accordingly. When dealing with date type settings that are set by Garmin Express or Garmin Connect, one should note that times are stored in UTC and that Gregorian.utcInfo() should be used in place of Gregorian.info() when working with such values to prevent unnecessary local time conversion. Testing App Settings
 An app settings editor tool is available within the Connect IQ simulator. Go to File &gt; Edit Persistent Storage &gt; Edit Application.Properties data . This tool will allow you to view the defined settings for a project, select values for each setting and send them to the simulator for testing. The app settings editor requires you to be authenticated in the SDK Manager as well as a internet connection. On Device Watch Face and Data Field Settings
 Since API level 3.2.0 Device applications, widgets, and audio content providers all accept user input that allow them to implement on-device settings in the app. Watch faces and data fields are not allowed to accept input or push views that would allow on device configuration. If you want to provide an on-device settings user interface for your watch face or data field, you can implement AppBase.getSettingsView() . getSettingsView() functions similarly to AppBase.getInitialView() where you return a WatchUi.View and WatchUi.InputDelegate pair that can serve as the initial view. Watch face configuration is available to the user in the system Watch Face menu. Data field configuration is available from the activity menu. Time operates half as fast in the setting within the setting. You might want to spin your top now. &nbsp;↩


# [Intents](https://developer.garmin.com/connect-iq/core-topics/intents/)nMenu Core Topics Intents
 Since API level 2.2.0 Intents allow a Connect IQ watch-app or widget to launch another Connect IQ watch-app, Connect IQ widget, or native application (e.g. built in activities like Run, Bike, etc.) by calling System.exitTo() : Calling exitTo() will cause a confirmation view to be displayed asking the user whether to exit to the intended app. If the user chooses ‘No’ then the app that called exitTo() will continue to run. If the user chooses ‘Yes’ then the app will exit and the new app will launch. While the confirmation view is shown, the originating app will continue to run. Exiting to Connect IQ Apps
 In order to exit to another Connect IQ app, a System.Intent must be created, which contains a target app identifier and any arguments you wish to pass to the target app. The target app identifier must be specified using one of two supported URI schemes: manifest-id:// followed by a valid UUID from the app’s manifest.xml
 store-id:// followed by a valid app store UUID
 
 Arguments are passsed to the target app as a dictionary, which may be empty or null , and are received by the target app’s AppBase.onStart() method as a Dictionary object. import Toybox.System; ... var intent = new System.Intent("manifest-id://01234567-89AB-CDEF-0123-456789ABCDEF", {"lat"=&gt;38.856419, "lon"=&gt;-94.801369}); System.exitTo(intent); Assuming the target app is installed on the device, this example launches the app with manifest ID 01234567-89AB-CDEF-0123-456789ABCDEF and passes it the "lat" and "lon" arguments. Exiting to Native Apps
 Intent objects to launch native apps deal exclusively with PersistedContent objects, such as PersistedContent.Waypoint , PersistedContent.Routes , and PersistedContent.Tracks . Connect IQ handles most of the Intent functionality for native apps behind the scenes, automatically embedding the appropriate native app identifier in the PersistedContent object, which is accessible via the toIntent() method. See the Persisted Content section for more information. Intent Exceptions
 Connect IQ includes three exception types related to intents: System.UnexpectedAppTypeException is thrown if your app tries to exit to a Connect IQ app type other than device app or widget
 System.AppNotInstalledException is thrown if your app tries to exit to an app that is not installed
 System.PreviousOperationNotCompleteException is thrown if exitTo() is called a while a confirmation view from a previous exitTo() call has not been acknowledged by the user


# [Build Configuration](https://developer.garmin.com/connect-iq/core-topics/build-configuration/)nMenu Core Topics Build Configuration
 Connect IQ supports a wide variety of Garmin devices, like watches, bike computers and handhelds. Even within these broader categories, devices can have different screen sizes, shapes and resolutions. Application developers may wish to define specific resources, like fonts and bitmap graphics, for certain devices or device families for a better user experience. For example, an app may need to use a round background image for round devices and a square background image for square devices. Connect IQ offers a few ways to manage app resources: device and family qualifiers , Jungles and [build exclusions][Build File Exclusions]. Device, Family, and Localization Qualifiers
 The simplest way to override resources is with device, family, and localization qualifiers, which are added to a resources folder by adding a hyphen ( - ) followed by a valid qualifier value. Let’s take a look at an example: Figure 1: A project that uses a fēnix 5 device resource qualifier Resource qualifiers are applied to the base resources folder, and all resources found within that folder will inherit the qualifiers of the base folder. Resources with more specific qualifiers will always take precedence over less specific ones if they share a resource ID. In Figure 1, the resources-fenix5 directory uses a -fenix5 qualifier to segregate resources specifically intended for the fēnix 5. When this project is built for fēnix 5, the layout and drawable in the resources-fenix5 directory will be used to display a different background image than the one in the more generic resources directory. All other supported products will compile with the default resources. Note: Multiple qualifiers separated by hyphens may be used on a single folder, but device qualifiers are not allowed to co-exist with family qualifiers in the same folder name (e.g. resources-round-fenix3 ) and will be skipped by the resource compiler if encountered. Device Qualifiers
 The device qualifier format allows for resources to target specific devices (as demonstrated in Figure 1). Resources included in a folder with a device qualifier will override the resources with the same ID that are defined in the base resource folder when building for the associated device. Device qualifiers also take precedence over less specific qualifiers, such as family qualifiers. Family Qualifiers
 The family qualifier format allows for resources to target specific device families, which is a group of devices differentiated by shared screen characteristics. There are two family qualifiers: Screen shape: The shape of the screen (e.g. round , rectangle , etc.)
 Screen size: The physical size of the screen in pixels ( e.g. 218x218 , 148x205 , etc.)
 
 The screen shape must always be specified when using a family qualifier, and the screen size may be added to further refine the target family. Here are some examples of valid and invalid family qualifier examples: resources-round : Valid —targets round screen devices, like the fēnix 3 series and fēnix 5 series
 resources-round-218x218 : Valid —targets 218px x 218px, round screen screen devices, like the fēnix 3 and fēnix 5S (but not the 5 or 5X since they have 240px x 240px screens)
 resources-218x218 : Invalid —this will be ignored by the resource compiler because no screen shape has been specified
 resources-218x218-round : Invalid —the screen shape was not specified first
 
 Resources with more specific qualifiers will always take precedence over less specific ones, so on a round, 218px x 218px device, any resources contained in the resources-round-218x218 resources folder will be used in place of those in resources-round if they share an ID. In addition any resource folder that carries a family qualifier will always defer to resource folders named with device qualifiers. Localization Qualifiers
 Localization qualifiers are a way to specify language-specific string resources, and are specified as an ISO 639–2 language code . These qualifiers may be combined with either device or family qualifiers, and are always specified last in the qualifier naming scheme. For example: resources-fre : Provides French language-specific string resources for all devices
 resources-round-fre : Provides French language-specific string resources for round devices only
 resources-fenix5s-fre : Provides French language-specific string resources for fēnix 5 devices only
 
 Build Configuration via Jungles
 Connect IQ runs on a diverse set of purpose built devices. Because of the variety of inputs, screen shapes and resources, it often is necessary to include code and resources tailored to specific conditions. For example, on a square device a progress bar may be rectangular, but on a round device it might look better as an arc that orbits the screen. Jungles allow developers to write custom build configurations for Monkey C projects. With Jungles, developers may: Define per-device or per-device family paths to source and resource directories
 Exclude portions of source code with annotations
 Specify Monkey Barrels that should be included when a project is built.
 
 Per Device Configuration
 Jungles allow for the source path, resource path and exclusions to be set for all products, by screen shape, or for particular products. The following prefixes are allowed: Name Description 
 base Configuration applies to all products 
 round Configuration applies to products with round screens 
 semiround Configuration applies to products with semi-round screens 
 rectangle Configuration applies to products with rectangle or square screens 
 semioctagon Configuration applies to products with octagon screens with sub-window 
 &lt;product id&gt; Configuration applies to a specific product. &lt;product id&gt; is the same as what is used in the manifest file 
 For round , semiround , semi-octagon , and rectangle identifiers, an optional -&lt;width&gt;x&lt;height&gt; suffix can be added for narrow the scope. Let’s say you are writing a wearable app that has different resources for round, semi-round and rectangle layouts. The Venu has a AMOLED specific implementation as well. Jungles make it easy to manage project build configurations in one place: base.sourcePath = source # Configure paths based on screen shape round.resourcePath = $(base.resourcePath);resource-round semiround.resourcePath = $(base.resourcePath);resource-semiround rectangle.resourcePath = $(base.resourcePath);resource-rectangle # Set the venu source and resource paths venu.sourcePath = $(base.sourcePath);source-venu venu.resourcePath = $(base.resourcePath);resource-venu These instructions set the source path for all devices to source . It tells the build system to use the resource-round , resource-semiround and resource-rectangle paths for the round, semi-round and rectangle the devices respectively. Finally, the Venu has an additional source and resource folders added. Feeling Excluded
 Now, let’s say that we have some code in our application that should only be run on round products, and all the non-round products should use the “regular” version: (:roundVersion) function drawThis(dc) { // Implementation } (:regularVersion) function drawThis(dc) { } We don’t want to include both versions in any executable because one version would just be dead code. Jungles allow us to specify this using exclusions. # Say that all products exclude declarations # with the annotation :roundVersion base.excludeAnnotations = roundVersion # Now say that the round products exclude # the regular version round.excludeAnnotations = regularVersion When building the app for a product, round products will exclude the version of drawThis with the :regularVersion annotation, and the rest of the products will exclude the version of drawThis with the :roundVersion annotation. For more information on how to use Jungles see the Jungle Reference Guide .


# [Security](https://developer.garmin.com/connect-iq/core-topics/security/)nMenu Core Topics Security
 At Garmin we are focused on the security of our devices and services. The security model in Connect IQ is designed to give the developer and the user the tools to know that their device and their information is safe with Garmin. Connect IQ has three levels of trust for apps: Trusted - Content that has been approved by the app store. These apps have passed the Garmin review process and can be downloaded from the Connect IQ store.
 Developer - Content that has been written by an individual developer, but has not been released in the Connect IQ store. This content can be used for testing, but is not an officially released app.
 Untrusted - Content that should not be run on device.
 
 These levels of trust are enforced using digital signatures. Key management has been worked into the app store, the device, and the developer SDK. The goal is to make sure that apps loaded from developers only come from two locations - the app store or a trusted developer. Developer Keys
 The Connect IQ compiler requires a developer key be provided to for signing when compiling and packaging apps. The required key must be a RSA 4096 bit private key. Note : It’s important you keep track of the key you use to sign app packages. You will need to use the same key to sign updates to an existing app on the store. If you lose your original signing key you will not be able to update your app. Generating a Key Using Visual Studio Code
 If you have a developer key you can set the path to it by selecting File &gt; Preferences &gt; Settings &gt; Monkey C and setting the Monkey C: Developer Key Path to your developer key. If you do not have a developer key, you can create one using the Monkey C: Generate Developer Key command in the command palette, or the Monkey C extension will create one when you verify the installation using the Monkey C: Verify Installation command. Generating a Key Using OpenSSL
 If you’re working from the command line you can generate a RSA key using OpenSSL . The following command will generate a valid signing key. &gt; openssl genrsa -out developer_key.pem 4096 &gt; openssl pkcs8 -topk8 -inform PEM -outform DER -in developer_key.pem -out developer_key.der -nocrypt This developer key, developer_key.der , is passed to the compiler using the -y command line option. Running on Device
 Apps must be signed to run on a Garmin device, and unsigned apps will be deleted by the device. The Monkey C tool will automatically sign your app based on your key. Your apps will run at the Developer privilege level. Apps signed by the app store run at the Trusted privilege level. The content of their object store will be encrypted and unreadable from the Connect IQ developer tools. The app store requires IQ files to be digitally signed. Your upload will be rejected If the developer key has changed since your last upload.


# [User Interface](https://developer.garmin.com/connect-iq/core-topics/user-interface/)nMenu Core Topics Views, Drawables and Layers
 The Connect IQ SDK makes it easier to port the user interface to different products. At the resource compiler level, we include a way to define a page in XML as well as specify page definitions per product. These tools make it easy to support multiple devices with a single app. Views
 Watch faces and apps have a page stack. A WatchUi.View is an object that represents a page. Views can be pushed onto and popped off of the page stack, or a view can replace another view on the page stack with a transition. A subclass of View usually implements the following functions: View.onShow() : Called when your WatchUi.View is first made visible. A good time to do on demand initialization of resources and timers.
 View.onLayout(dc) : In this function you can load a layout defined in the Layouts section.
 View.onUpdate() : Called when your view needs to update the display. The default version of this function will draw the layout elements, but you call onUpdate() to have the system draw the layout and then run your own custom drawing.
 View.onHide() : Called when your View is being removed from the view stack.
 
 Enhanced Readability Mode
 Since API level 4.2.0 Some devices have a new setting that enlarges the sizes of fonts in menus, glances and application pages to enhance readability. To add support for enhanced readability mode, check DeviceSettings.isEnhancedReadabilityMode at runtime to see if you should be using larger fonts. Implementing AppBase.onEnhancedReadabilityModeChanged() will let you know if the setting changed while the app was running. Drawables
 Each View contains a layout. A layout is an array of WatchUi.Drawable objects. A Drawable can draw itself to a device context through the Drawable.draw(dc) method. An illustration of Layouts, Views, and Drawables Any object that extends Drawable is a drawable object, expose their properties publicly. (This will become useful when we discuss the animation system.) Monkey C provides the basic drawables WatchUi.Text and WatchUi.Bitmap , allowing text and bitmap resources to be included in layouts. Layers
 Since API level 3.1.0 Layers are used to fuse multiple levels of drawable content belong to the same view. Once added to a view, layers are rendered on the screen automatically in the order they are added. Layers are conceptually closer to the Graphics.BufferedBitmap than a Drawable , and come with a similar runtime memory cost. The following is a code snippet about how to use the WatchUi.Layer system class MyLayerView extends WatchUi.View { function initialize() { // create a 240x240 layer, at [0,0] offset from the top-left corner of the screen var backgroundLayer = new WatchUi.Layer({:x=&gt;0, :y=&gt;0, :width=&gt;240, :height=&gt;240}); // draw something on the layer backgroundLayer.getDc().drawBitmap( ... ); backgroundLayer.getDc().drawPolyline( ... ); // add layer to View as background addLayer(backgroundLayer); // create another 20x20 layer and add it to the view as foreground layer var foregroundLayer = new WatchUi.Layer({:x=&gt;10, :y=&gt;10, :width=&gt;20, :height=&gt;20}); addLayer(foregroundLayer); // draw something on the foreground layer foregroundLayer.getDc().drawText( ... ); } } AnimationLayer
 Layers are useful for fusing animations with your View content. The WatchUi.AnimationLayer is a special layer that allows integration of WatchUi.AnimationResource and your View . Using layers, you can overlay animations over your View , or overlay static content over playing animations. Animation WatchFace With 3 Layers The above screenshot illustrates a 3-layer watch face from the samples/AnimationWatchFace sample app. See the Resources section to learn how to embed resources into your app. See the samples/AnimationWatchFace sample to learn more.


# [Layouts](https://developer.garmin.com/connect-iq/core-topics/layouts/)nMenu Core Topics Layouts
 The resource compiler allows page layouts to be customized to a particular device without changing any Monkey C code. In addition, drawable List objects can also be defined, which are WatchUi.Drawable objects that can draw a number of graphics primitives. When defining a layout in XML, simply list the drawable objects to include in your layout inside a set of layout tags. Each drawable listed will be turned into Monkey C WatchUi.Drawable objects and drawn one after the other. Because of this, if two drawables in your layout overlap each other the drawable that is defined second will draw on top of the drawable that is defined first. Here is an example of a basic layout: &lt;resources&gt; &lt;layout id="MainLayout"&gt; &lt;drawable id="MainBackground" /&gt; &lt;label text="Page Heading" x="10" y="25" font="Gfx.FONT_LARGE" color="Gfx.COLOR_BLACK" /&gt; &lt;label text="Your information goes here." x="50%" y="50%" font="Gfx.FONT_MEDIUM" color="Gfx.COLOR_DK_GRAY" /&gt; &lt;/layout&gt; &lt;/resources&gt; To use this layout in your code simply call View.setLayout() inside the View.onLayout() function. Call the parent View.onUpdate() if you plan on using the onUpdate() function to update dynamic values on the screen. For example: class MainView extends WatchUi.View { public function onLayout( dc as Dc ) as Void { setLayout( Rez.Layouts.MainLayout( dc ) ); } public function onUpdate( dc as Dc) as Void { // Call parent's onUpdate(dc) to redraw the layout View.onUpdate( dc ); // Include anything that needs to be updated here } } Layout
 The following attributes are supported by the layout tag: Attribute Definition Valid Values Default Value Notes 
 id The handle for the layout. This is used to reference the layout in the Rez module Any value that starts with a letter NA Required 
 Label
 Text can be included in layouts. To include text use the label tag, which supports the following attributes: Attribute Definition Valid Values Default Value Notes 
 id The handle for the label. The ID provided here references the label defined in the resource XML file Any value that starts with a letter NA 
 text The text to be displayed NA An empty string 
 font The font to be used when drawing the text See font references Graphics.FONT_MEDIUM 
 x The X coordinate of the point that the text will be justified against pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y The Y coordinate of the point that the text will be justified against pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 justification How the text should be justified in relation to the X &amp; Y location Graphics text justify constant Graphics.TEXT_JUSTIFY_LEFT 
 color The color of the text Graphics color constant or a 24-bit integer of the form 0xRRGGBB Graphics.COLOR_WHITE 
 background The background color of the text Graphics color constant or a 24-bit integer of the form 0xRRGGBB Gfx.COLOR_TRANSPARENT 
 visible The drawable is visible true or false true Only supported for devices with ConnectIQ 3.3.0 and later 
 Text Area
 Since API level 3.1.0 Text may also be included in a layout as a text area. A text area is similar to a text label, except it will attempt to fit text into the provided area by selecting an appropriate font, adding line breaks, or applying truncation. To include a text area, use a text-area element. The following attributes are permitted: Attribute Definition Valid Values Default Value Notes 
 id The handle for the text area. The ID provided here references the text area defined in the resource XML file Any value that starts with a letter NA 
 text The text to be displayed NA An empty string 
 font The font to be used when drawing the text See font references Graphics.FONT_MEDIUM Cannot be used if a font sequence is provided 
 x The X coordinate of the point that the text will be justified against pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y The Y coordinate of the point that the text will be justified against pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 width The width of the area to fit the text into pixel value, a relative dimension using ‘%’, or fill 0 
 height The height of the area to fit the text into pixel value, a relative dimension using ‘%’, or fill 0 
 justification How the text should be justified in relation to the X &amp; Y location Graphics text justify constant Graphics.TEXT_JUSTIFY_LEFT 
 color The color of the text Graphics color constant or a 24-bit integer of the form 0xRRGGBB Graphics.COLOR_WHITE 
 background The background color of the text Graphics color constant or a 24-bit integer of the form 0xRRGGBB Gfx.COLOR_TRANSPARENT 
 visible The drawable is visible true or false true Only supported for devices with ConnectIQ 3.3.0 and later 
 A text area can select a font from a sequence to minimize truncation. The text area will try the fonts in the specified order until the text can be drawn in the given area without truncation. If no font is found that avoids truncation, the last font in the sequence will be used and the text will be truncated. Valid values for each font element are the same as that of the font attribute. An example text-area with a font sequence: &lt;text-area id="BlockOfText" text="Lorem ipsum dolor sit amet, consectetur adipiscing elit." x="10%" y="10%" width="80%" height="80%"&gt; &lt;fonts&gt; &lt;font&gt;Gfx.FONT_MEDIUM&lt;/font&gt; &lt;font&gt;@Rez.Fonts.MySmallFont&lt;/font&gt; &lt;font&gt;Gfx.FONT_XTINY&lt;/font&gt; &lt;/fonts&gt; &lt;/text-area&gt; Font References
 In layout definitions, there are three ways to refer to fonts: Reference Description Example 
 System font reference Reference the standard FONT enumeration in the Graphics module. Graphics.FONT_SMALL 
 Custom font reference Reference a font in application resources . @Rez.Fonts.MySmallFont 
 Scalable font reference Reference a system scalable font. This is the font name or names optionally separated by a comma and the pixel size separated by a colon. See Scalable Fonts for more information. "#BionicBold,Roboto:12" 
 Drawables
 Drawables (both bitmaps and drawable XML resources) can also be included in a layout using the drawable tag. The following attributes are supported by the drawable tag: Attribute Definition Valid Values Default Value Notes 
 id The handle for the drawable. The ID provided here references the drawable defined in the resource XML file Any value that starts with a letter NA Required; the drawable must also be defined in a resource XML file 
 x The X coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y The Y coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 Drawable List
 Drawable XML resources consist of a list of basic drawables: bitmaps and shapes. To create an XML drawable, define a &lt;drawable-list&gt; in an XML resource file. Both &lt;bitmap&gt; and &lt;shape&gt; tags should be be placed as child nodes inside the &lt;drawable-list&gt; . An example drawable-list: &lt;resources&gt; &lt;drawable-list id="Smiley" background="Gfx.COLOR_YELLOW"&gt; &lt;shape type="circle" x="10" y="10" radius="5" color="Gfx.COLOR_BLACK" /&gt; &lt;shape type="circle" x="30" y="10" radius="5" color="Gfx.COLOR_BLACK" /&gt; &lt;bitmap id="mouth" x="15" y="25" filename="../bitmaps/mouth.png" /&gt; &lt;/drawable-list&gt; &lt;/resources&gt; To use this drawable in code do the following: function onUpdate( dc as Dc ) as Void { var mySmiley = new Rez.Drawables.Smiley(); mySmiley.draw( dc ); } The &lt;drawable-list&gt; tag supports the following attributes: Attribute Definition Valid Values Default Value Notes 
 id The ID of the drawable Any string that starts with a character NA Required 
 x The X coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y The Y coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 width The width of the drawable list. pixel value, a relative dimension using ‘%’, or fill fill 
 height The height of the drawable list. pixel value, a relative dimension using ‘%’, or fill fill 
 foreground The color of elements (shapes and text) drawn in the drawable Graphics color constant or a 24-bit integer of the form 0xRRGGBB The current draw context’s foreground color 
 background The background color of the drawable Graphics color constant or a 24-bit integer of the form 0xRRGGBB Gfx.COLOR_TRANSPARENT 
 For more, see the Drawable sample app distributed with the SDK. Shape
 The &lt;shape&gt; tag supports the following attributes: Attribute Definition Valid Values Default Value Notes 
 type The type of the shape to be drawn rectangle , ellipse , circle , or polygon NA Required 
 x For circles and ellipses: X coordinate of the center of the shape in relation to the parent; for everything else: the X coordinate of the top left corner in relation to the parent element. pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y For circles and ellipses: Y coordinate of the center of the shape in relation to the parent; for everything else: the Y coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 points A list of points which defines the polygon [[x1, y1], [x2, y2], ... , [xN, yN]] , points can be relative positions using ‘%’ NA Required for polygon ; must have at least 3 points 
 width The width of the shape to be drawn pixel value, a relative dimension using ‘%’, or fill fill Required for rectangle 
 height The height of the shape to be drawn pixel value, a relative dimension using ‘%’, or fill fill Required for rectangle 
 a The a value of the ellipse to be drawn pixel value, a relative dimension using ‘%’, or fill fill Required for ellipse 
 b The b value of the ellipse to be drawn pixel value, a relative dimension using ‘%’, or fill fill Required for ellipse 
 color The color of the shape to be drawn Graphics color constant or a 24-bit integer of the form 0xRRGGBB The current draw context’s foreground color 
 corner_radius The radius of the rounded corners of the rectangle pixel value 0 Only valid for rectangle 
 radius The radius of the circle pixel value or a relative dimension using ‘%’ 0 Required for circle 
 border_width The width of the border around the shape pixel value 0 Only valid for rectangle , ellipse , and circle 
 border_color The color of the border around the shape Graphics color constant or a 24-bit integer of the form 0xRRGGBB The current draw context’s foreground color Only valid for rectangle , ellipse , and circle 
 For more see the Drawable sample app distributed with the SDK. Bitmap
 The &lt;bitmap&gt; tag supports the following attributes: Attribute Definition Valid Values Default Value Notes 
 id The ID of the drawable Any string that starts with a character NA Required 
 x The X coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , left , right , or start 0 
 y The Y coordinate of the top left corner in relation to the parent element pixel value, a relative position using ‘%’, center , top , bottom , or start 0 
 filename The relative path to the image that should be shown A valid, relative path NA Required 
 visible The drawable is visible true or false true Only supported for devices with ConnectIQ 3.3.0 and later 
 Custom Drawables
 In some cases it is useful to have a drawable entry within a layout point to a custom defined class which extends Drawable , or any of its directly known subclasses. This is possible by using the class attribute of the &lt;drawable&gt; tag. &lt;layout&gt; &lt;drawable id="MoveBar" class="CustomMoveBar" /&gt; &lt;/layout&gt; The drawable entry above will add a new instance of the CustomMoveBar class to the layout. You can then define how the CustomMoveBar is drawn by overriding the draw(dc) function. import Toybox.WatchUi; class CustomMoveBar extends WatchUi.Drawable { function draw(dc as Dc) as Void { // Draw the move bar here } } Passing Parameters to Custom Drawables
 If may be useful to pass values into a custom Drawable. To do this you define &lt;param&gt; children within the &lt;drawable&gt; tag. The &lt;param&gt; tag should define the name of the parameter using the name attribute and the value as it’s content. The content value is passed as is to the custom Drawable. This means if you want to pass a string you must wrap the content in quotes. &lt;layout&gt; &lt;drawable id="MoveBar" class="CustomMoveBar"&gt; &lt;param name="color"&gt;Gfx.COLOR_RED&lt;/param&gt; &lt;param name="string"&gt;"Hello Custom Drawable!"&lt;/param&gt; &lt;/drawable&gt; &lt;/layout&gt; The parameters defined in XML are passed to the custom Drawable’s initialize function as a dictionary. The names are passed as symbols and the values are passed as they appear in the XML. import Toybox.WatchUi; class CustomMoveBar extends WatchUi.Drawable { private var _color, _string; public function initialize(params as Dictionary) { // You should always call the parent's initializer and // in this case you should pass the params along as size // and location values may be defined. Drawable.initialize(params); // Get any extra values you wish to use out of the params Dictionary _color = params.get(:color); _string = params.get(:string); } }


# [Graphics](https://developer.garmin.com/connect-iq/core-topics/graphics/)nMenu Core Topics Graphics
 The graphics module handles drawing bitmaps, fonts, and shapes to the device screen. Drawing Context
 The Graphics.Dc object is used to draw to a graphics surface. The primary device surface is provided to the View object methods View.onLayout() , View.onUpdate() , and View.onPartialUpdate() . The size of the surface can be queried with the Dc.getWidth() and Dc.getHeight() methods. Primitive or Operation Draw Fill API Level Notes 
 Set the pen or fill color Dc.setColor() , Dc.setStroke() Dc.setColor() , Dc.setFill() 1.0.0, 4.0.0 setStroke() and setFill() are API 4.0.0. 
 Set the pen width Dc.setPenWidth() N/A 1.0.0 
 Clear the drawable area N/A Dc.clear() 1.0.0 
 Draw a bitmap Dc.drawBitmap() NA 1.0.0 
 Draw a bitmap Dc.drawBitmap2() NA 4.2.0 
 Draw a text string Dc.drawText() NA 1.0.0 Only works with setColor() [1] 
 Draw a pixel Dc.drawPoint() NA 1.0.0 
 Draw a line Dc.drawLine() NA 1.0.0 
 Draw a circle Dc.drawCircle() Dc.fillCircle() 1.0.0 
 Draw an ellipse Dc.drawEllipse() Dc.fillEllipse() 1.0.0 
 Draw a rectangle Dc.drawRectangle() Dc.fillRectangle() 1.0.0 
 Draw a rounded rectangle Dc.drawRoundedRectangle() Dc.fillRoundedRectangle() 1.0.0 
 Draw an arc Dc.drawArc() N/A 1.0.0 
 Draw a polygon N/A [1] Dc.fillPolygon() 1.0.0 
 Set the clip area Dc.setClip() N/A 2.3.0 
 The setColor() method allows you to set the foreground and background drawing colors. Colors are passed to setColor() as 24-bit colors of the form 0xRRGGBB. When setting a color, the device will select the closest available color on the system. To see what colors are available on devices, see the User Experience Guidelines . A clipping region can be set for a Dc object using the Dc.setClip() method. The top left corner coordinates, width, and height are specified to set this region. All pixels outside of this region will be unaffected by any drawing operations. The pixels within the region will be updated normally. The Dc.clearClip() method will remove the clipping region. Strings and Fonts
 Text can be drawn using the drawText() method. The Dc object also has methods available to get the text width and height of a string with a specified font. Note that text size methods are also available in the Graphics module outside the Dc object. Operation Function API Level 
 Draw a text string Dc.drawText() 1.0.0 
 Draw text at an angle Dc.drawAngledText() 4.2.2 
 Draw text oriented along an arc Dc.drawRadialText() 4.2.2 
 Get the width and height of a text string with a given font Dc.getTextDimensions() 1.0.0 
 Get the width of a text string with a given font Dc.getTextWidthInPixels() 1.0.0 
 Get the height of a given font Dc.getFontHeight() , Graphics.getFontHeight() 1.0.0, 1.2.0 
 Get the ascent of a given font Graphics.getFontAscent() 1.2.0 
 Get the descent of a given font Graphics.getFontDescent() 1.2.0 
 Retrieve a system vector font Graphics.getVectorFont() 4.2.2 
 Scalable Fonts
 Since API level 4.2.2 Font support for Garmin devices can vary from device to device. All devices support unicode bitmap fonts, but some devices support scalable fonts. If a device supports scalable fonts, the supported fonts are published in the Reference Guide as Scalable Font entries in the font list. To access a scalable font, you can call Graphics.getVectorFont() using the name from the device reference as the :face argument. The :face argument also will take an array of face names. This allows you to specify backup font faces that are acceptable for your needs in case the device doesn’t support your preferred choice. You can also specify the font size in pixels. Scalable fonts work with Dc.drawText() but can also be used with the Dc.drawAngledText() and Dc.drawRadialText() . These APIs only support scalable fonts and do not support custom fonts loaded as resources. Anti-Aliasing
 Since API level 3.2.0 By default, anti-aliasing of primitives like polygons and lines are disabled, but it can be enabled by calling Dc.setAntiAlias(true) . This method is not available before API level 3.2.0 so if your app runs with the API level set below 3.2.0 make sure to guard it with a has check. function draw(dc) { if(dc has :setAntiAlias) { dc.setAntiAlias(true); } dc.drawPolygon() } Alpha Channels, Color, Fills, Stroke and Blend Modes
 Since API level 4.0.0 API level 4.0.0 adds some powerful new tools to the Dc : Function Purpose Accepts API Level 
 Dc.setFill() Set fill tool for drawing primitives. Graphics.ColorType , Graphics.BitmapTexture 4.0.0 
 Dc.setStroke() Set pen tool for drawing primitives Graphics.ColorType , Graphics.BitmapTexture 4.0.0 
 Dc.setBlendMode() Set blend mode for drawing Graphics.BlendMode 4.0.0 
 Previously, the setColor() API allowed the setting of a foreground or background color based on a 24-bit RRGGBB value. setFill() and setStroke() both accept 32-bit AARRGGBB values, allowing you to provide an alpha channel value with the RGB value. The setStroke() API allows setting the pen tool for the Dc, while setFill() sets the fill tool. You can also set the blend mode with setBlendMode() . By default, the system will blend your color with whatever is being drawn over. However, you can use BLEND_MODE_NO_BLEND to set the color and alpha of a BufferedBitmap directly. You can also use BLEND_MODE_ADDITION to have your blend added to the channels being drawn to. In addition to colors, you can now also provide a BitmapTexture . This allows a primitive to be filled by a bitmap and opens up many new drawing possibilities. Bitmaps
 Bitmap resources can be added to your executable using the resource compiler . You can use Application.loadResource() to load a bitmap at runtime, and Dc.drawBitmap() or Dc.drawBitmap2() to render it to the screen on the View.onUpdate() call. Transformation
 Since API level 4.2.2 Connect IQ allows you to create two-dimensional affine transforms using the Graphics.AffineTransform class. AffineTransform provides access to the underlying transformation matrix and common operations like rotation , scaling and shearing [2] . To apply the transform, pass the AffineTransform into Dc.drawBitmap2() as the :transform argument in the options dictionary. Tinting
 Since API level 4.2.2 Sometimes you want the color of an asset, like an icon, to be user-definable. For example, you may want the complication icons on a watch face to match a user-defined theme color. One of the features of Dc.drawBitmap2() is the ability to apply a tint color to an asset. The :tintColor option can be used to specify a color to apply to a grayscale asset. Graphics Pool
 Since API level 4.0.0 Before API level 4.0.0, all resources loaded at runtime into the application heap. This heap is used to hold your code, data, stack and runtime objects, so loading images could quickly limit the runtime functionality of your app. API level 4.0.0 introduced a new graphics pool that is separate from your application heap. When you load a bitmap or font at runtime, the resource will load into the graphics pool, and you will be returned a Graphics.ResourceReference . The graphics pool dynamically caches, unloads and reloads your resources behind the scenes based on available memory. All the drawing primitives that accept resource objects also accept references so your app should not have to be reworked to take advantage of the new system. Calling ResourceReference.get() on a reference will return a resource object. As long as the object returned is in scope, the resource will be locked in the graphics pool. Buffered Bitmaps
 Since API level 2.3.0 The Graphics.BufferedBitmap class can be used to draw to surface other than the primary display surface. There are two options for creating a BufferedBitmap object. The first is to generate one from a loaded bitmap resource. In this case, the provided bitmap is used as the drawing surface that is manipulated. The second option is to specify the width, and height of the surface, and optionally a color palette. If no color palette is specified, the BufferedBitmap will use the system colors, and will not have a palette. If a bitmap resource is provided to the initializer, the width, height, and palette parameters are ignored. If a BufferedBitmap does have a palette, it can be read using the BufferedBitmap.getPalette() method. The palette can also be modified using the BufferedBitmap.setPalette() method. The palette provided must have the same number of colors as the existing palette for that bitmap. All pixels in the image will change color to the new color assigned at each color index. Note that Bitmaps with a palette that are generated by the resource compiler will have an additional transparent index at the end of the specified palette unless the disableTransparency flag has been specified. A Drawing Context can be obtained from the BufferedBitmap using the BufferedBitmap.getDc() method. This returns a Dc class that has the same capabilities as the primary device Dc that is provided to the methods View.onLayout() , View.onUpdate() , and View.onPartialUpdate() . This object can be used to modify the contents of the BufferedBitmap by drawing shapes, text, and bitmaps to it. Buffered Bitmaps and the Graphics Pool
 BufferedBitmap objects, like other graphics resources, now take advantage of the graphics pool, as well. The advantage of this scenario is that you can now liberally use temporary graphics buffers without running out of application heap. As noted earlier, the graphics pool will intelligently purge and restore resources from the pool if the loaded resources exceed the available pool space. Unlike static resources that are reloaded from your executable, BufferedBitmap are not restored if they have been purged. This works fine if you are using a short-lived, temporary buffer, but if your bitmap is purged after allocation, you need to re-render its contents. Alternatively, you can call the get() method on the reference to get a locked version of the bitmap. This will prevent the BufferedBitmap object from being purged from the pool, but it can also lead to the graphics pool running out of available space if more resources are loaded. To create a BufferedBitmap , use the Graphics.createBufferedBitmap() API. If your application runs on pre-API level 4.0 devices, use a has check for allocating your BufferedBitmap : import Toybox.Graphics; //! Factory function to create buffered bitmap function bufferedBitmapFactory(options as { :width as Number, :height as Number, :palette as Array&lt;ColorType&gt;, :colorDepth as Number, :bitmapResource as WatchUi.BitmapResource }) as BufferedBitmapReference or BufferedBitmap { if (Graphics has :createBufferedBitmap) { return Graphics.createBufferedBitmap(options); } else { return new Graphics.BufferedBitmap(options); } } Yes, really. &nbsp;↩ 
 I’m so glad I wasn’t the one to come up with this . &nbsp;↩


# [Input Handling](https://developer.garmin.com/connect-iq/core-topics/input-handling/)nMenu Core Topics Input Handling
 As if input handling wasn’t already one of the most important and complicated pieces of a UI toolkit, Garmin devices take the complication up a level. Unlike those touchable glowing rectangles that are modern smart phones, Garmin devices come in lots of shapes and sizes. Touch screens are not always ideal for all watch products, so there is a mix of input styles and screen technologies. It’s the job of the UI toolkit to make this coherent to the developer. Input and App Types
 Not all app types have full access to input. A watch face can only know if it has been pressed and data fields can only know if they have been tapped . Widgets and glances can receive input (may be limited on some devices) while watch-apps will have the most input capability. Input Delegates
 The delegate object implements a certain interface specific to input handling. Monkey C provides a low level WatchUi.InputDelegate that allows handling of events at a basic level. This is useful for situations when the app needs to handle button presses or touchscreen interactions in a particular way. API Purpose API Level 
 InputDelegate.onDrag() This is sent when the user is dragging the touch screen 3.3.0 
 InputDelegate.onFlick() This is sent when the user has flicked the touch screen 3.3.0 
 InputDelegate.onKey() A physical button has been pressed and released 1.0.0 
 InputDelegate.onKeyPressed() A physical button has been pressed down 1.1.0 
 InputDelegate.onKeyReleased() A physical button has been pressed released after being pressed down 1.1.0 
 InputDelegate.onTap() This is sent when the touch screen is tapped (a quick touch and release) 1.0.0 
 InputDelegate.onHold() This is sent when the touch screen is touched and not released 1.0.0 
 InputDelegate.onRelease() This is only sent after an onHold() event, once the hold on the touch screen is released 1.0.0 
 InputDelegate.onSwipe() This is sent when the touch screen is swiped 1.0.0 
 To process input events, extend the InputDelegate and override the appropriate handler operation. If you return true in the handler, the system will know the event has been handled. Returning false will tell the system to handle the input. For more see the Input sample app distributed with the SDK. Behaviors
 Garmin makes products with a purpose, and that purpose can alter the design of one product line over another. Deciding whether a product has a touch screen or has buttons can depend on the environment in which the user will take. For instance, if the product is intended to be used in water (swimming, canoeing, on a boat), it may not have a touch screen. These decisions make for superior products, but also add to developer frustration due to device fragmentation. Most products will support common behaviors (next page, back a page), but how they are executed by the user may differ based on the available input types. To help with this dilemma, Monkey C exposes events at a behavior level. Behaviors separate high-level intentions from the actual input type—next page versus screen press. The WatchUi.BehaviorDelegate is a super class of InputDelegate and maps its low level inputs to common operations across multiple products. Using the BehaviorDelegate can lead to much more portable code. API Purpose API Level 
 BehaviorDelegate.onBack() Handle the user performing the back behavior 1.0.0 
 BehaviorDelegate.onMenu() Handle the user performing the menu behavior 1.0.0 
 BehaviorDelegate.onNextPage() Handle the user performing a next page in page loop behavior 1.0.0 
 BehaviorDelegate.onPreviousPage() Handle the user performing a previous page in page loop behavior 1.0.0 
 BehaviorDelegate.onSelect() Handle the user performing a select behavior 1.0.0 
 Selectables and Buttons
 Selectables
 Since API level 2.1.0 Monkey C provides an interface for products with large touch screens (and few buttons) to easily define touchable objects on-screen known as a WatchUi.Selectable . A Selectable is a state driven object that supports four optional built-in states which are set based on touch interaction: Default ( :stateDefault ) - Initial state
 Highlighted ( :stateHighlighted ) - Selectable is currently being pressed
 Selected ( :stateSelected ) - Selectable was pressed and released (i.e. tapped)
 Disabled ( :stateDisabled ) - Selectable has been disabled
 
 Once a state change occurs, a WatchUi.SelectableEvent is sent which results in a call to InputDelegate.onSelectable() , which passes both the instance of the current Selectable and the symbol of the previous state for comparison, and allows for custom actions as a result of the state change. Selectables must be registered as part of the View’s layout via the View.setLayout() call in order to for the View to know about them and direct touch events to the object. Stacked instances of Selectables will have input directed to them depending on their order as passed to setLayout() (last in, first drawn / selected). Each of the four states must be mapped to a Drawable , Graphics.COLOR constant, or 24-bit integer of the form 0xRRGGBB. States are optionally defined and be specified in the Selectable constructor, or manually modified as members of the instance. Each Selectable will draw the current state using the defined locX and locY coordinates as an offset if it has been defined. Extending Selectable with additional states is encouraged and the getState() and setState() routines may used to alter the default state machine (see Selectable sample application for a demonstration of check boxes). A Button is derived from Selectable and adds the ability to define a background and map interaction to an existing or new custom method (i.e. onMenu() ) within BehaviorDelegate . Button-Only and Touch Screen Interfaces
 It can be difficult to make a user interface that operates with both button-only products and products with touch screens. You can use View.setKeyToSelectableInteraction() to enable compatibility mode with button-only products. setKeyToSelectableInteraction() may be called to enable the up/down keys to cycle through the list of Selectables registered via the View’s setLayout() call, which sets the highlighted state on a Selectable until it is put in the Selected state via the enter key. Defining Selectables And Buttons In Layouts
 Much like their parent Drawable , Selectables and Buttons both support the layout system. Selectable and Button XML resources consist of a list of state ID’s and optional parameters. To create an XML Selectable, define a &lt;selectable&gt; in an XML resource file: Attribute Definition Valid Values Default Value Notes 
 id The ID of the Selectable Any string that starts with a character NA 
 x The X coordinate of the top left corner of the Selectable region pixel value, a relative position using ‘%’, center , left , right , or start N/A Required 
 y The Y coordinate of the top left corner of the Selectable region pixel value, a relative position using ‘%’, center , top , bottom , or start N/A Required 
 width The width of the Selectable region pixel value or a relative dimension using ‘%’ or fill N/A Required 
 height The height of the Selectable region pixel value or a relative dimension using ‘%’ or fill N/A Required 
 The &lt;button&gt; resource expands the definition of &lt;selectable&gt; and adds the following: Attribute Definition Valid Values Default Value Notes 
 behavior A method existing within a View’s registered BehaviorDelegate Method symbol null Optional / Param 
 background The background color of the Button Graphics.ColorValue color constant or a 24-bit integer of the form 0xRRGGBB Graphics.COLOR_TRANSPARENT Optional / Param 
 Both &lt;selectable&gt; and &lt;button&gt; tags use &lt;state&gt; as child nodes to define their states at construction. Each state is defined optionally but is defined as the following: Attribute Definition Valid Values Default Value Notes 
 id The state ID for the Button / Selectable stateDefault , stateHighlighted , stateSelected , or stateDisabled N/A Required 
 bitmap A bitmap resource in the layout drawn at the Selectable / Button origin WatchUi.Bitmap objects N/A Required or either color or drawable must be specified 
 color A color fill applied to the Selectable / Button region Graphics.ColorValue color constant or a 24-bit integer of the form 0xRRGGBB Graphics.COLOR_TRANSPARENT Required or either bitmap or drawable must be specified 
 drawable A drawable object in the layout drawn at the Selectable / Button origin WatchUi.Drawable objects N/A Required or either bitmap or color must be specified 
 An example layout containing two a menu and back button: &lt;layout id="ButtonLayout"&gt; &lt;button x="40" y="center" width="50" height="50" background="Gfx.COLOR_BLACK" behavior="onBack"&gt; &lt;state id="stateDefault" bitmap="@Drawables.DefaultBackButton" /&gt; &lt;state id="stateHighlighted" bitmap="@Drawables.PressedBackButton" /&gt; &lt;state id="stateSelected" bitmap="@Drawables.PressedBackButton" /&gt; &lt;state id="stateDisabled" color="Graphics.COLOR_BLACK" /&gt; &lt;/button&gt; &lt;button x="115" y="center" width="50" height="50"&gt; &lt;state id="stateDefault" bitmap="@Drawables.DefaultMenuButton" /&gt; &lt;state id="stateHighlighted" bitmap="@Drawables.PressedMenuButton" /&gt; &lt;state id="stateSelected" bitmap="@Drawables.PressedMenuButton" /&gt; &lt;state id="stateDisabled" color="Graphics.COLOR_BLACK" /&gt; &lt;param name="background"&gt;Graphics.COLOR_BLACK&lt;/param&gt; &lt;param name="behavior"&gt;onMenu&lt;/param&gt; &lt;/button&gt; &lt;/layout&gt; For more, see the Selectable sample app distributed with the SDK.


# [Native Controls](https://developer.garmin.com/connect-iq/core-topics/native-controls/)nMenu Core Topics Native UI Controls
 Toybox.WatchUi provides a number of native widgets to handle input: Menus
 Generic Picker
 Confirmation Dialog
 Progress Bar
 Page Loops
 Toasts
 Data Fields
 Map Views
 
 Two additional handlers provided by WatchUi can be used to give feedback to the user: the confirmation dialog and progress dialog. Menus
 Menus are full screen lists of options for the user. Menus can be used to present options or settings for the user to choose from. Menu2
 Since API level 3.0.0 The WatchUi.Menu2 system allows for complex menu user interfaces. The Menu2 class includes new capabilities like graphical titles [1] , menu items that can be updated dynamically, and additional menu elements such as check boxes. The Menu2 system includes multiple new classes. Let’s start with the most simple of the new menu elements. Here is a basic implementation of a Menu2 using a simple WatchUi.MenuItem : import Toybox.WatchUi; class MyBehaviorDelegate extends WatchUi.BehaviorDelegate { function initialize() { BehaviorDelegate.initialize(); } function onMenu() as Boolean{ var menu = new WatchUi.Menu2({:title=&gt;"My Menu2"}); var delegate; // Add a new MenuItem to the Menu2 object menu.addItem( new MenuItem( // Set the 'Label' parameter "Item 1 Label", // Set the `subLabel` parameter "Item 1 subLabel", // Set the `identifier` parameter "itemOneId", // Set the options, in this case `null` {} ) ); menu.addItem( new MenuItem( "Item 2 Label", "Item 2 subLabel", "itemTwoId", {} ) ); // Create a new Menu2InputDelegate delegate = new MyMenu2Delegate(); // a WatchUi.Menu2InputDelegate // Push the Menu2 View set up in the initializer WatchUi.pushView(menu, delegate, WatchUi.SLIDE_IMMEDIATE); return true; } } While the Menu example is built using the resource system, the Menu2 example above is built programmatically. Let’s take a look at some of the new features demonstrated: new WatchUi.Menu2 The Menu2 class is a special WatchUi.View that is similar to Menu that presents the user with a list of options. MenuItem The MenuItem object constructor takes four parameters: label , subLabel , identifier , and options . Each MenuItem can display a label and sub-label defined by the first two parameters. Here is a diagram that demonstrates the layout of the label and sub-label in MenuItem : An Illustration of label and sub-labels in Menu2 The MenuItem identifier is an object, typically a string, and is used to identify the MenuItem object in event calls. There is a fourth parameter which is a Dictionary of options which can be null . WatchUi.Menu2InputDelegate The new Menu2InputDelegate class is used to handle selected Menu2 items. This object handles these selections with three methods: onBack() - Handles the back key and pops the current page off the stack if not overridden.
 onDone() - Used with a specialized CheckboxMenu . Pops the current page when not overridden.
 onSelect() - Handles when a Menu2 item is selected.
 
 For more, see the Menu2Sample sample app distributed with the SDK. Menu2 XML Resources
 A basic Menu2 can be defined in XML as a resource as follows: &lt;menu2 id="MainMenu" title="@Strings.MainMenuTitle"&gt; &lt;menu-item id="generic1" label="Generic 1" subLabel="With Sublabel"&gt;&lt;/menu-item&gt; &lt;menu-item id="generic2" label="Generic 2"&gt;&lt;/menu-item&gt; &lt;/menu2&gt; Here are the attributes and definitions of a Menu2 defined as an XML resource: Attribute Definition Valid Values Default Value Notes 
 id The ID of the &lt;menu-item&gt; Any string that starts with a character NA Required 
 title The label text to be displayed as the header A valid Drawable identifier, a string resource, or String NA optional 
 icon The icon to display in the sub-window (Instinct 2 only) Bitmap resource identifier NA 
 dividerType The location of the divider (5.0.1+ device support only) A DividerType WatchUi.Menu2.DIVIDER_TYPE_DEFAULT optional 
 theme The background color of a menu item A MenuTheme or “disabled” WatchUi.MENU_THEME_DEFAULT optional 
 personality The personality class for the menu A defined personality class NA See Monkey Style &nbsp; 
 The MenuItem identified as “generic1” uses both a label and sublabel. The “generic2” item uses only a label. Here are the attributes and definitions of a MenuItem defined as an XML resource: Attribute Definition Valid Values Default Value Notes 
 id The ID of the &lt;menu-item&gt; Any string that starts with a character NA Required 
 label The label text to be displayed A valid string resource or String NA Required 
 subLabel The sub-label text to be displayed A valid string resource or String NA 
 icon The icon to display in the sub-window (Instinct 2 only) Bitmap resource identifier NA 
 The most exciting part about Menu2 is the use of icons, check boxes and toggles within menus. All Menu2 items can be created and launched in the same way, but each new menu item behaves uniquely. We’ve already seen the basic MenuItem class. Lets talk about some of the specifics when using the others. Icon Menu Item
 The IconMenuItem class allows developers to implement an icon based menu system. The IconMenuItem uses a label and sub-label, but also includes an icon that may be displayed to the right or left of the label and sub-label text. An illustration of an IconMenuItem in Menu2 Here is an IconMenuItem created as an XML resource: &lt;menu2 id="IconMenu" title="@Strings.IconMenuTitle"&gt; &lt;icon-menu-item id="defaultAlign" label="@Strings.IconDefaultLabel" subLabel="@Strings.IconDummySubLabel" icon="@Drawables.LauncherIcon" /&gt; &lt;icon-menu-item id="right" label="@Strings.IconRightLabel" subLabel="@Strings.IconDummySubLabel" icon="@Drawables.LauncherIcon"&gt; &lt;param name="alignment"&gt;WatchUi.MenuItem.MENU_ITEM_LABEL_ALIGN_RIGHT&lt;/param&gt; &lt;/icon-menu-item&gt; &lt;/menu2&gt; Here are the attributes available for &lt;icon-menu-item&gt; : Attribute Definition Valid Values Default Value Notes 
 id The ID of the &lt;icon-menu-item&gt; Any string that starts with a character NA Required 
 label The label text to be displayed A valid string resource or String NA Required 
 subLabel The sub-label text to be displayed A valid string resource or String NA 
 icon The icon to be displayed A valid drawable resource or custom drawable NA Required 
 Checkbox and Toggle Menu Items
 The WatchUi.CheckboxMenuItem allows users to check multiple items in a list of menu items and save their state at one time (i.e. selecting play lists for music content). The CheckboxMenuItem class is used in combination with a class extending the WatchUi.CheckboxMenu View and a Menu2InputDelegate . An illustration of a CheckboxMenuItem in Menu2 Developers define a CheckboxMenuItem using XML as follows: &lt;checkbox-menu id="CheckMenu" title="@Strings.CheckMenuTitle"&gt; &lt;checkbox-menu-item id="defaultAlign" label="@Strings.CheckDefaultLabel" subLabel="@Strings.CheckDefaultSubLabel" checked="true" /&gt; &lt;checkbox-menu-item id="right" label="@Strings.CheckRightLabel" subLabel="@Strings.CheckRightSubLabel" checked="false"&gt; &lt;param name="alignment"&gt;Ui.MenuItem.MENU_ITEM_LABEL_ALIGN_RIGHT&lt;/param&gt; &lt;/checkbox-menu-item&gt; &lt;/checkbox-menu&gt; The ToggleMenuItem class is an element that indicates a menu item is in one of two states: :enabled or :disabled . See the change in the image below: An illustration of a ToggleMenuItem in Menu2 You can create a ToggleMenuItem as a resource using XML: &lt;menu2 id="ToggleMenu" title="@Strings.ToggleMenuTitle"&gt; &lt;toggle-menu-item id="defaultAlign" label="@Strings.ToggleLabel1" subLabel="@Strings.ToggleOnSubLabel" disabledSubLabel="@Strings.ToggleOffSubLabel" checked="true" /&gt; &lt;toggle-menu-item id="left" label="@Strings.ToggleLabel2" subLabel="@Strings.ToggleOnSubLabel" disabledSubLabel="@Strings.ToggleOffSubLabel" checked="false"&gt; &lt;param name="alignment"&gt;WatchUi.MenuItem.MENU_ITEM_LABEL_ALIGN_LEFT&lt;/param&gt; &lt;/toggle-menu-item&gt; &lt;/menu2&gt; The &lt;checkbox-menu-item&gt; and &lt;toggle-menu-item&gt; attributes are identical in name and function: Attribute Definition Valid Values Default Value Notes 
 id The ID of the &lt;toggle-menu-item&gt; or &lt;checkbox-menu-item&gt; Any string that starts with a character NA Required 
 label The label text to be displayed A valid string resource or String NA Required 
 subLabel The sub-label text to be displayed when checked is true A valid string resource or String NA 
 disabledSubLabel The sub-label text to be displayed when checked is false A valid string resource or String NA 
 checked The boolean state of the &lt;toggle-menu-item&gt; or &lt;checkbox-menu-item&gt; true for :enabled , false for disabled false Value will switch even when not defined in XML 
 icon The icon to display in the sub-window (Instinct 2 only) Bitmap resource identifier NA 
 dividerType The location of the divider (5.0.1+ device support only) A DividerType WatchUi.Menu2.DIVIDER_TYPE_DEFAULT Optional 
 The checked attribute is automatically created as part of a ToggleItem or CheckboxItem object and does not have to be defined in XML. If it is not defined in XML, then it will default to false . For a MenuItem using graphical elements such as toggles and check boxes, developers can choose to align the elements to the left or right of the MenuItem label. If not defined, then elements will be aligned to the right as seen in the defaultAlign toggle menu above. A &lt;param&gt; tag with the desired MenuItem.MENU_ITEM_LABEL_ALIGN_* value is used to set the alignment of icons, checks, and toggles. Developers can also explicitly align items to the right by using the MenuItem.MENU_ITEM_LABEL_ALIGN_RIGHT value. Action Menus
 Since API level 3.4.0 Action views are screens that both provide information and provide a contextual menu of actions. These actions might be next steps or tasks that can be performed on the visible information. For more, see the WatchUi.showActionMenu() API and the Action Views chapter of the Personality Library. Original Menu API
 WatchUi.Menu is the older API for providing a list of options for the user. The options are displayed in a list that matches the device the app is running on. A menu can be defined in the resource XML file using the following format: &lt;menu id="MainMenu"&gt; &lt;menu-item id="item_1" label="@Strings.menu_item_1_label" /&gt; &lt;menu-item id="item_1" label="@Strings.menu_item_2_label" /&gt; &lt;/menu&gt; The resource compiler will then take this XML and generate a Menu object in the Rez module. In order to use this menu, a developer simply needs to push the menu and a delegate for the menu using WatchUi.pushView() : class MyView extends WatchUi.View { function openTheMenu() { WatchUi.pushView( new Rez.Menus.MainMenu(), new MyMenuDelegate(), Ui.SLIDE_UP ); } } class MyMenuDelegate extends WatchUi.MenuInputDelegate { function onMenuItem(item) { if ( item == :item_1 ) { // Do something here } else if ( item == :item_2 ) { // Do something else here } } } Generic Picker
 The Picker class, along with the PickerDelegate and PickerFactory classes, provides applications with the ability to create on-screen lists of user-selectable objects. A picker consists of one or more objects, a title, a next and previous arrow, and a confirm button. The next and previous arrows and the confirm button are device specific but can be overwritten if desired. Pickers are pushed using WatchUi.pushView() , providing a PickerDelegate for the input delegate. A PickerFactory is required to indicate what should be displayed for each pick-able value. User Interface
 The above image is a representation of the general structure of what a picker should look like on a square screen. Other screen formats should have the same layout with some size differences to account for the screen and button layout. The top red bar represents where the title of the picker is displayed.
 Up and down arrows to scroll through the available options are placed where the green boxes are.
 The leftmost blue box is where the last item you selected is shown if the picker has multiple selectable items.
 The center blue box is the item you are currently selecting.
 The white box will either be the next selectable item in the list or the button to confirm your selection.
 
 For more, see the Picker sample app distributed with the SDK. Confirmation Dialog
 The WatchUi.Confirmation and WatchUi.ConfirmationDelegate provides a simple yes/no dialog. This is useful when presenting a simple selection to the user. For more, see the ConfirmationDialog sample app distributed with the SDK, and the Confirmations section of the Personality Library. Progress Bar
 The progress dialog gives a standard wait dialog. It has two modes—one that shows the completion of some process, and a second that acts a wait timer displaying an indeterminate amount of progress. The look and feel of the progress bar will be device-specific. For more, see the ProgressBar sample app distributed with the SDK, and the Progress Bars section of the Personality Library. Page Loops
 Page loops&nbsp;are carousels of views. When the user is in a page loop, the user interface presents a set of pages of information that provide different data and insights to the user. There are standard behaviors for going to the next and previous pages. Advancing from the last page typically loops the user back to the first page. For more, see the WatchUi.ViewLoop API, and the Page Loops section of the Personality Library. Toasts
 Since API level 3.4.0 Toasts are partial screen banners with text and an optional icon. The user cannot interact with them, and they dismiss after a short period. Toasts are good for informing users about asynchronous events without disrupting what they are currently doing. For more, see the WatchUi.showToast() API, and the Toasts section of the Personality Library. Data Field
 Data fields function as plug-ins for the Garmin activity experience. After users install a data field from the store, they can place them inside of their activity pages for any Garmin activity. On devices with touch screen support, an input delegate can be used to accept input. Only the InputDelegate.onTap() behavior is supported and will be triggered when the user touches a point inside the data field when it is active on the screen. The behavior delegate should be the second element of the array that is returned from AppBase.getInitialView() as with other app types. // This data field accepts touch input class DataFieldApp extends App.AppBase { // Data field view with associated behavior delegate function getInitialView() { return [ new DataFieldView(), new DataFieldDelegate() ]; } } class DataFieldDelegate extends Ui.InputDelegate { // Handle touch events function onTap(evt) { // Process the touch event } } Alerts
 Since API level 3.2.0 When you want your data field to notify the user of a specific event, you can push a view that extends DataFieldAlert . DataFieldAlert is a special instance of View that can be presented to the user with showAlert . The alert does not accept input and will time out after the standard alert period. The user is required to enable alerts for your app in the workout alert settings. Mapping
 Since API level 3.0.0 Connect IQ enables developers to embed map views into their apps on products with onboard cartography. Mapping is accessible in two ways: The WatchUi.MapView and the WatchUi.MapTrackView . MapViews
 The MapView class is pushed like any other View class, but has some unique characteristics. Namely, MapView objects give you access to a rendering of a specified portion of the on-board map for a device. MapView objects let you choose a portion of a map to focus on by using two points of the type Location . Here is the setup for a basic MapView : import Toybox.WatchUi; import Toybox.Position; class MyMapView extends MapView { // Initialize the MapView function initialize() { MapView.initialize(); // Set the top left Location object for the Map Visible Area var topLeft = new Position.Location({:latitude =&gt; 38.85695, :longitude =&gt;-94.80051, :format =&gt; :degrees}); // Set the bottom right Location object for the Map Visible Area var bottomRight = new Position.Location({:latitude =&gt; 38.85391, :longitude =&gt;-94.7963, :format =&gt; :degrees}); // Set the area of the map to be displayed MapView.setMapVisibleArea(topLeft, bottomRight); // Set the area in which to display the selected map area MapView.setScreenVisibleArea(0, 0, 240, 240/2); // Set the map mode MapView.setMapMode(WatchUi.MAP_MODE_PREVIEW); } } Let’s dissect this a bit to learn about the view itself: MapView.initialize() It is recommended to set the parameters of your MapView in it’s initialize() function as shown here. MapView.setMapVisibleArea() This method takes top_left and bottom_right parameters as Position.Location objects. These two locations create a bounding box that defines the view area of the map which are the top-left and bottom-right most Location objects that must be displayed on the initial map render. Conceptually, this works itself out into a rectangular portion of a map that must be focused on for the initial render of the MapView. MapView.setScreenVisibleArea() MapViews allow developers to overlay UI items on top. Sometimes you want the entire screen to have the map image, but other times you’ll want to split the display between map and UI elements. If you want the map area to not be the center of the screen you can use this method to define the rectangular area. This method determines the rectangular area in which the area of the map defined in the setMapVisibleArea() call should be rendered. Here is a figure to help illustrate the relationship where the blue rectangles represent the map area and the red rectangles represent the screen area. An Illustration of relationship between Map Area and the Screen Area MapView.setMapMode() This call sets the map mode to one of the MAP_MODE_* enum values. MapViews and MapTrackViews have two modes: Preview: Selected with the MAP_MODE_PREVIEW enum value. This allows a non-movable map to be rendered on the screen.
 Browse: Selected with the MAP_MODE_BROWSE enum value. This mode allows the user to zoom, pan, and move the map using the system default controls.
 
 MapTrackView
 The MapTrackView is similar to the MapView in all ways except for one. The MapTrackView will dynamically render the active location of the device on the screen. For more, see the MapSample sample app distributed with the SDK. Mapping Artifacts
 Maps can add context with your content, but only if you can combine them together. Thankfully, not only can you access the maps native to devices, you can draw on them too! Monkey C has two new objects to interact with maps: MapPolyline and MapMarker . MapPolyline
 The MapPolyline object allows developers to draw a line with multiple points of location on a MapView rendering of a map. Only one MapPolyline object is allowed in a view. Here is an example of a MapPolyline with four points: // Initialize a new MapPolyline object var polyline = new WatchUi.MapPolyline(); //Set the color of the MapPolyline polyline.setColor(Toybox.Graphics.COLOR_RED); // Set the pen width to draw the MapPolyline polyline.setWidth(2); // Set the Locations on the MapPolyline polyline.addLocation( new Position.Location({ :latitude =&gt; 38.85391, :longitude =&gt;-94.79630, :format =&gt; :degrees }) ); polyline.addLocation( new Position.Location({ :latitude =&gt; 38.85465, :longitude =&gt;-94.79922, :format =&gt; :degrees }) ); polyline.addLocation( new Position.Location({ :latitude =&gt; 38.85508, :longitude =&gt;-94.79959, :format =&gt; :degrees }) ); polyline.addLocation( new Position.Location({ :latitude =&gt; 38.85557, :longitude =&gt;-94.79864, :format =&gt; :degrees }) ); // Set the MapPolyline object to draw on the map MapView.setPolyline(polyline); new WatchUi.MapPolyline This creates a new instance of MapPolyline object. setColor() Sets the color of the MapPolyline with a COLOR_* enum value. setWidth() Sets the pen width used to draw the MapPolyline in pixels. addLocation() This method takes a Location object and adds it to an Array of MapPolyline objects. These locations make up the points used to draw the lines that comprise the MapPolyline representation on the map. MapView.setPolyline() This sets the MapPolyline object to be rendered on the map in the MapView or MapTrackView . In this example it is using the MapPolyline object stored as polyline . MapMarker
 The MapMarker object pairs a Location object with a BitmapResource to create a marker to be draw on a map. Each Bitmap image used in a MapMarker object will have a “hotspot” for the image. The hotspot is the point of the image that will be drawn at the latitude and longitude for the provided Location for the MapMarker . Here is a simple implementation of a MapMarker object: // Initialize a map marker with a Location object var bitmapMarker = new WatchUi.MapMarker( new Position.Location({ :latitude =&gt; 38.85391, :longitude =&gt;-94.79630, :format =&gt; :degrees }) ); bitmapMarker.setIcon(WatchUi.loadResource(Rez.Drawables.MapPin), 12, 24); bitmapMarker.setLabel("Custom Icon"); var defaultMarker = new WatchUi.MapMarker( new Position.Location({ :latitude =&gt; 38.85508, :longitude =&gt;-94.79959, :format =&gt; :degrees }) ); defaultMarker.setIcon(WatchUi.MAP_MARKER_ICON_PIN, 0, 0); defaultMarker.setLabel("Predefined Icon"); // Set the Map Marker for the view MapView.setMapMarker(defaultMarker); Let’s look at the code above to get a better handle on the APIs. new WatchUi.MapMarker The MapMarker object is initialized with the Location object passed to it. This is be the point at which the MapMarker hotspot of the Bitmap resource is be drawn. bitmapMarker.setIcon(WatchUi.loadResource(Rez.Drawables.MapPin), 12, 24) This call sets the icon of the MapMarker named bitmapMarker to the bitmap resource Rez.Drawables.MapPin . The hotspot is set to 12 for the x coordinate of the bitmap and 24 for the y coordinate of the MapPin icon. setLabel() Sets the label of the MapMarker icon to be displayed on the rendered map. defaultMarker.setIcon(WatchUi.MAP_MARKER_ICON_PIN, 0, 0) This MapMarker is using the MAP_MARKER_ICON_PIN enum value when setting the icon and use the system default icon for marking the point on the map. Note that the provided values for x, y for the hotspot are 0, 0 respectively. When using the default icon, the hotspot management is handled by the system. setMapMarker() The setMapMarker() method takes a MapMarker object and sets it on the map. In this example only the defaultMarker is set to be drawn on the map. However, it is acceptable to set multiple MapMarker objects by setting them in an Array . For example: // Create an Array to hold the MapMarker objects var markers = []; // Add the MapMarkers to the Array markers.add(bitmapMarker); markers.add(defaultMarker); // Set multiple markers in an Array MapView.setMapMarker(markers); Simulating Maps
 When working with maps in the simulator, Connect IQ uses web APIs to retrieve map images to simulate on-device behavior. Simulator and on-device mapping coverage with vary as on-device mapping is contingent on the device and maps available. Here is the detail coverage map for the simulator: Green: Low detail
 Blue: Medium detail
 Red: High detail
 
 The detail map available on the Connect IQ Simulator Graphical titles are currently only supported via programmatic creation of MenuItem elements in Menu2 . Defining a title as a drawable resource will result in compiler error. &nbsp;↩


# [Resources](https://developer.garmin.com/connect-iq/core-topics/resources/)nMenu Core Topics Resources
 The resource compiler compiles images, text, and static data into a resource database that the application can access at run time. The resource compiler is tied into the Monkey C compiler. Its input is an XML file: &lt;resources&gt; &lt;bitmap id="bitmap_id" filename="path/for/image" /&gt; &lt;font id="font_id" filename="path/to/fnt" /&gt; &lt;string id="string_id"&gt;Hello World!&lt;/string&gt; &lt;/resources&gt; The Resource Module (a.k.a. Rez)
 The resource compiler auto-generates a Monkey C module named Rez that contains the resource IDs for the resource file. These identifiers, of type ResourceId , are used to refer to your resources: The code can use the Rez class to reference the resources at run time. You can use the following APIs: API Purpose API Level 
 WatchUi.loadResource() Load a resource from the PRG into memory 1.0.0 
 Application.loadResource () [1] Load a resource from the PRG into memory 3.1.0 
 For example, let’s say you have a bitmap you want to use in your view. Before it can be used by the app, it must be loaded from the resource file: image = Application.loadResource( Rez.Drawables.bitmap_id ) as BitmapResource; Now the bitmap can be drawn in the update handler: dc.drawBitmap( 50, 50, image ); Resources are reference counted just like other Monkey C objects. Loading a resource can be an expensive operation, so do not load resources when handling screen updates. Referencing Resources Within Resource Files
 Resources can also be referenced from within another resource file. To do this use the syntax @&lt;module&gt;.&lt;id&gt; . For example, you could reference a String resource within a menu definition using the following code. &lt;string id="menu_item_1_label"&gt;Item 1&lt;/string&gt; &lt;menu id="MainMenu"&gt; &lt;menu-item id="item_1" label="@Strings.menu_item_1_label" /&gt; &lt;/menu&gt; This code would use the string defined with an ID of menu_item_1_label as the label for the menu item. Resource Scopes
 Since API level 3.1.0 Adding resources to an app comes with a minor runtime memory cost. While the cost is small, it can seriously cut into the available memory for background services and glances. To mitigate these costs, Connect IQ has an additional scope attribute to the following resource tags: &lt;layout&gt; , &lt;drawable-list&gt; , &lt;bitmap&gt; , &lt;string&gt; , &lt;font&gt; , &lt;jsonData&gt; . The scope attribute tells the resource compiler the type of application that the resource should be made available to. Valid values for the scope attribute are background , glance , and foreground . If the attribute is not specified for a resource, it will be considered part of the foreground scope by default. An example of using the scope attribute with string resources: &lt;resources&gt; &lt;string id="MyBackgroundString" scope="background"&gt;Background String&lt;/string&gt; &lt;string id="MyGlanceString" scope="glance"&gt;Glance String&lt;/string&gt; &lt;string id="MyForegroundString" scope="foreground"&gt;Foreground String&lt;/string&gt; &lt;/resources&gt; Use the scope attribute to save memory in your glance or background service. All background scoped resources will be available to the glance and foreground application. All glance scoped resources will be available to the foreground application, but not to the background service. Foreground scoped resources will only be available to the foreground application. Application Mode MyBackgroundString MyGlanceString MyForegroundString 
 Background Service X 
 Glance X X 
 Foreground X X X 
 In the example above, MyBackgroundString would be available when running the application in any valid mode. MyGlanceString would be available to the glance and foreground application, but not to the background service if present. MyForegroundString would only be available to the foreground application. By providing this hierarchy, developers can better determine how their resources should be scoped. See Background Services or Glances for more information. Strings
 Connect IQ products are used around the world, and those users want apps to work in their language. Connect IQ supports adding strings using a strings resource file: &lt;strings&gt; &lt;string id="identifier"&gt;String Value&lt;/string&gt; &lt;/strings&gt; At runtime, you can load this string using loadResource() . String definitions take the following attributes: Attribute Required Description 
 id Yes Identifier for the string 
 scope No See resource scopes . String can have the additional settings &nbsp;scope which removes it from the runtime. This is useful when a string is only used within your setting definitions. 
 translatable No Indicates if a string requires translations. Set to false to mark a string as not requiring translations. 
 Using localization qualifiers of your resource folders you can provide different strings for different languages. Adding the following suffixes to your resource folder will allow you to add string files for various languages Qualifier Language Notes 
 No qualifier Base language These strings will be used if no language is provided. If a translation is not provided for a string in a specific language, the system will use the base language version as a substitution. 
 ara Arabic 
 bul Bulgarian 
 ces Czech 
 dan Danish 
 deu German 
 dut Dutch 
 eng English 
 est Estonian 
 fin Finnish 
 fre French 
 hrv Croatian 
 hun Hungarian 
 ind Indonesian 
 ita Italian 
 jpn Japanese 
 kor Korean 
 lav Latvian 
 lit Lithuanian 
 nob Norsk Bokmål 
 pol Polish 
 por Portuguese 
 slo Slovak 
 slv Slovenian 
 spa Spanish 
 swe Swedish 
 rus Russian 
 ron Romanian 
 tha Thai 
 tur Turkish 
 ukr Ukrainian 
 vie Vietnamese 
 zsm Standard Malay 
 zhs Simplified Chinese 
 zht Traditional Chinese 
 You can combine these qualifiers with device, family and screen qualifiers to have strings that are customized to each device if necessary. See the Strings sample for an example of how to use the strings resource system. Bitmaps
 Garmin devices have different form factors, screen sizes and screen technologies, so bitmaps need to be explicitly converted for every device. The resource compiler will generate resources for every intended product, which allows the developer to have one set of resources for black and white products, one set for color products, one for larger screen sizes, etc. The resource compiler supports JPG/JPEG , BMP/WBMP , GIF , SVG and PNG file formats. While each device has a unique palette, the developer can specify a palette to use for an image. The resource compiler will map the colors that are defined in the developer’s palette to the closest match in the device palette and use only those colors. A palette can be defined using the following syntax: &lt;resources&gt; &lt;bitmap id="bitmap_id" filename="path/for/image"&gt; &lt;palette disableTransparency="false"&gt; &lt;color&gt;FF0000&lt;/color&gt; &lt;color&gt;FFFFFF&lt;/color&gt; &lt;color&gt;0000FF&lt;/color&gt; &lt;/palette&gt; &lt;/bitmap&gt; &lt;/resources&gt; The table below shows some of the valid attributes for a &lt;bitmap&gt; definition. Attribute Definition Valid Values Default Value Notes 
 id The handle for the layout, which is used to reference the layout in the Rez module Any value that starts with a letter NA Required 
 filename The relative path to the image file A valid, resolvable path to an image file NA Required 
 dithering The type of dithering to use when compiling the image floyd_steinberg or none floyd_steinberg 
 compress Indicate that the compiled bitmap should be compressed to reduce .PRG size true or false false 
 automaticPalette Automatically determine a reduced color palette to use while compiling the image. Images will be limited to 256 colors for 16-bit color devices. true or false true for 16-bit color devices 
 packingFormat The format with which the image will be encoded into the PRG default , png , jpg , yuv . default Options besides default only available on certain devices. See Bitmap Packing Formats 
 scaleX How should the image be scaled in the x dimension? Pixel size or percentage If scaleY is set, will default to scaleY ’s value. Otherwise will default to 100% of image width See scaleRelativeTo 
 scaleY How should the image be scaled in the x dimension? Pixel size or percentage If scaleX is set, will default to scaleX ’s value. Otherwise will default to 100% of image height See scaleRelativeTo 
 scaleRelativeTo What should the scale factor be based on? screen or image screen Sets what to base relative scaling on. If set to screen, image will be re-scaled based on product it is being built for at compile time 
 personality Personality class for the element Personality class None See Monkey Style 
 The valid attributes for a &lt;palette&gt; definition are in the table below. Attribute Definition Valid Values Default Value Notes 
 disableTransparency Should the compiler allow transparent pixels in the image? Disabling transparency may save memory true or false false 
 Bitmap Packing Formats
 Since API level 4.0.0 Images can grow your executable size, which can add extra wait when users install or update your app. To reduce executable bloat use these bitmap attributes for packing images into your executable. Each of the formats can have their advantages and disadvantages: Format Advantage Disadvantage Use Case 
 default Available on all products, fastest to load, supports alpha channel No compression App runs on pre-API level 4.0.0 devices. Low palette images can have very small runtime costs 
 png Lossless, compressed and supports alpha channel Slowest to load, which can add runtime cost if purged and reloaded frequently from the graphics pool Importing non-photo images with or without alpha channel 
 jpg Compresses very well, fast to load Lossy format and does not support alpha channel Importing photo imagery without alpha channel 
 yuv Compresses well, supports alpha channel, fast to load Lossy format Importing photo imagery with alpha channel 
 
 Fonts
 The resource compiler reads fonts in TXT or PNG format. You can use the BMFont tool (available at http://www.angelcode.com/products/bmfont/ ) to convert a font from many different formats to a compatible format. Prior to export, ensure that BMFont’s Font Settings specify the Unicode character set. Recommended export options are shown in the image below: The BMFont Export Options The color can be set using Dc.setColor() . Since bitmap fonts can take a lot of runtime memory, the font converter defaults to non-anti-aliased 1-bit fonts to save memory. If you know you will have the runtime RAM available, you can turn on font anti-aliasing with the antialias option. &lt;!-- Domo arigato mister font --&gt; &lt;font id="font_id" filename="roboto.fnt" antialias="true" /&gt; If you are creating a large font, sometimes, only particular glyphs need to be large-sized (like numbers for a watch face). Use the filter attribute to specify the particular glyphs to include: &lt;!-- Only include digits from this large font --&gt; &lt;font id="font_id" filename="big_font.fnt" filter="0123456789:"/&gt; Font elements accept the following attributes: Attribute Type Required Default Description 
 id String Yes None Unique identifier for the font 
 filename String Yes None BMFont generated .fnt &nbsp;file 
 filter String No None Optional string that outlines all characters to import from the font 
 antialias Boolean No false Boolean that identifies if fonts should be imported with anti-aliasing information 
 scope String No foreground See resource scopes 
 personality Personality class No None Personality class for the element. See Monkey Style &nbsp;for more information 
 Menus
 Menus are common UI elements on Connect IQ products. Menu resources allow you to define your menus within your resource definitions. Standard Menus
 Menus are defined using the &lt;menu2&gt; element, which has the following attributes: Attribute Type Required Default Description 
 id String Yes None Unique identifier for the menu 
 title String No None String, string resource identifier, or drawable resource identifier 
 icon Drawable reference No None Bitmap identifier. Used for Instinct 2 sub-screen icon. 
 personality Personality class No None Personality class for the element. See Monkey Style &nbsp;for more information 
 Within a &lt;menu2&gt; element can be an array of &lt;menu-item&gt; , &lt;toggle-menu-item&gt; , or &lt;icon-menu-item&gt; types. Standard Menu Items
 Standard menu items are contained within &lt;menu-item&gt; elements and have the following attributes: Attribute Type Required Default Description 
 id String Yes None Unique identifier for the menu item 
 label String Yes None String title for the menu item 
 subLabel String No None String sub-title for the menu item 
 icon Drawable reference No None Drawable icon displayed in the Instinct 2 sub-screen [2] 
 personality Personality class No None Personality class for the element. See Monkey Style &nbsp;for more information 
 Toggle Menu Items
 Toggle menu items are contained within the &lt;toggle-menu-item&gt; element. In addition to the attributes mentioned in standard menu items , they have the following attributes: Attribute Type Required Default Description 
 disabledSubLabel String No None Separate sub-label for when the toggle id in the disabled state 
 checked Boolean No false true &nbsp;if toggle should be enabled, false &nbsp;otherwise 
 Icon Menu Items
 Icon Menu items are defined with the &lt;icon-menu-item&gt; element. With icon menu icons, the icon attribute is displayed in the menu item. Checkbox Menus
 Checkbox menus are defined with the &lt;checkbox-menu&gt; element, which has the same attributes as standard menus . Inside of the checkbox menu can be a sequence of &lt;checkbox-menu-item&gt; elements. Checkbox Menu Items
 Checkbox menu items are defined with the &lt;checkbox-menu-item&gt; element. In addition to the attributes mentioned in standard menu items , they have the following attributes: Attribute Type Required Default Description 
 checked Boolean No false true &nbsp;if toggle should be enabled, false &nbsp;otherwise 
 Action Menus
 Action menus are contextual menus associated with a page. Action menus are defined with the &lt;action-menu&gt; element, which can have the following attributes: Attribute Type Required Default Description 
 id String Yes None Unique identifier for the menu 
 theme WatchUi.ACTION_MENU_THEME_DARK &nbsp;or&nbsp; WatchUi.ACTION_MENU_THEME_LIGHT No WatchUi.ACTION_MENU_THEME_DARK Allows configuring if the action menu is light on dark or dark on light. Not configurable on all products. 
 personality Personality class No None Personality class for the element. See Monkey Style &nbsp;for more information 
 Action Menu Items
 Action menu items are contained within &lt;action-menu-item&gt; elements and have the following attributes: Attribute Type Required Default Description 
 id String Yes None Unique identifier for the menu item 
 label String Yes None String title for the menu item 
 personality Personality class No None Personality class for the element. See Monkey Style &nbsp;for more information 
 Animations
 Since API level 3.1.0 The Monkey Motion tool included in the Connect IQ SDK that can be used to generate animation resources for compatible Connect IQ products. The Monkey Motion tool supports importing from YUV and GIF file formats. Due the fact that YUV is a true color, close-to-raw file format, it is the recommended format when entering a high quality animation into the Monkey Motion encoder tool. If necessary, FFmpeg is a convenient tool for converting video file formats. For example, if your creative team has provided a video in some other popular format, convert the file to the YUV format: &gt; ffmpeg -i input.mp4 -vf format=yuv420p output.y4m Additionally, to overcome the fact that the YUV format does not support transparency (unlike the GIF file format), the Monkey Motion tool accepts an additional YUV file as input. This video file should represent an alpha channel mask of the original animation that contained transparency. Again, FFmpeg is a convenient tool for creating such a video. The alphaextract option can be used to take an input stream with an alpha channel and return a video containing just the alpha component as a greyscale value: &gt; ffmpeg -i input.gif -vf alphaextract,format=yuv420p output.y4m For the same reasons outlined in the section above, animations need to be explicitly converted for every device. For easy import into your Connect IQ application, the Monkey Motion tool batch converts video to binary encoding [3] for devices you select. Including Animation Resources in a Monkey C Project
 To include an animation resource in a Monkey C project, define an animation resource. This can be done manually or by using the Monkey Motion tool. The table below shows all of the valid attributes for an &lt;animation&gt; resource: Attribute Definition Valid Values Default Value Notes 
 id The handle for the layout, which is used to reference the layout in the Rez module Any value that starts with a letter NA Required 
 filename The relative path to the Monkey Motion Manifest file A valid, resolvable path to a Monkey Motion Manifest file NA Required 
 personality Personality class for the element A defined personality class NA Optional 
 An example Animation XML resource: &lt;resources&gt; &lt;animation id="swirl" filename="swirl.mmm" /&gt; &lt;/resources&gt; To load this animation resource in code, create a WatchUi.AnimationLayer then add it to a WatchUi.View : class MyAnimationView extends WatchUi.View { var mySwirl; function initialize( dc ) { var dev = System.getDeviceSettings(); var x = ( dev.screenWidth - mySwirl.getWidth() ) / 2; var y = ( dev.screenHeight - mySwirl.getHeight() ) / 2; // create a new AnimationLayer with the resource then add it to the view // as a WatchUi.Layer mySwirl = new WatchUi.AnimationLayer(Rez.Drawables.swirl, {:locX=&gt;x, :locY=&gt;y}); view.addLayer( mySwirl ); } function onShow() { mySwirl.play(); View.onShow(); } function onUpdate(dc) { // override 'onUpdate' to clear the screen dc.clear(); } } Read more about Animations in the Monkey Motion reference , API documentation , AnimationLayer documentation , the Animation Considerations , and the AnimationWatchFace sample. JSON Data
 JSON data resources can store relatively large amounts of data in your app without having to keep it in memory at all times. This can be useful for storing something like a table of information that must be referenced at runtime, but will not be modified. These resources are declared with the jsonData tag in a resource file, are read by the resource compiler, and loaded on demand at runtime. The jsonData tag supports the following attributes: Attribute Definition Valid Values 
 id The identifier of the JSON resource Any string starting with a letter 
 filename The name of a file containing JSON data A valid, resolvable path to a data file 
 JSON data resources may be provided as either a jsonData value or as a file referenced by the filename attribute, depending on whether it’s easier to manage the data inside a resource file or in a separate JSON file. If using a file, it may only contain JSON data. Here are a few examples: &lt;resources&gt; &lt;jsonData id="jsonDictionary"&gt;{"key":"value", "3":"three", "three":3}&lt;/jsonData&gt; &lt;jsonData id="jsonArray"&gt;[1,2,3,4,5,6]&lt;/jsonData&gt; &lt;jsonData id="jsonMix"&gt;[1,{"1":"one"},["a","b","c"]]&lt;/jsonData&gt; &lt;jsonData id="jsonPrimitive"&gt;5&lt;/jsonData&gt; &lt;jsonData id="jsonFile" filename="data.json"/&gt; &lt;/resources&gt; The JSON data is loaded with the Application.loadResource() method by passing in the jsonData ID. For example, to load the jsonArray data from the example above, the following code would be used: var array = Application.loadResource(Rez.JsonData.jsonArray); For more see the JsonDataResources sample app distributed with the SDK. WatchUi wasn’t accessible by background services so we moved it. &nbsp;↩ 
 We stan a sub-screen icon. QUEEN! &nbsp;↩ 
 Their own language and their own video file format? Who do these people think they are? &nbsp;↩


# [Monkey Style](https://developer.garmin.com/connect-iq/core-topics/monkey-style/)nMenu Core Topics Monkey Style
 Monkey style is a domain-specific property language for managing style elements. It borrows heavily from CSS but has been tailored for Monkey C. Monkey style allows developers to create style property constants that can adapt between Garmin products. Personality Classes
 Monkey style allow you to create personality classes of constants. These classes can be defined using the following syntax: personality_class { property: "constant"; } Personality classes and properties have to be named with Monkey C legal names and can have the following value types: Type Example 
 Number 500 
 Percent 80% 
 String “What’s the deal with style sheets?” 
 Boolean true 
 Color #555555 
 Symbol :myBitmap 
 Resource @Rez.Strings.promptTitle 
 API Constant Graphics.TEXT_JUSTIFY_CENTER 
 Array [ Graphics.FONT_SMALL , Graphics.FONT_TINY ] 
 Resource Compiler
 Personality classes can be referenced by resource compiler elements using the personality attribute. The personality attribute can reference multiple space-separated personality classes. For example, you can have a personality class with the following definition: layout1__time { x: "center"; y: 10%; font: Graphics.FONT_LARGE; justification: Graphics.TEXT_JUSTIFY_CENTER; color: Graphics.COLOR_BLUE; } This can then be referenced in your layout: &lt;layout id="WatchFace"&gt; &lt;drawable class="Background" /&gt; &lt;label id="TimeLabel" personality="layout1__time" /&gt; &lt;/layout&gt; Using Personality Classes in Source
 Any personality class you define is addressable from the Rez.Styles namespace. The class is defined as a module of constant values that you can address via its name. dc.setFont(Rez.Styles.layout1__time.font); When referenced this way, the compiler can replace the constant references at compile time and eliminate the personality classes from your runtime. Configuring Personalities
 You can configure the series of monkey style sheets in the jungle. This allows you to have specific style sheets for each product while keeping the content universal across products. You can configure the personality with the personality selector: fenix7system6preview.personality=$(fenix7system6preview.personality);resources-fenix2022


# [Getting the Users Attention](https://developer.garmin.com/connect-iq/core-topics/getting-the-users-attention/)nMenu Core Topics Getting the User’s Attention
 Your app may need to request the user’s attention at certain times. Connect IQ offers ways to do this via the Toybox.Attention module. The Attention module provides access to the vibration motor, tone generator, screen backlight and flashlight. API Description API Level 
 Attention.backlight() Controls the display backlight 1.0.0 
 Attention.setFlashlightMode() Controls the display backlight 1.0.0 
 Attention.playTone() Plays a tone using the tone generator 1.0.0 
 Attention.vibrate() Uses the vibration motor 1.0.0 
 Backlight
 The backlight behavior for Garmin devices depends on the display technology. Reflective displays like memory-in-pixel (MIP) typically keep the backlight off to conserve power. The user has options to have the backlight enable for different actions like button touches and gestures. These will be handled automatically by the system based on the user settings. Emissive displays like AMOLED are not backlit, but instead typically draw power to light every pixel. The brightness of the display can vary from a low brightness of an “always on” mode to full brightness when the user has gestured. The user can choose their brightness settings for the device, and the system will obey them automatically. The Attention.backlight() API allows the developer to enable the screen backlight. On API 3.2.0 and above, the backlight brightness can be provided as a value between 0.0 and 1.0, and below API 3.2 the brightness can be set to true or false . Note that keeping an AMOLED display on for extended periods at full brightness can damage the display. If the system detects the developer is attempting to do this, an Attention.BacklightOnTooLong exception will be thrown. The backlight, especially on AMOLED devices, should not be used as a flashlight. In these cases, you can use the flashlight API. Flashlight
 The fēnix® 7X was the first device to have an on-device flashlight. The on-device flashlight can support different modes including: Off, on or blink patterns
 Different brightness levels
 Different colors
 
 The Attention.setFlashlightMode() API allows the developer to control the device flashlight: function setFlashlightMode(mode as FlashlightMode, options as { :color as FlashlightColor, :brightness as Number or FlashlightBrightness, // 0 to 100 or special value :strobeMode as FlashlightStrobeMode, :strobeSpeed as FlashlightStrobeSpeed, }?) as FlashlightResult The mode is an enum of the following possibilities: Value Description API Level 
 FLASHLIGHT_MODE_OFF Turns the flashlight off 4.2.0 
 FLASHLIGHT_MODE_ON Turns the flashlight on 4.2.0 
 FLASHLIGHT_MODE_STROBE Sets the flashlight to strobe. Use the :strobeMode and :strobeSpeed options to configure the strobe. 4.2.0 
 The :color option accepts FLASHLIGHT_COLOR_WHITE , FLASHLIGHT_COLOR_GREEN , or FLASHLIGHT_COLOR_RED . Not every device supports every color. Use Attention.hasFlashlightColor() to check if a color is supported. The :brightness option accepts the following values: Value Description API Level 
 0 to 100 Sets the brightness from 0 to 100 percent 4.2.0 
 FLASHLIGHT_BRIGHTNESS_LOW Sets the brightness to the device low setting 4.2.0 
 FLASHLIGHT_BRIGHTNESS_MEDIUM Sets the brightness to the device medium setting 4.2.0 
 FLASHLIGHT_BRIGHTNESS_HIGH Sets the brightness to the device high setting 4.2.0 
 The :strobeMode can be set to the following: [1] Value Description API Level 
 FLASHLIGHT_STROBE_MODE_BLINK Sets the strobe to a -- -- -- -- pattern 4.2.0 
 FLASHLIGHT_STROBE_MODE_PULSE Sets the strobe to a =-_ =-_ =-_ =-_ pattern [2] 4.2.0 
 FLASHLIGHT_STROBE_MODE_BLITZ Sets the strobe to a ... ... ... pattern 4.2.0 
 The :strobeSpeed can be set to the following: [1] Value Description API Level 
 FLASHLIGHT_STROBE_SPEED_SLOW Uses a slow strobe mode 4.2.0 
 FLASHLIGHT_STROBE_SPEED_MEDIUM Uses a medium strobe mode 4.2.0 
 FLASHLIGHT_STROBE_SPEED_FAST Uses a fast strobe mode 4.2.0 
 The setFlashlightMode() API returns the following based on the input: Value Description API Level 
 FLASHLIGHT_RESULT_SUCCESS Flashlight mode was set successfully 4.2.0 
 FLASHLIGHT_RESULT_INVALID_COLOR Flashlight mode could not be set because an invalid color was specified 4.2.0 
 FLASHLIGHT_RESULT_INVALID_BRIGHTNESS Flashlight mode could not be set because the brightness is not supported 4.2.0 
 FLASHLIGHT_RESULT_MODE Flashlight mode could not be set because the mode is not supported 4.2.0 
 FLASHLIGHT_RESULT_SPEED Flashlight mode could not be set because the strobe speed is not supported 4.2.0 
 FLASHLIGHT_RESULT_FAILURE Flashlight mode could not be set 4.2.0 
 Tones
 Garmin devices often use audible tones for different events. The Attention.playTone() API provides access to the tone generator: function playTone(options as Tone or { :toneProfile as Array&lt;ToneProfile&gt;, :repeatCount as Number }) as Void To play a system tone, you can pass one of the Attention.Tone enum values. If you want to play a custom tone, you can pass an array of Attention.ToneProfile objects to the :toneProfile option. The ToneProfile allows you to set a frequency and duration for each note. Vibration
 The vibration motor can be used to inform the user that an event that needs their attention is occurring. You can engage the vibration motor with the Attention.vibrate() API: function vibrate(vibeProfiles as Array&lt;VibeProfile&gt;) as Void You pass the vibrate() API a set of Attention.ToneProfile objects. Each ToneProfile contains a duty cycle and a duration. The device will go through each ToneProfile in order, adjusting the duty cycle for the specified durations. FLASHLIGHT_STROBE_MODE_FUNKADELIC may come in a future update. &nbsp;↩ 
 Could also be defined as ☀🔆🌥 ☀🔆🌥 ☀🔆🌥 . &nbsp;↩


# [HTTPS](https://developer.garmin.com/connect-iq/core-topics/https/)nMenu Core Topics JSON REST Requests
 Widgets and apps can communicate with a mobile phone via Bluetooth Low Energy (BLE). The mobile phone may be sharing data with the device, or it may act as a bridge between the app and the Internet. This allows the mobile phone to become part of the wearable web. There are also high-level interfaces for making JSON and image requests. This allows developers the option of developing a wearable web app without having to write their own companion phone app. API Purpose API Level 
 Communications.makeWebRequest() Make an asynchronous JSON REST request to a web service 1.3.0 
 Communications.makeImageRequest() Download an image from the web 1.2.0 
 Communications.openWebPage() Commands Connect Mobile to ask the user to view a web link 1.3.0 
 JSON REST Requests via Mobile Proxy
 Monkey C exposes a high level APIs to allow calls to basic web services through Garmin Connect Mobile via the Communications.makeWebRequest() and Communications.makeImageRequest() APIs. These APIs expose JSON requests and image requests as very straightforward APIs for making REST API calls. The JSON calls are converted to serialized Monkey C data and sent across the BLE pipe. You must have set the Communications permission to use this API. makeWebRequest() provides a high level API for making a JSON REST request to an endpoint. The call is asynchronous and requires a callback to receive the data once the operation completes. // It is common for developers to wrap a makeWebRequest() call in a function // as displayed below. The function defines the variables for each of the // necessary arguments in a Communications.makeWebRequest() call, then passes // these variables as the arguments. This allows for a clean layout of your web // request and expandability. import Toybox.System; import Toybox.Communications; import Toybox.Lang; class JsonTransaction { // set up the response callback function function onReceive(responseCode as Number, data as Dictionary?) as Void { if (responseCode == 200) { System.println("Request Successful"); // print success } else { System.println("Response: " + responseCode); // print response code }; }; function makeRequest() as Void { var url = "https://www.garmin.com"; // set the url var params = { // set the parameters "definedParams" =&gt; "123456789abcdefg" }; var options = { // set the options :method =&gt; Communications.HTTP_REQUEST_METHOD_GET, // set HTTP method :headers =&gt; { // set headers "Content-Type" =&gt; Communications.REQUEST_CONTENT_TYPE_URL_ENCODED}, // set response type :responseType =&gt; Communications.HTTP_RESPONSE_CONTENT_TYPE_URL_ENCODED }; var responseCallback = method(:onReceive); // set responseCallback to // onReceive() method // Make the Communications.makeWebRequest() call Communications.makeWebRequest(url, params, options, method(:onReceive)); } } makeImageRequest() offers a similar API for making an image request. The images can be processed by the system, including applying a palette and dithering. import Toybox.System; import Toybox.Communications; import Toybox.WatchUi; class ImageTransaction { var image as BitmapResource?; var responseCode as Number?; // Set up the responseCallback function to return an image or null function responseCallback(responseCode as Number, data as BitmapResource?) { responseCode = responseCode; if (responseCode == 200) { image = data; } else { image = null; } } // wrap the request in a function function makeRequest() as Void { // set the image url var url = "http://www.garmin.com/image-path"; // set the parameters var parameters = null; // set the options var options = { // set the palette :palette =&gt; [ Gfx.COLOR_ORANGE, Gfx.COLOR_DK_BLUE, Gfx.COLOR_BLUE, Gfx.COLOR_BLACK ], // set the max width :maxWidth =&gt; 100, // set the max height :maxHeight =&gt; 100, // set the dithering :dithering =&gt; Communications.IMAGE_DITHERING_NONE }; // Make the image request Communications.makeImageRequest(url, parameters, options, method(:responseCallback)); } } For more see the WebRequest sample app distributed with the SDK. Directing Users to Web Content
 The openWebPage call can be used to direct the user to a specific web page on the paired mobile device. When called, the specified web page should be fetched and displayed in the phones default browser. There is no callback for this function and the watch app has no method for checking if the call was completed on the phone successfully.


# [Authenticated Web Services](https://developer.garmin.com/connect-iq/core-topics/authenticated-web-services/)nMenu Core Topics Authenticated Web Services
 There are countless web services available to developers that use either OAuth to provide access control. Connect IQ has OAuth APIs in the Communications module that allow widgets and device apps to make authenticated calls. OAuth 101
 OAuth provides a standard way for developers to authenticate to gain access to web APIs. Before an app can access the web API, the developer must register the app with the service. During registration you must provide a redirect URL that will be used to retrieve the credentials. Once registered the app will provide a client id and secret , which are necessary for the login process. To access the web service, the app must authenticate the user. To do this, the app redirects the user’s web browser to the web service authentication page, providing the secret, the client id, and the redirect URL. After the service has authenticated the user, it redirects their browser back to the client providing an access token. The access token can then be used in subsequent calls to the web service. OAuth and Wearables
 The OAuth standard is based on the world of web browsers and mobile applications, but in general people don’t want to enter their username and password on their watch. Connect IQ has added some new APIs to allow you to write OAuth enabled apps: Operation Function API Level 
 Request credentials from an OAuth 2.0 web endpoint Communications.makeOAuthRequest() 1.3.0 
 Request credentials from an OAuth 2.0 web endpoint Authentication.makeOAuthRequest() 3.3.0 
 Register a callback to receive OAuth credentials upon user completion Communications.registerForOAuthMessages() 1.3.0 
 Register a callback to receive OAuth credentials upon user completion Authentication.registerForOAuthMessages() 3.3.0 
 The Communications.makeOAuthRequest() and Authentication.makeOAuthRequest() calls are intended for implementing credential entry step of the OAuth 1.0 &amp; 2.0 standard. Be sure to use the following redirects when using the makeOAuthRequest call: API Redirect 
 Communications.makeOAuthRequest() http://localhost 
 Authentication.makeOAuthRequest() connectiq://oauth 
 When called, the user will receive a phone notification that your app wants to log into a web service. Clicking on this notification will take the user to a web view within Garmin Connect mobile app ( Communications.makeOAuthRequest() ) or the Connect IQ Store mobile app ( Authentication.makeOAuthRequest() ), where they can enter their log in information. During this time, the Connect IQ app should display a page directing the user to open the respective application. Once the user has completed credential entry, Connect will send back the tokens specified in the resultKeys option, and direct them back to the wearable. Your app should call Communications.registerForOAuthMessages() or Authentication.registerForOAuthMessages() to receive the result of the login process. Logging in can take a long time, and a widget may time out before the user completes the login step. If your app closes before the login process completes, the result will be cached on the device until the next time your app calls registerForOAuthMessages() , at which point the result will be passed to your callback immediately. Once you have the access token, you can use it as an argument to Communications.makeWebRequest() .


# [Communicating with Mobile Apps](https://developer.garmin.com/connect-iq/core-topics/communicating-with-mobile-apps/)nMenu Core Topics Communicating with Mobile Apps
 There are a few complications with device-to-phone communication. For example, the watch app may be killed during the time communication happens, or a phone app may try to send information while the app is not active. In order to simplify these cases for the developer, Monkey C does not expose a low-level interface, but instead exposes a very high-level approach: the API exposes a mailbox metaphor instead of using a socket metaphor. Messages are constructed as a parcel of information and sent back and forth between devices. Each app will have a mailbox where messages are received, and an event that fires when new messages arrive. Mobile SDK Downloads
 The Connect IQ Mobile SDKs are released separately from the Connect IQ Developer SDK and is available for iOS and Android. There are several editions of the Mobile SDK available: Android BLE
 iOS BLE
 Android ADB
 
 The BLE edition supports development of communication-enabled applications on an iOS or Android target device while the Android Debug Bridge (ADB) edition is used for testing with the Connect IQ Simulator. More information on how to download the correct version for your mobile platform may be found on the Garmin Developer site and the Mobile SDK for Android and Mobile SDK for iOS sections. BLE Simulation Over Android Debug Bridge
 When using the Connect IQ Simulator, it is possible to communicate with a companion app running on an Android device using ADB . This will simulate actual BLE speeds to better approximate performance of your application. The ADB edition of the Android Mobile SDK and companion app is required to use ADB for testing. Here’s how to enable the companion to communicate over ADB : Connect the phone to the PC running the simulator via USB
 Have USB debugging enabled on the Android handset
 Obtain an instance of ConnectIQ using getInstance( IQCommProtocol.ADB_SIMULATOR ) 
 Optionally call setAdbPort( int port ) to set a specific port to use for communication (the default port is 7381)
 Call initialize() 
 To allow the simulator to communicate over ADB , forward the TCP port to the Android device in a terminal or console: adb forward tcp:7381 tcp:7381 Note that this command will need to be reissued for each connected Android device, or if a device is disconnected and re-connected. Once your app is started on the phone, connect it to the simulator by clicking the Connection menu and selecting Start (CTRL-F1). The Connect IQ apps in the simulator will now be able to communicate with your device via the Communications APIs over ADB .


# [Downloading Content](https://developer.garmin.com/connect-iq/core-topics/downloading-content/)nMenu Core Topics Downloading Content
 Since API level 2.2.0 The Toybox.PersistedContent module allows access to the saved Tracks, Courses, Waypoints, Workouts, and Routes that the user has on their device. These content types contain a name and a unique identifier, which can be used by System.exitTo() as an Intent to launch into a native app and present the content to the user in some way. See the Intents section for more details. Type Object API Level 
 Track, Route, Course PersistedContent.Track , PersistedContent.Route , PersistedContent.Course [1] 2.2.0 
 Waypoint PersistedContent.Waypoint 2.2.0 
 Workout PersistedContent.Workout 2.2.0 
 Calling exitTo() with a Toybox.PersistedContent object prompts the user to choose which native app to launch. For example, if an app calls exitTo() with a Waypoint object, the dialog will ask whether to launch the waypoint with one of either the Run or Bike native apps. When retrieving the list of stored content on the device, a PersistedContent.Iterator will be returned. The Iterator.next() function must be called to get the first entry, and null is returned when there are no more entries: import Toybox.PersistedContent; import Toybox.System; function example() as Void {} // Get the first waypoint from the device var waypoints = PersistedContent.getWaypoints(); var waypoint = waypoints.next(); if(waypoint != null) { // Launch the waypoint (User will be asked // what activity to launch in) System.exitTo(waypoint.toIntent()); } } There are three possible cases once the content is sent to the device: Data import is successful - A PersistedContent.Iterator will be returned, which contains the elements that were downloaded.
 The system does not have enough space - The STORAGE_FULL response will be returned to the responseCallback .
 The system does not support the file type (i.e. a running workout is sent to a cycling device) - The responseCallback will return an empty iterator or null value.
 Access to PersistedContent requires the ‘Persisted Content’ permission. Persisted Content in the Simulator
 Because native apps are not simulated in Connect IQ simulator, an Intent Launched feature has been added that is useful for testing with Toybox.PersistedContent . This feature displays three critical pieces of information about the Toybox.PersistedContent object supplied via Intent in the simulator window: The object type
 The unique serializable ID of the object
 The name of the object
 For example, the sample code above may display a picture of an activity with “Intent Launched”, a type, an ID number and its name displayed. WiFi Bulk Downloads
 Since API level 3.1.0 In some cases, the Bluetooth Low Energy (BLE) link to Garmin Connect Mobile is too slow for downloading some content. For these situations, the WiFi Bulk Downloads feature can prove useful. The Communications module provides methods to initiate a transition to sync mode, and communicate sync status information to the system for display. The Application.AppBase class provides an entry point for the system to get a delegate used to communicate with the app while in sync mode. Function or Class Purpose 
 Communications.startSync() Exit the Application and launch it in sync mode. 
 AppBase.getSyncDelegate() Get a SyncDelegate object that communicates sync status to the system 
 Communications.SyncDelegate A delegate object that the user implements to respond to sync request 
 Communications.notifySyncProgress() Send a system notification to the system to indicate overall sync progress. 
 Communications.notifySyncComplete() Send a system notification to the system to indicate that the sync completed. 
 To use the bulk download functionality, implement getSyncDelegate() to return an instance of a class derived from SyncDelegate . When the application calls Communications.startSync() , the system will terminate the running application, re-launch it in sync mode, and make a call to getSyncDelegate() to retrieve the application’s SyncDelegate . Once the application has retrieved the application’s SyncDelegate , it will verify that a sync is necessary by calling SyncDelegate.isSyncNeeded() . If this method returns true , the system will proceed to call SyncDelegate.onStartSync() . At this point, the delegate may initiate a request to download content by making a call to Communications.makeWebRequest() or Communications.makeImageRequest() . When the response callback for the request is invoked, the delegate should notify the system of the progress made by calling notifySyncProgress() . If additional content remains to be downloaded, another content request may be issued. This cycle should repeat until all content has been downloaded or an error has occurred, at which time a call to notifySyncComplete() should be made to notify the system that the app can leave sync mode. If the user decides to cancel the bulk download operation, the system will call SyncDelegate.onStopSync() to notify the application. The app must acknowledge the sync cancellation by calling notifySyncComplete() . The system will display the given error message, if appropriate, and will proceed to exit sync mode. For more see the BulkDownload sample app distributed with the SDK. I can’t tell you what the differences are. Sometimes our job is to just abstract the thing and not ask questions. &nbsp;↩


# [Mobile SDK for Android](https://developer.garmin.com/connect-iq/core-topics/mobile-sdk-for-android/)nMenu Core Topics Mobile SDK for Android
 The Mobile SDK allows you to create companion applications that run on a user’s phone and interact with your application on their wearable device. This allows for a more feature rich user experience where doing certain tasks on the wearable device might be tedious or resource intensive. Adding the Mobile SDK to a project
 The Mobile SDK is publicly available on Maven Central at ConnectIQ Companion App SDK . To include the AAR to your project add the following line to your build.gradle file implementation "com.garmin.connectiq:ciq-companion-app-sdk:&lt;latest_version&gt;@aar" Additional Requirements
 In order for your companion application to communicate with a Connect IQ device the user must also install Garmin Connect Mobile onto their phone. All communication for companion applications running on Android goes through a Garmin Connect Mobile service to reach the device. When initializing the SDK with a wireless connection type this requirement is checked and initialization will fail if Garmin Connect Mobile is not installed. If true is passed to the auto UI parameter of initialize, a message is displayed to the user that they need to either install or upgrade Garmin Connect Mobile and provides them a way to go directly to the application in the Google Play Store. See Displaying a UI message automatically when initialization fails for more information. Interacting with the SDK
 All interactions between the companion application and the Connect IQ application are done via the ConnectIQ class. To use this class you must first obtain an instance of the class and then initialize it. ConnectIQ connectIQ = ConnectIQ.getInstance(ConnectIQ.IQConnectType.&lt;protocol&gt;); ConnectIQ.IQConnectType provides two options: WIRELESS - For communicating with the Connect IQ simulator or real device via BLE. This is the default.
 TETHERED - For communicating with the Connect IQ simulator over the Android Debug Bridge.
 
 Initializing the SDK
 Initializing the SDK is an asynchronous process and requires a ConnectIQListener to handle returned states of the SDK. You must wait for the onSdkReady() call to be made before calling any additional API methods. Doing so beforehand will result in an InvalidStateException . connectIQ.initialize(context, true, new ConnectIQListener() { // Called when the SDK has been successfully initialized @Override public void onSdkReady() { // Do any post initialization setup. } // Called when the SDK has been shut down @Override public void onSdkShutDown() { // Take care of any post shutdown requirements } // Called when initialization fails. @Override public void onInitializationError(IQSdkErrorStatus status) { // A failure has occurred during initialization. Inspect // the IQSdkErrorStatus value for more information regarding // the failure. } }); Displaying a UI message automatically when initialization fails
 If initialization fails due to Garmin Connect Mobile not being installed on the user’s phone or if it needs to be upgraded, a message can be displayed prompting the user to take action. You can tell the SDK to display this message automatically by passing true as the second parameter to the initialize() method. By default, the UI will display a dialog message to the user asking them to take action. The strings that make up the dialogs are by default English only strings. These strings are fully customizable by simply adding some predefined strings to your projects strings.xml file. Customizable Strings
 install_needed_title — Dialog title for when Garmin Connect Mobile needs to be installed.
 install_needed_message — Dialog message for when Garmin Connect Mobile needs to be installed.
 install_needed_yes — Button text for user to confirm they want to visit the Google Play Store to install Garmin Connect Mobile.
 install_needed_cancel — Button text for user to cancel the dialog and not install Garmin Connect Mobile.
 upgrade_needed_title — Dialog title for when Garmin Connect Mobile needs to be upgraded to a version that supports the SDK.
 upgrade_needed_message — Dialog message for when Garmin Connect Mobile needs to be upgraded to a version that supports the SDK.
 upgrade_needed_yes — Button text for user to confirm they want to visit the Google Play Store to upgrade Garmin Connect Mobile.
 upgrade_needed_cancel — Button text for a user to cancel the dialog and not upgrade Garmin Connect Mobile.
 
 Working with Devices
 Finding Connect IQ-compatible Devices
 Before you can interact with a Connect IQ device, you must obtain a reference to an IQDevice object instance representing it. This is done by one of two methods. getKnownDevices() will return a list of any Connect IQ device that has been paired within Garmin Connect Mobile. These devices may or may not be connected at the time the API is called. List&lt;IQDevice&gt; paired = connectIQ.getKnownDevices(); if (paired != null &amp;&amp; paired.size() &gt; 0) { // get the status of the devices for (IQDevice device : paired) { IQDeviceStatus status = connectIQ.getStatus(device); if (status == IQDeviceStatus.CONNECTED) { // Work with the device } } } getConnectedDevices() will return a list of currently connected devices. Because these devices could become disconnected at any time, it is good practice to register to receive a notification when the device connects or disconnects. See the next section for more information. List&lt;IQDevice&gt; devices = connectIQ.getConnectedDevices(); if (devices != null &amp;&amp; devices.size() &gt; 0) { // Work with devices. } Listening for Device Events
 You can request to be notified when the status of a device changes by calling registerForDeviceEvents(IQDevice, IQDeviceEventListener) . Once registered any device status change will call the IQDeviceEventListener.onDeviceStatusChanged() with the new status. When you no longer need to receive updates for a device, you should call unregisterForDeviceEvents(IQDevice) to release any associated resources. // Register to receive status updates connectIQ.registerForDeviceEvents(device, new IQDeviceEventListener() { @Override public void onDeviceStatusChanged(IQDevice device, IQDeviceStatus newStatus) { // Handle new status } }); // Get the current status IQDeviceStatus current = device.getStatus(); // Unregister when we no longer need status updates connectIQ.unregisterForDeviceEvents(device); Possible Device statuses
 CONNECTED — The device is connected and can be communicated with.
 NOT_CONNECTED — The device is paired with Garmin Connect Mobile but is not currently connected and cannot be communicated with.
 NOT_PAIRED — The device is not paired with Garmin Connect Mobile and cannot be communicated with.
 
 Working with Apps
 Obtaining an Instance of IQApp
 Apps are represented in the Mobile SDK as instances of the IQApp class. While you can create an IQApp instance on your own, it is recommended to obtain a fully populated IQApp instance via the getApplicationInfo() method. You can determine if your Connect IQ application is installed on the user’s device by passing the Applications UUID, the IQDevice , and an IQApplicationInfoListener into a getApplicationInfo() call. IQApplicationInfoListener.onApplicationInfoReceived( IQApp ) will be called if the application is installed on the watch, and IQApplicationInfoListener.onApplicationNotInstalled( String ) if the app does not exist on the watch. onApplicationInfoReceived will be called with an IQApp object that can be inspected via the getStatus() method to determine the status of your application on the device. If the status is INSTALLED , the version number will also be populated so you can determine if the user has the latest version of your application. connectIQ.getApplicationInfo(MY_APPLICATION_ID, device, new IQApplicationInfoListener() { @Override public void onApplicationInfoReceived( IQApp app ) { if (app != null) { if (app.getStatus() == INSTALLED) { if (app.getVersion() &lt; MY_CURRENT_VERSION) { // Prompt the user to upgrade } } } } @Override public void onAPplicationNotInstalled( String applicationId ) { // Prompt user with information AlertDialog.Builder dialog = new AlertDialog.Builder( this ); dialog.setTitle( "Missing Application" ); dialog.setMessage( "Corresponding IQ application not installed" ); dialog.setPositiveButton( android.R.string.ok, null ); dialog.create().show(); } }); Possible Application Statuses
 INSTALLED — The application is installed on the device and the version information has been populated.
 NOT_INSTALLED — The application is not currently installed on the device but is supported.
 NOT_SUPPORTED — The application is not installed on the device and is not supported by the device.
 
 Opening an App on the Device
 You may wish to prompt the user to open a Connect IQ application on their device. To do this you can use the openApplication API. A response from the device will be returned to your IQOpenApplicationListener . connectIQ.openApplication(device, app, new IQOpenApplicationListener() { @Override public void onOpenApplicationResponse(IQDevice device, IQApp app, IQOpenApplicationStatus status) { // Handle the response here } }); Possible Open Application Statuses
 PROMPT_SHOWN_ON_DEVICE
 PROMPT_NOT_SHOWN_ON_DEVICE
 APP_IS_NOT_INSTALLED
 APP_IS_ALREADY_RUNNING
 UNKNOWN_FAILURE
 
 Opening the Connect IQ store
 If the user does not have your applications installed (status of NOT_INSTALLED ), or needs to upgrade to the latest version, you can open the Connect IQ store directly to your application. Simply call openStore() passing in a String containing the public UUID associated with your application in the store. Note, this will not work if you are using the TETHERED connection option. connectIQ.openStore( MY_STORE_ID ); Sending Messages
 You can send messages to your Connect IQ application on a connected device using any of the Java equivalent Monkey C data types (see Supported Data Types table below). Calling sendMessage() will deliver the message to your applications mailbox. List&lt;Object&gt; message = new ArrayList&lt;String&gt;() {"hello pi", 3.14159}; connectIQ.sendMessage(device, app, message, new IQSendMessageListener() { @Override public void onMessageStatus( IQDevice device, IQApp app, IQMessageStatus status ) { Toast.makeText( this, status.name(), Toast.LENGTH_LONG ).show(); if (status != IQMessageStatus.SUCCESS) { // Evalute status for cause of the failure } } }); Receiving Messages
 In order to receive data messages from a Connect IQ application, you must first register to receive application events. Once registered via registerForAppEvents() , when a new message arrives from the Connect IQ application, it will be delivered to the onMessageReceived() method of the listener passed when registering. When you no longer wish to receive incoming messages, you should call unregisterForAppEvents() to release any associated resources. A companion app may register to receive messages from multiple apps across many devices. However, multiple companion apps cannot be registered to receive messages from the same ConnectIQ application. The SDK will override any previous registrations with each call to registerForAppEvents() . // Register to receive messages from our application connectIQ.registerForAppEvents(device, app, new IQApplicationEventListener() { @Override public void onMessageReceived(IQDevice device, IQApp app, List&lt;Object&gt; messageData, IQMessageStatus status) { // First inspect the status to make sure this // was a SUCCESS. If not then the status will indicate why there // was an issue receiving the message from the Connect IQ application. if (status == IQMessageStatus.SUCCESS) { // Handle the message. } } }); // unregister when we no longer care about messages coming from our app. connectIQ.unregisterForAppEvents(device, app); Supported Data Types
 Java Data Type Monkey C Type Notes 
 int, Integer Integer 
 long, Long Integer, Long If the value of the long is small enough to be represented as an integer, it will be converted to save space. 
 float, Float Float 
 double, Double Float, Double If the value of the double is within 5 matching significant fractional digits of the nearest float, it will be converted to a float to save space. 
 boolean, Boolean Boolean 
 char Char 
 String String 
 List&lt;?&gt; Array[] List must contain only supported data types. If the list contains unsupported data types, an exception will be thrown. 
 Map&lt;?,?&gt; Dictionary Map keys and values must be supported data types. If the map contains unsupported data types, an exception will be thrown.


# [Mobile SDK for iOS](https://developer.garmin.com/connect-iq/core-topics/mobile-sdk-for-ios/)nMenu Core Topics Mobile SDK for iOS
 The Connect IQ Mobile SDK allows companion iOS applications to be created that interact with Monkey C applications running on Garmin wearable devices. This allows feature-rich user experiences to be built by retrieving remote data or offloading resource-intensive tasks from the wearable device to the iOS device. This document will guide you through adding the Mobile SDK to an iOS project, as well as introducing the SDK’s API and how to communicate with your Monkey C apps. Configuring a project to use the Mobile SDK
 Add the framework to the project
 The Mobile SDK for iOS is distributed as an iOS framework package and can be found at Garmin GitHub repo for Connect IQ Mobile SDK . To enable the framework, add an entry to the Project &gt; Package Dependencies panel. To do this, click the + at the bottom of the Packages list. You will be presented with a dialog box to choose which package to add as dependency. In the search box enter “https://github.com/garmin/connectiq-companion-app-sdk-ios” Embed the ConnectIQ framework as a binary
 To allow a project to build with the Mobile SDK, embed the framework as a binary for each of the project’s targets by checking the box against each of the targets and click Add Package . Add required linker flags
 The Mobile SDK for iOS utilizes category methods internally. When importing a library that uses category methods, an additional flag must be specified to allow the library to be linked correctly. To do this, add the –ObjC flag to the Target &gt; Build Settings &gt; Linking &gt; Other Linker Flags setting. Register a URL scheme
 Unlike the Mobile SDK for Android, apps created with the Mobile SDK for iOS are standalone apps and do not directly rely on Garmin Connect Mobile (GCM) to communicate with a wearable device. They do, however, require GCM to initially discover Connect IQ-compatible devices that are available for communication, or to install Monkey C applications on the wearable device. The companion app and GCM exchange information by launching each other via the iOS URL scheme system. To facilitate this, a URL scheme that GCM can send data to must be registered by the app. To do this, add an entry to the Target &gt; Info &gt; URL Types panel. A string that is not likely to collide with any other apps on the iOS device should be chosen. See the Apple documentation for more information on custom URL schemes . If you are compiling against the iOS 9 SDK or above you will need to add an entry for gcm-ciq to LSApplicationQueriesSchemes in your app’s Info.plist. This is needed to ensure that the SDK can verify if GCM is installed. If this key is not present in your Info.plist it will need to be added. If your project doesn’t already set CFBundleDisplayName in your app’s Info.plist, you will need to add a definition. You can set this to ${PRODUCT_NAME} if you are unsure what value to use. Set Bluetooth usage description
 Starting in iOS 10 it is required to set strings explaining the usage of BLE peripheral access. The NSBluetoothPeripheralUsageDescription key must be set in Info.plist to explain your app’s usage of BLE to be accepted by iTunes Connect. If this key is not present in your Info.plist it will need to be added. Set background execution mode (optional)
 The iOS system allows apps that communicate with Bluetooth devices to be woken up to execute in the background when a connected device has data to send. This can be useful for companion apps that process requests for their respective Monkey C applications on a wearable device. To enable this behavior, turn on the Uses Bluetooth LE accessories option in the Target &gt; Capabilities &gt; Background Modes panel. Initializing the SDK
 All interaction with the Mobile SDK is done through the ConnectIQ class. This class must be initialized during app startup with the project’s URL scheme and a UI override delegate. Typically this is done within the app delegate’s application:didFinishLaunchingWithOptions: method. [[ConnectIQ sharedInstance] initializeWithUrlScheme:@"exapp-123456" uiOverrideDelegate:self]; The URL scheme should be the same string chosen in Step 4 of Configuring a project to use the Mobile SDK . When invoking a method of the ConnectIQ class that requires GCM to be installed and it is not present on the iOS system, by default an alert dialog will be shown to the user that allows them to go to the Apple App Store page for GCM to install it. By passing an instance of an object that conforms to the IQUIOverrideDelegate protocol here, custom behavior or a specialized UI may be specified in this case. To use the default alert dialog and behavior, pass nil . Implementing a UI override delegate
 If a UI override delegate was specified and an action was performed that requires GCM to be installed, the ConnectIQ class will call the needsToInstallConnectMobile method on that delegate. The app should inform the user that GCM is required for this action and give the user the option to open the Apple App Store page for GCM or to cancel the action that triggered it. If the user chooses to install GCM, the showAppStoreForConnectMobile method may be called. - (void)needsToInstallConnectMobile { // Show alert to user with choice to install GCM if (alert.result == YES) { [[ConnectIQ sharedInstance] showAppStoreForConnectMobile]; } } Note that this example is synchronous, but if UI is shown to the user, the showAppStoreForConnectMobile method should be called as a result of user input instead of directly in the needsToInstallConnectMobile method. Working With Devices
 Finding Connect IQ-compatible devices
 The Mobile SDK for iOS can communicate directly with Connect IQ-compatible devices over Bluetooth. However, it must first know which devices are available. To accomplish this, a companion app must call the showConnectIQDeviceSelection method. [[ConnectIQ sharedInstance] showConnectIQDeviceSelection]; This method launches GCM to the foreground and allows the user to choose which paired Connect IQ-compatible devices to share with the companion app. If GCM is not installed and a UI override delegate was set, its needsToInstallConnectMobile will be called. Note that by launching GCM, this method causes the companion app to go into the background, possibly resulting in the app being suspended. The companion app should expect to be suspended when calling this method. Once the user has selected which of the paired devices to share with the companion app, GCM will launch the companion app (via its registered URL scheme), passing the list of devices as serialized URL query items. The companion app should override its app delegate’s application:openURL:sourceApplication:annotation: method to listen for this. The companion app may then call the parseDeviceSelectionResponseFromURL: method to extract the query items into an NSArray of IQDevice objects that it can use with the Mobile SDK. - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { if ([url.scheme isEqualToString:ReturnURLScheme] &amp;&amp; [sourceApplication isEqualToString:IQGCMBundle]) { NSArray *devices = [[ConnectIQ sharedInstance] parseDeviceSelectionResponseFromURL:url]; if (devices != nil) { [self.devices removeAllObjects]; for (IQDevice *device in devices) { self.devices[device.uuid] = device; } return YES; } } return NO; } Note that in this example, the parsed devices are stored to a dictionary for later use within the app, but are not cached in any kind of persistent storage. To avoid needing to launch GCM excessively to discover devices, companion apps should cache devices to persistent storage. When a list of devices is returned by GCM, companion apps should clear all previously cached references to devices they may have known about. Always use only the latest list of devices that the user has authorized. Listening for device events
 Once the companion app has one or more IQDevice instances from GCM, it may register with the ConnectIQ class to receive notifications when that device’s connection status changes by calling registerForDeviceEvents:delegate: . [[ConnectIQ sharedInstance] registerForDeviceEvents:device delegate:self]; The delegate passed in must be an instance of a class that conforms to the IQDeviceEventDelegate protocol. Once registered, the delegate’s deviceStatusChanged:status: method will be invoked when the device’s connection status changes. The getDeviceStatus: method may also be called to get the current connection status of the device. These methods both return a device’s status as an IQDeviceStatus value. A companion app must register to receive device events before calling methods that operate on devices or apps, such as getDeviceStatus: or sendMessage:toApp:progress:completion: . To stop listening for device events, a companion app may call either the unregisterForDeviceEvents:delegate: or unregisterForAllDeviceEvents: method. // Stop listening to a single device [[ConnectIQ sharedInstance] unregisterForDeviceEvents:device delegate:self]; // ... or unregister all devices for this listener [[ConnectIQ sharedInstance] unregisterForAllDeviceEvents:self]; Working With Apps
 Creating an app instance
 Apps are represented in the Mobile SDK as instances of the IQApp class. An instance of the IQApp class represents a single app on a single device. This means that in order to work with an app that’s installed on two different devices, a companion app will need two instances of the IQApp class with the same app ID, one for each device. To create an app instance, use the IQApp class’s appWithUUID:device: method. NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:@”&lt;YourAppID&gt;”]; IQApp *app = [IQApp appWithUUID:uuid device:device]; Requesting an app’s status
 Once an IQApp instance has been created that links an app ID to an IQDevice instance, a companion app may request the status of the app on that device by calling the getAppStatus:completion: method. [[ConnectIQ sharedInstance] getAppStatus:app completion:^(IQAppStatus *appStatus) { if (appStatus != nil &amp;&amp; appStatus.isInstalled) { NSLog(@”App is installed! Version: %d”, appStatus.version); } }]; This method communicates with the device over Bluetooth, and therefore is asynchronous. The completion block will be invoked when the device responds, or the request times out. If the request is successful, the completion block will be invoked with an instance of the IQAppStatus class. A companion app may inspect this status to discover if the app is installed on the device, and if so, what the version of that app is. A companion app could then potentially show a UI that recommends that the user upgrade the app on the device. If the device is not currently connected or the request times out, the completion block will be invoked with a nil status. Installing, upgrading, or managing an app
 If a companion app determines that an app is out of date or not installed, it may allow the user to install or upgrade that app by launching the Connect IQ store within GCM. To do this, simply call the showConnectIQStoreForApp: method. [[ConnectIQ sharedInstance] showConnectIQStoreForApp:app]; A companion app may also call this method even if the app is installed and up-to-date on the device, to allow the user to manage or uninstall the app from the device. Like the showConnectIQDeviceSelection method, by launching GCM, this method causes the companion app to go into the background, possibly resulting in the app being suspended. The companion app should expect to be suspended when calling this method. Opening an app on the Garmin device
 A companion app can request that a CIQ app be opened on the target device. When doing so a prompt will be displayed to the user on the Garmin device to see if they app should be opened. If the user chooses to open the app then it will be immediately opened. This can be accomplished by calling the openAppRequest: method. [[ConnectIQ sharedInstance] openAppRequest:app completion:^(IQSendMessageResult result) { switch(result) { case IQSendMessageResult_Success: NSLog(@”Popup was displayed”); break; case IQSendMessageResult_Failure_PromptNotDisplayed: NSLog(@”Popup was displayed”); break; case IQSendMessageResult_Failure_AppAlreadyRunning: NSLog(@”Popup was displayed”); break; } }]; Sending messages
 Once a companion app has determined that an app is installed on a connected device, the companion app may send messages over Bluetooth to that app’s mailbox by calling the sendMessage:toApp:progress:completion: method. This method takes an object as a message, an IQApp as the destination, and two blocks – one that is invoked periodically as the data transfer progresses, and one that is invoked once the transfer is finished. NSArray *message = @[@”hello pi”, @(3.14159)]; [[ConnectIQ sharedInstance] sendMessage:message toApp:app progress:^(uint32_t sent, uint32_t total) { float percent = 100 * sent / (float)total; NSLog(@"%02.2f%% - %u/%u", percent, sent, total); } completion:^(IQSendMessageResult result) { NSLog(@"Send message finished with result %@", NSStringFromSendMessageResult(result)); }]; The message object that is passed to this method is first converted by the SDK into a Monkey C-compatible type, and is then sent to the app’s mailbox on the device. Therefore, only Objective-C types that can be directly translated to comparable Monkey C types are valid. Valid message types include NSString , NSNumber , NSArray , NSDictionary , and NSNull . Take advantage of nesting other types inside an NSArray or NSDictionary to form complex messages. Values contained in NSNumber objects will be converted to the most appropriate Monkey C value type on the device. Keep in mind that the wearable devices have limited memory and processing power compared to an iOS device. Messages should be as small as possible. However, sending frequent small messages can incur performance and battery life costs. Therefore, it is more desirable to send occasional large messages than it is to frequently send many tiny messages. Companion apps should aim to balance the costs of memory and performance by sending messages only when necessary and keeping message size to a minimum. Receiving messages
 A companion app may register to receive messages that are sent from an app on a device by calling the registerForAppMessages:delegate: method. This method takes an IQApp to listen for messages from, and an instance of an object that conforms to the IQAppMessageDelegate protocol as the listener. After registering, when a message from that app is successfully received, the receivedMessage:fromApp: method will be called on the listener. To stop listening for app messages, a companion app may call either the unregisterForAppMessages:delegate: or unregisterForAllAppMessages: method. - (void)viewWillAppear:(BOOL)animated { [[ConnectIQ sharedInstance] registerForAppMessages:self.app delegate:self]; } - (void)viewDidDisappear:(BOOL)animated { [[ConnectIQ sharedInstance] unregisterForAllAppMessages:self]; } - (void)receivedMessage:(id)message fromApp:(IQApp *)app { NSLog(@"Received message from app %@: '%@'", app, message); } A companion app may register to receive messages from multiple apps across many devices. However, multiple companion apps should never register to receive messages from the same app . The nature of Bluetooth communication on iOS prevents the Mobile SDK from determining which companion app to deliver the message to. Therefore, undefined behavior will result from multiple companion apps registering to receive messages from the same app.


# [Ant and Ant Plus](https://developer.garmin.com/connect-iq/core-topics/ant-and-ant-plus/)nMenu Core Topics ANT and ANT+
 The Sensor module of Connect IQ gives developers access to the built-in and paired sensors of the device. Connect IQ also provides access to the available ANT channels as well. This allows developers to communicate with sensors not supported by Garmin. Using the FIT recording system those metrics can be recorded to the Activity file and uploaded to Garmin Connect. Learn more about ANT and ANT+ at thisisant.com API Purpose API Level 
 Toybox.Ant Provides access to generic ANT channels. These allow direct communication between your app and an ANT device 1.0.0 
 Toybox.AntPlus Allows access to ANT devices paired with the device. 2.2.0 
 Generic ANT Channels
 Connect IQ provides a low level interface for communication with ANT and ANT+ sensors. With this interface, an ANT channel can be created to send and receive ANT packets. With an ANT USB dongle you can use Connect IQ ANT APIs in the Connect IQ Simulator. Note that Garmin Express will block access to the ANT USB dongle if it is running, so make sure to shut down Garmin Express when using the ANT USB dongle with the Connect IQ simulator. Using ANT stick in Linux
 In order to use ANT stick in Linux the usb device should be accessible to the simulator. A udev rule must be installed in the system for the ANT stick to populate with non-root privileges. Find the vendor and product id for the ANT stick $ lsusb Identify the ANT stick in the list and its vendor and product id. example: Bus 001 Device 009: ID 0fcf:1009 Dynastream Innovations, Inc. ANTUSB-m Stick Create a udev rule for this device $ sudo touch /etc/udev/rules.d/50-connectiq-usbant.rules $ sudo nano /etc/udev/rules.d/50-connectiq-usbant.rules Then add the line below to the file and save the changes: CTRL-x ACTION=="add", SUBSYSTEMS=="usb", ATTRS{idVendor}=="0fcf", ATTRS{idProduct}=="1009", MODE="664", GROUP="plugdev" Restart the udev service and plug the ANT stick $ sudo /etc/init.d/udev restart Add yourself to the ‘plugdev’ group $ sudo usermod -a -G plugdev &lt;userName&gt; Communicating with a Tempe Sensor
 The Environment Profile is supported by sensors like the Garmin tempe™ wireless environment sensor and makes it possible to read the minimum, maximum and current temperature. We can initialize an ANT channel to a tempe sensor with the following: // Constructor function initialize() { // Get the channel chanAssign = new Ant.ChannelAssignment( Ant.CHANNEL_TYPE_RX_NOT_TX, Ant.NETWORK_PLUS); GenericChannel.initialize(method(:onMessage), chanAssign); // Set the configuration deviceCfg = new Ant.DeviceConfig( { :deviceNumber =&gt; 0, //Wildcard our search :deviceType =&gt; DEVICE_TYPE, :transmissionType =&gt; 0, :messagePeriod =&gt; PERIOD, :radioFrequency =&gt; 57, //Ant+ Frequency :searchTimeoutLowPriority =&gt; 10, //Timeout in 25s :searchTimeoutHighPriority =&gt; 2, //Timeout in 5s :searchThreshold =&gt; 0} ); //Pair to all transmitting sensors GenericChannel.setDeviceConfig(deviceCfg); data = new TempeData(); searching = true; } This code sets up the ANT channel assignment and sets device config and passes them to the base Ant.GenericChannel class. The device config is set to wildcard search to find any environment sensor. The initializer also sets up the onMessage callback to handle incoming packets. // Handle incoming information function onMessage(msg as Message) { // Parse the payload var payload = msg.getPayload(); if( Ant.MSG_ID_BROADCAST_DATA == msg.messageId ) { if( TempeDataPage.PAGE_NUMBER == (payload[0].toNumber() &amp; 0xFF) ) { // Were we searching? if(searching) { searching = false; // Update our device configuration primarily to see // the device number of the sensor we paired to deviceCfg = GenericChannel.getDeviceConfig(); } var dp = new TempeDataPage(); dp.parse( msg.getPayload(), data ); tempDataAvailable = true; // Check if the data has changed and we need to update the ui if( pastEventCount != data.eventCount ) { pastEventCount = data.eventCount; } } } // end broadcast data else if( Ant.MSG_ID_CHANNEL_RESPONSE_EVENT == msg.messageId ) { if( Ant.MSG_ID_RF_EVENT == (payload[0] &amp; 0xFF) ) { if( Ant.MSG_CODE_EVENT_CHANNEL_CLOSED == (payload[1] &amp; 0xFF) ) { open(); } else if( Ant.MSG_CODE_EVENT_RX_FAIL_GO_TO_SEARCH == (payload[1] &amp; 0xFF) ) { searching = true; } } else{ //It is a channel response. } } // end channel response event } // end on message The callback handles pairing with a nearby sensor, and handing incoming packets. The MO2Display sample provides a sample application that implements the Muscle Oxygen ANT profile. The ANT Generic interface is not available to watch faces. Low and high priority search timeout for sensors differs from the basic ANT radio specification to allow for interoperation with native ANT behavior on devices. These are limited to a maximum timeout of 30 seconds and 5 seconds respectively. Burst Data
 Since API level 2.2.0 Burst data transmission provides a mechanism for large amounts of data to be sent between devices over an ANT Generic Channel. Developers are notified through a listener of the success/failure of burst transmit/receive events. Burst data transmission is limited to up to 8Kb of data at a time. Common use cases for this include passkey authentication or sending/receiving configuration data between devices. The GenericChannelBurst sample provides a demonstration of transmitting and receiving burst data. ANT+ Profiles
 Since API level 2.2.0 The Toybox.AntPlus module allows access to information about ANT+ sensors that are paired to a user’s device without requiring you to set up and manage the ANT channel yourself. All management of ANT+ sensors such as adding, removing, enabling, disabling, and calibrating is managed by the user via the device’s regular sensor menus. An extension of a sensor-specific listener is passed into the constructor for a sensor-specific extension of AntPlus.Device . If there is a sensor of the given type paired to the user’s device, information about that sensor can be retrieved using the sensor-specific getters, or through the common data getters such as Device.getBatteryStatus() . null can be passed in as the identifier for sensor types (like most) that do not support multi-components. Callbacks in the AntPlus.DeviceListener and extensions of it will be called automatically if a sensor of the given type is paired and the corresponding information is updated via ANT. For example, DeviceListener.onDeviceStateUpdate() will be called if a sensor’s ANT channel goes from connected to searching, or if the user switches the sensor ID of a given type that their device is connected to. Callbacks like DeviceListener.onCalculatedPowerUpdate() will be called when new pieces of information about a power sensor are received via ANT. Certain ANT+ sensors, such as bike lights, have special callbacks. For example, the DeviceListener.onLightNetworkStateUpdate() callback should be used to understand the light network’s state rather than onDeviceStateUpdate() . The AntPlus.LightNetwork class will allow you to make changes to bike light modes, given there are bike lights paired to the user’s device and a light network is fully formed. Not all ANT+ profiles provisioned by Monkey C will be supported by every Connect IQ-compatible device.


# [Bluetooth Low Energy](https://developer.garmin.com/connect-iq/core-topics/bluetooth-low-energy/)nMenu Core Topics Getting Started with Connect IQ BLE Development
 Resources
 When going through this guide, developers will want to keep a few things handy. Connect IQ BLE API Documentation Having the API Documentation close by will be critical (especially in the later steps of this document). 
 Nordic nRF52 DK The Connect IQ team has built out the Connect IQ SDK tools to be compatible with the Nordic nRF52 DK Bluetooth 5 and Bluetooth mesh Development Kit for nRF52810. 
 
 Nordic Documentation Page The Nordic Documentation has links to all of the resources needed to use the nRF52 DK. 
 nRF Connect For Desktop The nRF Connect For Desktop application allows developers to flash new firmware to the board, monitor connections, etc. This software is necessary to program the board to work correctly with the Connect IQ simulator. 
 An up-to-date Connect IQ SDK To use the BLE APIs, developers should be working with the current version of the Connect IQ SDK. 
 Firmware for the nRF52 DK The memory layout of the nRF52 DK will need to be flashed to a different firmware for use with the Connect IQ SDK. The correct firmware for the development environment has been provided: nRF52 DK firmware 
 nRF52840 Dongle firmware 
 

 
 Windows
 The drivers and applications needed to communicate with the nRF52 DK are all included in the installation of nRF Connect for Desktop for the Windows platform. Once this application is installed along with the necessary drivers, the nRF52 DK should be found by the nRF Connect for Desktop application. At this point, proceed to the Using Nordic nRF Connect section. Mac
 When using macOS, developers will need to manually install the JLink/JTrace USB drivers to communicate with the nRF52 DK board. To do so, download and install the Segger JLink installer package 6.22g for Mac. Once this is completed, developers will need to install the nRF Connect for Desktop for Mac. At this point, proceed to the Using Nordic nRF Connect section. Linux
 When using Linux, developers will need to manually install the JLink/JTrace USB drivers to communicate with the nRF52 DK board. To do so, download and install using the appropriate Segger JLink installer for Linux: 32-bit: JLink_6.22g - 32 
 64-bit: JLink_6.22g - 64 
 
 Once this is completed developers will need to install the nRF Connect for Desktop for Linux. Using Nordic nRF Connect
 The nRF Connect Desktop application will need to be installed. Please see the above sections for the appropriate links. Once installed, launch the application. Click Add/remove apps : 
 Install the Programmer app.
 Click Launch App .
 Plug in the nRF52 board.
 Launch the Programmer app. 
 Near the top left, click Select device .
 Select the correct device.
 Click Read to see the Memory Layout of the connected device. [1] 
 Drag and drop or click Add HEX file to prepare the desired Memory Layout with the proper .hex file. 
 Click Erase &amp; write to flash the new memory layout. 
 Finding The COM Port
 Now that the board is properly communicating with the computer, it’s time to figure out which port it’s utilizing. Windows
 Open up Device Manager and find your device under Ports . It will look something like this: The communications port is listed in parentheses. In the example above the communications port is COM4 . Copy this to be used in a later step and proceed to Setting the COM Port . Mac
 Open up a terminal and type: ls /dev/tty.usbmodem* then press Tab . This should list out the port information in the format /dev/tty.usbmodem&lt;number&gt; . Copy this to be used in a later step and proceed to Setting the COM Port . Linux
 Open up a terminal and type: ls /dev/ttyACM* then press Tab . This should list out the port information in the format /dev/ttyACM&lt;number&gt; . Copy this to be used in a later step and proceed to Setting the COM Port . Setting the COM Port
 At this point the nRF52 is properly communicating with the development environment and the com port information has been retrieved. The final step is to set the COM port in the Connect IQ Simulator. Launch the simulator via Visual Studio Code or command line tools. 
 Select Settings &gt; BLE Settings 
 In the dialog box, enter the COM port information from Finding the COM Port . 
 Click OK . 
 It’s possible that developers might encounter an error. This is likely due to a failure to set the COM Port for the Connect IQ simulator. If an error occurs, then developers have a few things they can check. Double check the COM Port assignment: Follow the steps for the correct environment to find and confirm the COM Port.
 Ensure there are no copy/paste errors: Double check the information entered when setting the COM Port .
 That’s it! If all goes well, then the Connect IQ Simulator will use the nRF52 DK board BLE chipset to communicate with nearby BLE devices per the Connect IQ Bluetooth Low Energy APIs. For more information on the APIs, please refer to the API documentation and the NordicThingy52 and NordicThingy52CoinCollector sample applications included in the Connect IQ SDK. Developers may also check the Auto read memory checkbox to have the device memory read automatically each time an action is taken. &nbsp;↩


# [Sensors](https://developer.garmin.com/connect-iq/core-topics/sensors/)nMenu Core Topics Sensors
 The Toybox.Sensor module allows the app to enable and receive information from Garmin ANT+ sensors. To receive information, a listener method must be assigned and the sensors enabled: function initialize() { Sensor.setEnabledSensors( [Sensor.SENSOR_HEARTRATE] ); Sensor.enableSensorEvents( method( :onSensor ) ); } function onSensor(sensorInfo as Sensor.Info) as Void { System.println( "Heart Rate: " + sensorInfo.heartRate ); } Sensor information is packaged in the Sensor.Info object: Sensor Type API Units API Level 
 Accelerometer Info.accel Array of x,y,z values in millig-units. 1.2.0 
 Altitude Info.altitude Altitude above mean sea level in meters (m). 1.0.0 
 Cadence Info.cadence Revolutions per minute (rpm). 1.0.0 
 Heading Info.heading True north in radians. 1.0.0 
 Heart Rate Info.heartRate Beats per minute (bpm). 1.0.0 
 Magnetometer Info.mag Array of x,y,z values in milliGauss. [1] 1.2.0 
 Oxygen Saturation Info.oxygenSaturation The current oxygen saturation in percent (%). 3.2.0 
 Power Info.power Watts. 1.0.0 
 Pressure Info.pressure The barometric pressure in Pascals. [2] 1.0.0 
 Temperature Info.temperature Degrees Celsius (C). 1.0.0 
 The simulator can simulate sensor data via the Simulation menu by selecting Fit Data &gt; Simulate Data . This generates valid but random values that can be read in via the sensor interface. For more accurate simulation, the simulator can play back a FIT file and feed the input into the Sensor module. To do this, select Simulation &gt; Fit Data &gt; Playback File and choose a FIT file from the dialog. For more, see the AccelMag and Sensor sample apps distributed with the SDK. High Frequency Data
 Since API level 2.3.0 The Toybox.Sensor module contains the ability to fetch samples of accelerometer data for a defined period of time with a certain frequency. This feature enables developers to implement their own custom motion detection algorithms within a Connect IQ application. Accelerometer data can be obtained by registering a sensor data listener, which provides sampling parameters as well as a user-defined callback method that will be executed when new data is available. Sensor data requests are managed via the following Sensor module methods and classes: Class or Function Purpose API Level 
 Sensor.SensorData Wrapper for high frequency sensor data 2.3.0 
 Sensor.AccelerometerData Wrapper for accelerometer information 2.3.0 
 Sensor.GyroscopeData Wrapper for gyroscope information 3.3.0 
 Sensor.MagnetometerData Wrapper for magnetometer information 3.3.0 
 Sensor.registerSensorDataListener() Register a callback to fetch data from various sensors 2.3.0 
 Sensor.unregisterSensorDataListener() Deregister a previously registered data request 2.3.0 
 Sensor.getMaxSampleRate() Get the maximum sample rate supported by the system 2.3.0 
 Calling Sensor.registerSensorDataListener() will enable your application to receive accelerometer data via the callback that you provide. The type and amount of data provided is configured via the options dictionary parameter, which supports the following fields: Option Description 
 :period A Number representing the period of time to request samples in seconds. Maximum is 4 seconds. 
 :sampleRate A Number representing the samples per second in Hz. Use getMaxSampleRate() to determine what the system can support. 
 :accelerometer Options for the accelerometer (see below) 
 :heartBeatIntervals Options for beat to beat intervals (see below) 
 :gyroscope Options for beat to beat intervals (see below) 
 :magnetometer Options for beat to beat intervals (see below) 
 The :accelerometer , :heartBeatIntervals , :gyroscope , and :magnetometer options allow the following: Option Applicable To Description 
 :enabled :accelerometer , :heartBeatIntervals , :gyroscope , :magnetometer Set to true to enable the sensor 
 :sampleRate :accelerometer , :gyroscope , :magnetometer A Number representing the samples per second in Hz. Use getMaxSampleRate() to determine what the system can support. 
 :includePower :accelerometer Requests that the power array be computed. Default false 
 :includePitch :accelerometer Requests that pitch array be computed. Default false 
 :includeRoll :accelerometer Requests that roll array be computed. Default false 
 Additionally, you must provide a callback method that accepts a single parameter, which is invoked by the system when new data is available. This method is passed a SensorData object populated with the requested sensor data. Note that only a single sensor data request can be active at any given time, so if you wish to submit a request while an existing one is active, you must first call Sensor.unregisterSensorDataListener() . After Sensor.registerSensorDataListener() is called, the callback that you provided will be invoked whenever a new set of samples are available. For example, if you request four seconds worth of data at 25Hz, the callback will be invoked every 100 samples taken. A simplified usage example can be found below: using Toybox.Sensor; class MyAccelHistoryClass { private var _samplesX = null; private var _samplesY = null; private var _samplesZ = null; // Initializes the view and registers for accelerometer data public function enableAccel() as Void { var maxSampleRate = Sensor.getMaxSampleRate(); // initialize accelerometer to request the maximum amount of data possible var options = {:period =&gt; 4000, :sampleRate =&gt; maxSampleRate, :enableAccelerometer =&gt; true}; try { Sensor.registerSensorDataListener(method(:accelHistoryCallback), options); } catch(e) { System.println(e.getErrorMessage()); } } // Prints acclerometer data that is recevied from the system public function accelHistoryCallback(sensorData as SensorData) as Void { _samplesX = sensorData.accelerometerData.x; _samplesY = sensorData.accelerometerData.y; _samplesZ = sensorData.accelerometerData.z; System.println("Raw samples, X axis: " + _samplesX); System.println("Raw samples, Y axis: " + _samplesY); System.println("Raw samples, Z axis: " + _samplesZ); } public function disableAccel() as Void { Sensor.unregisterSensorDataListener(); } } For more, see the PitchCounter sample app distributed with the SDK. Filtering Accelerometer Data
 When processing accelerometer data, you may wish to apply filters to the raw sensor input that your application receives. IIR and FIR filter objects are provided to aid the developer in sample filtering. The following new objects have been added to the Math module: Class Purpose API Level 
 Math.FirFilter Create a FIR filter that can be applied to a sample array 2.3.0 
 Math.IirFilter Create a IIR filter that can be applied to a sample array 2.3.0 
 Each filter class requires coefficients to be provided, which is done via the dictionary parameter. The options supported by each filter class are as follows: FIR Filter Option Description 
 :coefficients An array of float values that specify the filter coefficients. This can also be a resource ID referring to an embedded JSON resource that defines the array of values. 
 :gain A float value that specifies a multiplier to be applied to the coefficients. 
 IIR Filter Option Description 
 :coefficientList1 An array of float values that specify the filter coefficients. This can also be a resource ID referring to an embedded JSON resource that defines the array of values. 
 :coefficientList2 An array of float values that specify the filter coefficients. This can also be a resource ID referring to an embedded JSON resource that defines the array of values. 
 :gain A float value that specifies a multiplier to be applied to the coefficients. 
 Once the filter object has been constructed, the apply function can be called, passing in an array of samples, and an array containing the filtered results will be returned. A simplified usage example can be found below (for a more detailed sample see the PitchCounter sample app distributed with the SDK). using Toybox.Sensor; class MyAccelHistoryClass { hidden var mFilter = null; hidden var mSamplesX = null; hidden var mSamplesY = null; hidden var mSamplesZ = null; function initialize() { mFilter = new Sensor.FirFilter({:coefficients=&gt;[0.22,0.12,0.55], :gain=&gt;1.2); } // Initializes the view and registers for accelerometer data function enableAccel() { var maxSampleRate = Sensor.getMaxSampleRate(); // initialize accelerometer to request the maximum amount of data possible var options = {:period =&gt; 4000, :sampleRate =&gt; maxSampleRate, :enableAccelerometer =&gt; true}; try { Sensor.registerSensorDataListener(method(:accelHistoryCallback), options); } catch(e) { System.println(e.getErrorMessage()); } } // Prints acclerometer data that is recevied from the system function accelHistoryCallback(sensorData) { mSamplesX = mFilter.apply(sensorData.accelerometerData.x); mSamplesY = sensorData.accelerometerData.y; mSamplesZ = sensorData.accelerometerData.z; Toybox.System.println("Filtered samples, X axis: " + mSamplesX); Toybox.System.println("Raw samples, Y axis: " + mSamplesY); Toybox.System.println("Raw samples, Z axis: " + mSamplesZ); } function disableAccel() { Sensor.unregisterSensorDataListener(); } } Logging Accelerometer Data
 Accelerometer data can also be logged by the device, and can be played back in the simulator for testing applications that use the Accelerometer Data feature. Logging accelerometer data is done by passing a SensorLogging.SensorLogger object to a FIT recording session. The SensorLogger object with the same options provided to the Sensor.registerSensorDataListener() method. However, the logger will always record at a standard rate for consumption by the simulator. A simplified usage example can be found below (for a more detailed sample see the samples/PitchCounter sample app distributed with the SDK). import Toybox.SensorLogging; class LoggingController { private var _logger as SensorLogger; private var _session as Session; public function initialize() { _logger = new SensorLogging.SensorLogger({:enableAccelerometer =&gt; true}); _session = Fit.createSession({:name=&gt;"mySession", :sport=&gt;Fit.SPORT_GENERIC, :sensorLogger =&gt; mLogger}); } public function startLogging() { _session.start(); } public function stopLogging() { _session.stop(); } public function saveLogging() { _session.save(); } } Weather
 Since API level 3.2.0 Many Garmin devices have access to current weather conditions that are updated every 15 minutes. This information requires that the device has access to a data connection, primarily via a paired smartphone. Weather information is not available in all areas of the world. Connect IQ provides the following ways to access this information: Function Purpose API Level 
 Weather.getCurrentConditions() Get the most recently cached weather conditions 3.2.0 
 Weather.getDailyForecast() Get the daily forecast 3.2.0 
 Weather.getHourlyForecast() Get the hourly forecast 3.2.0 
 Weather.getSunrise() Get the sunrise for a given location 3.3.0 
 Weather.getSunset() Get the sunset for a given location 3.3.0 
 Be aware that the user is allowed to choose a specific location for weather updates besides their current location. You cannot assume that the weather conditions returned are the weather conditions for your current location. MillivaniliGauss was the authors high school rap duo. &nbsp;↩ 
 Not to be confused with the Pedropascals used as a measure of “cool”. This author measures 20 picoPedropascals. &nbsp;↩


# [Positioning](https://developer.garmin.com/connect-iq/core-topics/positioning/)nMenu Core Topics Positioning
 Monkey C provides access to the wearable’s available sensors, which may include the GPS, altimeter, thermometer, and supported ANT sensors. API Purpose API Level 
 Position.Location Abstraction of a coordinate 1.0.0 
 Position.enableLocationEvents() Allows enabling the GPS and receiving location update events to a callback.Requires the Position permission. 1.0.0 
 Position.getInfo() Query the position information from the system 1.0.0 
 Location
 A Position.Location is an abstraction of a coordinate. It exposes the ability to retrieve the coordinates in radians or decimal degrees and then provides a method to convert to coordinate formats supported by the Garmin system. The Toybox.Position module also exposes string parsing interface to convert from various coordinate formats to a Location object. Location Events
 To enable the GPS call the Position.enableLocationEvents() method. To register a position listener, use the Object.method() call to create a Lang.Method callback: function onPosition( info as Position.Info ) as Void { Sys.println( "Position " + info.position.toGeoString( Position.GEO_DM ) ); } function initializeListener() as Void { Position.enableLocationEvents( Position.LOCATION_CONTINUOUS, method( :onPosition ) ); } All of the location information will be sent in an Position.Info object. You can also use Position.getInfo() to retrieve an Info instance. For more, see the PositionSample sample app distributed with the SDK. Multi-Band
 There are times where you may want control over what positioning solution is used. The :configuration option of Position.enableLocationEvents() allows you to specify the which positioning solution you wish to use: Configuration GPS Solution API Level 
 CONFIGURATION_GPS GPS L1 3.3.6 
 CONFIGURATION_GPS_GLONAS GPS L1, GLONASS 3.3.6 
 CONFIGURATION_GPS_GALILEO GPS L1, GALILEO L1 3.3.6 
 CONFIGURATION_GPS_BEIDOU GPS L1, BEIDOU L1 3.3.6 
 CONFIGURATION_GPS_GLONASS_GALILEO_BEIDOU_L1 GPS L1, GLONASS, GALILEO L1, BEIDOU L1 3.3.6 
 CONFIGURATION_GPS_GLONASS_GALILEO_BEIDOU_L1 GPS L1, GLONASS, GALILEO L1, BEIDOU L1 3.3.6 
 CONFIGURATION_GPS_GLONASS_GALILEO_BEIDOU_L1_L5 GPS L1, GLONASS, GALILEO L1, BEIDOU L1, GPS L5, GALILEO L5, BEIDOU L5 3.3.6 
 CONFIGURATION_SAT_IQ Solution chosen dynamically for optimum power usage 3.3.6 
 Not every device supports every GPS configuration. You can use Position.hasConfigurationSupport() to determine if the device supports a specific configuration.


# [Activity Recording](https://developer.garmin.com/connect-iq/core-topics/activity-recording/)nMenu Core Topics Activity Recording
 Imagine that you are trying to create a yoga app. You’d like the app to record heart rate and calories burned during your yoga workout, just like other Garmin apps. You’d also like the recording to be displayed on Garmin Connect . Monkey C allows for apps to start and stop recording of FIT files. Controlling the FIT file recording requires a few steps: Enable the sensors to be recorded
 Use ActivityRecording.createSession() to create a session object
 Use the Session.start() method of the FIT session to begin recording. Data from the enabled sensors will be recorded into the FIT file.
 Use Session.stop() to pause the recording
 Use Session.save() to save the recording, or Session.discard() to delete the recording
 The FIT file will sync with Garmin Connect . You can use the Garmin Connect Developer Program to process the FIT file from a web service. For more, see the RecordSample sample app distributed with the SDK. Recording FIT Files
 In addition to being able to play back existing FIT files, the simulator can also record files using data obtained via the Fit Data &gt; Simulate Data menu option. To begin recording a session you must start the timer; this can be done via the Data Fields &gt; Timer &gt; Start Activity menu option, or by clicking the corresponding start button on the device you have selected. The following table describes the different options available for activity recording and provides instructions for how to access them via the menu bar, or the device buttons (where available). Option Menu Button Device Button Notes 
 Start Activity Data Fields &gt; Timer &gt; Start Activity Start Button The device start button starts and stops an activity. 
 Stop Activity Data Fields &gt; Timer &gt; Stop Activity Start Button The device start button starts and stops an activity, and the Start Activity menu item is renamed to Stop Activity when recording is active. 
 Lap Activity Data Fields &gt; Timer &gt; Lap Activity Back Button Records a lap record in the FIT file. 
 Pause Activity Data Fields &gt; Timer &gt; Pause Activity N/A Pauses activity recording. Note this option is only available when FIT data simulation is enabled. 
 Resume Activity Data Fields &gt; Timer &gt; Resume Activity N/A Resumes activity recording. Note this option is only available when FIT data simulation is enabled and activity recording is paused. 
 Discard Activity Data Fields &gt; Timer &gt; Discard Activity N/A Discards the current recording and deletes the corresponding .fit file. Note this is only enabled if activity recording has been started and subsequently stopped. 
 Save Activity Data Fields &gt; Timer &gt; Save Activity N/A Saves the recorded activity into a .fit file and resets the timer state. Note this is only enabled if activity recording has been started and subsequently stopped. 
 Note: the device simulator will not automatically start activity recording when a data field is being run. You must explicitly start and stop activity recording via the menu options described here. FIT Developer Fields
 Now imagine you want to add a new metric - Namastes - to the Yoga app [1] . This metric will combine heart rate, accelerometer, and other sensor data into a single value, and does not have an analog in any Garmin recording metric. To do this we need the Toybox.FitContributor module, which allows you to add new metrics to a FIT recording and display it on Garmin Connect . First, you must enable the FitContributor permission in the manifest file (see the Manifest and Permissions section for more information). Next, you need to add your field definitions in your resources using the fitContributions block: &lt;strings&gt; &lt;string id="namaste_label"&gt;Namastes&lt;/string&gt; &lt;string id="namaste_graph_label"&gt;Namastes&lt;/string&gt; &lt;string id="namaste_units"&gt;N(s)&lt;/string&gt; &lt;/strings&gt; &lt;fitContributions&gt; &lt;fitField id="0" displayInChart="true" sortOrder = "0" precision="2" chartTitle="@Strings.namaste_graph_label" dataLabel="@Strings.namaste_label" unitLabel="@Strings.namaste_units" fillColor="#FF0000" /&gt; &lt;/fitContributions&gt; The fitField block has a number of configurable options: Attribute Value Notes 
 id A numeric value from 0 to 255 used to refer to your field No duplicates within an app are allowed 
 displayInChart Indicates whether or not record level connect IQ data should be rendered in a chart true if you want this entry to be displayed as a chart, false otherwise. Graph fields can only support numeric data. 
 displayInActivityLaps Indicates whether or not lap level connect IQ data should be rendered in the Activity Laps section in the Garmin Connect Activity Details page true if you want this entry to be displayed in the activity laps, false otherwise 
 displayInActivitySummary Indicates whether or not activity (fit session) level connect IQ data should be rendered in the Activity Summary section in the Garmin Connect Activity Details page true if you want this entry to be displayed in the activity summary data, false otherwise 
 sortOrder Determines the order in which the Connect IQ data will appear in the Summary or Lap Sections of the Activity Details page and what order charts will be displayed on the Activity Details page No duplicates are allowed 
 precision Decimal point precision for numeric data 0 for integer, 1 for one decimal point, 2 for two decimal points. Without this attribute the default is no rounding 
 chartTitle This is the resources string key to use to render the title of the chart Optional if displayInChart is false . Must be a string resource. 
 dataLabel This is the resources string key to use to render the label of the data field in the Activity Summary or Activity Laps section of the Activity Details page (ex. Cadence, or Heart Rate). Must be a string resource 
 unitLabel This is the key to use to render the unit of the data field in the Activity Summary or Activity Laps section of the Activity Details page (ex. kph, or miles). Must be a string resource 
 fillColor RRGGBB value of color to use for chart Optional if displayInChart is false 
 This will communicate the metadata to display our chart to Garmin Connect . Now we need to create our Field in the code. You do this by using the Session.createField() method of the Session object within your source: // Field ID from resources. const NAMASTE_FIELD_ID = 0; hidden var mNamasteField; // Initializes the new Namaste field in the activity file function setupField(session as Session) { // Create a new field in the session. // Current namastes provides an file internal definition of the field // Field id _must_ match the fitField id in resources or your data will not display! // The field type specifies the kind of data we are going to store. For Record data this must be numeric, for others it can also be a string. // The mesgType allows us to say what kind of FIT record we are writing. // FitContributor.MESG_TYPE_RECORD for graph information // FitContributor.MESG_TYPE_LAP for lap information // FitContributor.MESG_TYPE_SESSION` for summary information. // Units provides a file internal units field. mNamasteField = session.createField("current_namastes", NAMASTE_FIELD_ID, FitContributor.DATA_TYPE_FLOAT, { :mesgType=&gt;Fit.MESG_TYPE_RECORD, :units=&gt;"N" }); } Now when you call Session.setData() on mNamasteField the value will be recorded into either the Record, Lap, or Session information of the FIT file based on the message type specified when calling createField() . If you are creating a Record (graph), you should update this value once a second. For lap and summary, you should provide constant updates to the current lap or workout value for the metric. After setting this up, you will want to preview how this will look on Garmin Connect . We can use the Monkey graph tool to create a preview. The Monkey graph tool requires the following: a FIT file with the recorded developer data, and an IQ file of the app (you can acquire an IQ file via the App Export Wizard . The tool will allow you to test how charts will look before uploading your app for review. See how to launch the Monkey graph tool included with the SDK. namaste &nbsp;↩


# [Quantifying the User](https://developer.garmin.com/connect-iq/core-topics/quantifying-the-user/)nMenu Core Topics Quantifying User Information
 Garmin devices collect and quantify numerous metrics about the user [1] . Connect IQ exposes many of the collected metrics so they can be incorporated into your solutions. The Toybox.ActivityMonitor and Toybox.SensorHistory modules allow apps to access the activity tracking, wellness features, and historical sensor information of Garmin wearable devices. User Profile
 The Toybox.UserProfile provides access to personal information about the user, including their gender, birth year, height, weight, and athletic metrics like VO2 Max and activity class. It requires the UserProfile permission to access. The UserProfile.getProfile() call returns a UserProfile.Profile object, which provides Metric API Value API Level 
 Activity Class Profile.activityClass A quantification of how active the user from 0 to 100 1.0.0 
 Average Resting Heart Rate Profile.averageRestingHeartRate The user’s seven day average resting heart rate (bpm) 3.2.0 
 Biological Sex Profile.gender The user’s biological gender 1.0.0 
 Birth Year Profile.birthYear The year the user was born 1.0.0 
 Cycling VO2 Max Profile.vo2maxCycling The user’s VO2 Max value for a cycling activity 3.3.0 
 Height Profile.height The user’s height in centimeters (cm) 1.0.0 
 Resting Heart Rate Profile.restingHeartRate The user’s current resting heart rate in beats per minute (bpm) 1.0.0 
 Running Step Length Profile.runningStepLength The user’s running step length in millimeters (mm) 1.0.0 
 Running VO2 Max Profile.vo2maxRunning The user’s VO2 Max value for a running activity 3.3.0 
 Sleep Time Profile.sleepTime Typical sleep time as configured by the user 1.0.0 
 Wake Time Profile.wakeTime Typical wake time as configured by the user 1.0.0 
 UserProfile provides access to the additional data: Information API Value API Level 
 Activity History UserProfile.getUserActivityHistory() Record of the activities the user has done 3.3.0 
 Heart Rate Zones UserProfile.getHeartRateZones() The user’s defined heart rate zones for running, cycling, or swimming 1.2.6 
 Activity Monitoring
 ActivityMonitor provides access to the current day’s metrics via ActivityMonitor.getInfo() which returns a ActivityMonitor.Info object. You can also get a daily history of some of these metrics with ActivityMonitor.getHistory() which returns an array of ActivityMonitor.History objects. How far back this history goes can vary by device as well as how long the device has been turned on, but a seven day history is fairly typical. Metric API Value API Level 
 Calories Burned Info.calories , History.calories The calories burned so far for the current day in kilocalories (kCal) 1.0.0 
 Daily Active Minutes Info.activeMinutesDay , History.activeMinutes The number of active minutes for the current day 2.1.0 
 Distance Traveled [2] Info.distance , History.distance The distance traveled since midnight of the current day in centimeters (cm) 1.0.0 
 Floors Climbed Info.floorsClimbed , History.floorsClimbed The number of floors climbed for the current day 2.1.0 
 Floors Climbed Goal Info.floorsClimbedGoal , History.floorsClimbedGoal The goal the user has set for the number of floors climbed in a day 2.1.0 
 Floors Descended Info.floorsDescended , History.floorsDescended The number of floors descended for the current day 2.1.0 
 Meters Climbed Info.metersClimbed The vertical distance of floors climbed in meters (m) 2.1.0 
 Meters Descended Info.metersDescended The vertical distance of floors descended in meters (m) 2.1.0 
 Move Bar Level Info.moveBarLevel The current level of the move bar between MOVE_BAR_LEVEL_MIN and MOVE_BAR_LEVEL_MAX 1.0.0 
 Respiration Rate Info.respirationRate Current respiration rate for the user, in breaths per minute 3.3.0 
 Steps Info.steps , History.steps The step count since midnight of the current day in number of steps 1.0.0 
 Step Goal Info.stepGoal , History.stepGoal The step goal for the current day in number of steps 1.0.0 
 Stress Info.stressScore The current stress score based on the last 30 seconds 5.0.0 
 Time to Recovery Info.timeToRecovery Time to recovery from the last activity, in hours 3.3.0 
 Weekly Active Minutes Info.activeMinutesWeek The number of active minutes for the current week 2.1.0 
 Weekly Active Minutes Goal Info.activeMinutesWeekGoal The user’s goal number of weekly active minutes 2.1.0 
 Wheelchair Pushes Info.pushes The user’s number of wheelchair pushes 4.2.0 
 Wheelchair Pushes Goal Info.pushesGoal The user’s goal number of wheelchair pushes 4.2.0 
 When wheelchair mode is enabled, ActivityMonitor.Info will have zeroes for steps , stepGoal , floorsClimbed , floorsDescended and Info.floorsClimbedGoal and will instead have values in pushes and pushesGoal . Sensor History
 Since API level 2.1.0 The Toybox.SensorHistory module allows the app to access saved sensor history on the device. Data from sensors can be accessed by getting an iterator. Function Purpose API Level 
 SensorHistory.getBodyBatteryHistory() Get the user’s body battery samples as recorded over the previous hours on the device. This does not have access to synced data. 3.3.0 
 SensorHistory.getHeartRateHistory() Get the user’s heart rate samples as recorded over the previous hours on the device. This does not have access to synced data. 2.1.0 
 SensorHistory.getTemperatureHistory() Get the temperature as recorded over the previous hours on the device. This does not have access to synced data. 2.1.0 
 SensorHistory.getPressureHistory() Get the barometric pressure as recorded over the previous hours on the device. This does not have access to synced data. 2.1.0 
 SensorHistory.getElevationHistory() Get the distance from sea level as recorded over the previous hours on the device. This does not have access to synced data. 2.1.0 
 SensorHistory.getOxygenSaturationHistory() Get the user’s SpO2 as recorded over the previous hours on the device. This does not have access to synced data. Depends on if user has enabled MO2 recording. 3.2.0 
 SensorHistory.getStressHistory() Get the user’s stress as recorded over the previous hours on the device. This does not have access to synced data. 3.3.0 
 Not all SensorHistory types are available on all devices. Capabilities should be validated using the has operator. The get functions will return a SensorHistory.SensorHistoryIterator type. Calling the SensorHistoryIterator.next() function will iterate through the history values until the end of the data is reached. When there is no more data the iterator will return null. There are no guarantees on the sample interval or that the requested range will be available. This function returns a SensorSample object. The iterator can be adjusted to provide the newest data values first or the oldest values first by using the enumeration values ORDER_NEWEST_FIRST and ORDER_OLDEST_FIRST Number 6’s argument of “I am not a number, I am a free man!” never met Garmin Connect &nbsp;↩ 
 🎵 …and I would walk five hundred miles / and I would walk five hundred more / just to be the man who walks a thousand miles / and beats my Connect step challenge 🎵 &nbsp;↩


# [Complications](https://developer.garmin.com/connect-iq/core-topics/complications/)nMenu Core Topics Complications
 Garmin devices collect numerous data points as users wear them. Many of these data points can be summarized and displayed on the watch face as a complication . The Connect IQ SDK offers multiple APIs to access user metrics, and has expanded the offerings with every release. The Toybox.Complications module consolidates the specific metrics typically displayed by Garmin devices into a unified interface. This unified interface gives the developer access to the information typically shown on the watch face for the developer. The complications are exposed using a publish/subscribe model. In addition, device app and audio content provider developers can now publish up to four complications using this new framework. Complications have public, protected, and private visibility levels with the system. Finally, Face It will also be a consumer of Connect IQ complications. This allows developers to create information that can be published on Face It watch faces. Publishers and Subscribers
 At the heart of the complications system is a publisher/subscriber system. The system publishes complication data for subscribers to consume. Connect IQ device apps and audio content providers can publish complication data, but only watch faces can subscribe to complication information. Complication Objects
 Data is published as a Complications.Complication object. The complication object exposes the following information: Identifier Description API Level 
 complicationId A unique identifier for the type of data being published of type Complications.Id 4.2.0 
 longLabel A textual name for the complication. The long label is intended for display in a configuration menu. 4.2.0 
 ranges An optional array of numeric values. Ranges allow breakdowns of sets of values that can be integrated into the display. 4.2.0 
 shortLabel A five-character string intended to summarize your complication as a radial complication. 4.2.0 
 unit The units to use with the value. If this is null &nbsp;then the unit shouldn’t be displayed. If this is a UNIT &nbsp;identifier, the value &nbsp;is expected to be in a specific unit for conversion. If the unit &nbsp;is a string, the value &nbsp;should be interpreted without conversion. 4.2.0 
 value A string or numeric value describing the value to be displayed to the user 4.2.0 
 You can query additional information with these accessors: Method Description API Level 
 Complication.getIcon() For Connect IQ complications, query the icon provided by the app 4.2.0 
 Complication.getType() For native complications, returns the COMPLICATION_TYPE . Will return COMPLICATION_TYPE_INVALID &nbsp;for Connect IQ complications. 4.2.0 
 Units
 Complications are allowed to publish information in units that are configurable by the user in their system settings. When receiving complication values, it is the subscriber’s role to convert the value to the metric specified in system settings. Units should be expected to be published as the following: Unit Expected Value 
 Complications.UNIT_DISTANCE Meters 
 Complications.UNIT_ELEVATION Meters 
 Complications.UNIT_HEIGHT Meters 
 Complications.UNIT_SPEED Meters per second 
 Complications.UNIT_TEMPERATURE Degrees Celsius 
 Complications.UNIT_WEIGHT Grams 
 Subscribing to Complications
 To publish a complication you need to add the ComplicationSubscriber permission to your manifest file. Subscribing to Complications requires the Id . You can use Complications.getComplications() to query the identifiers of all complications supported by the system: // get an iterator over complications available to this app void iter = Complications.getComplications(); // iterate over them var complicationId = iter.next(); while (complicationId != null) { var complication = Complications.getComplication(complicationId); complicationId = iter.next(); } You can also query a native complication directly by constructing a Id explicitly: var complication = Complications.getComplication( new Id(Complications.COMPLICATION_TYPE_CALORIES) ); This only works for native complications. Once you have the complication id, you can persist the id in storage for later use. You can use Complications.registerComplicationChangeCallback() to subscribe to multiple complication values. All subscriptions are terminated when your app shuts down and must be re-done when your app is launched. When you subscribe, you register a callback to be called when the value updates: function onStart(params as Dictionary) as Void { // Retrieve persisted Complication ID mComplicationId = Storage.getValue(COMPLICATION_ID_KEY); // Register a callback for receiving // updates on complication information Complications.registerComplicationChangeCallback( self.method(:onComplicationChanged)); // Liking and subscribing Complications.subscribeToUpdates(mComplicationId); } In your callback, you can then query the updated information and process it: function onComplicationChanged( complicationId as Complication.Id) as Void { // Identify the complication being updated if (complicationId == mComplicationId) { // Get the complication information try { var data = Complications.getComplication( complicationId); // Handle the application processing updateData(complicationId, data); } catch (e instanceof ComplicationNotFoundException) { handleComplicationRemoval(complicationId); } } } If the complication is no longer available, for example the user has uninstalled the publishing app, the system will throw a ComplicationNotFoundException . You should trap this exception and handle it within your app. If a publishing app is uninstalled, the system will send an event to your ComplicationChangeCallback and automatically unsubscribe your app from any subscribed complications. When wheelchair mode is enabled, COMPLICATION_TYPE_STEPS and COMPLICATION_TYPE_FLOORS_CLIMBED are replaced with COMPLICATION_TYPE_WHEELCHAIR_PUSHES . Hold to Launch
 Some Connect IQ products have a feature where pressing and holding on a complication launches the associated app. You can add this functionality to your watch face by implementing the WatchFaceDelegate.onPress() method: function onPress(clickEvent as ClickEvent) as Boolean { if ((mComplicationId != null) &amp;&amp; isClickInside(clickEvent, mBoundingBox)) { // launch the app that published the // complication try { Complications.exitTo(mComplicationId); return true; } catch (e instanceof AppNotInstalledException) { // fall through } } return false; } Publishing Complications
 If you are developing a device or audio content provider apps, you can publish up to four complications to the framework. To publish a complication you need to add the ComplicationPublisher permission to your manifest file. Resources
 To publish a complication, you have to define each complication in your resources: &lt;complications&gt; &lt;complication id="0" access="public" longLabel="@Strings.myLongLabel" shortLabel="@Strings.myShortLabel" icon="@Drawables.MyComplication" glancePreview="true"&gt; &lt;faceIt defaultText="@Strings.complicationName" /&gt; &lt;range&gt; &lt;value&gt;0&lt;/value&gt; &lt;value&gt;24&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;41&lt;/value&gt; &lt;value&gt;50&lt;/value&gt; &lt;value&gt;53&lt;/value&gt; &lt;/range&gt; &lt;/complication&gt; &lt;/complications&gt; The complication element has the following attributes: Attribute Description Required API Level 
 id Numerical identifier from 0 - 255. Keep this value stable across versions. Changing this value between versions will impact apps consuming your complication when your app updates. Yes 4.2.0 
 access public , protected , or private Yes 4.2.0 
 longLabel A descriptive title for your complication value. Yes 4.2.0 
 shortLabel A short string for apps that are displaying your complication as a radial complication. No 4.2.0 
 icon A resource identifier for the icon you want to associate with this complication. The specified resource must be an svg &nbsp;if your access is public &nbsp;or protected . The icon cannot be changed at runtime. Yes 4.2.0 
 glancePreview A Boolean value. When users place your glance into a glance folder, you can identify one of your complications to be used as the preview value. Only one of your complications can be demarked as a preview. No 4.2.0 
 Using the access attribute, you can control if your complications are visible to just apps with your developer key, all apps, and Face It or all of the above: Access Your Apps Face It All Apps 
 public X X X 
 protected X X 
 private X 
 The required faceIt element allows you to provide information for Face it: Attribute Description Required API Level 
 defaultText This will be shown in Face It as the name of the complication. Yes 4.2.0 
 The optional range element allows you to provide an ordered set of numeric values that define different ranges for your value. Publishing Values
 Once your complication is defined, you can use the Complications.updateComplication() function to publish data: var data = { // String, Number, Float, Long, Double, or null :value =&gt; newValue, // String :shortLabel =&gt; newShortLabel, // String or Complication.UNITS_* value :units =&gt; newUnits, // Array&lt;Numeric&gt; with at least 3 elements :ranges =&gt; newRanges, } // update complication // 0 is the id of the complication // from complications.xml Complications.updateComplication(0, data); Face It Complications
 Publishing a complication as public allows Face It to integrate your complication. It will always display your complication icon, and will use the following rules to display your complication value: If units are… …then value is expected to be… …and will be displayed as… 
 Complications.UNIT &nbsp;type besides UNIT_INVALID A numerical value A numerical value converted from the default units defined for the unit type to the system units with the appropriate unit abbreviation. 
 String A numerical value A numerical value with the string units appended. 
 Complications.UNIT_INVALID or null A numerical or string value A numerical or string value will be displayed without conversion and without any units appended. 
 Some best practices: * Make sure your Face It icon is high contrast and will appear well in both light and dark mode in mobile. * Use Latin characters (A-Z, a-z, 0–9) for published complication strings.


# [Shareable Libraries](https://developer.garmin.com/connect-iq/core-topics/shareable-libraries/)nMenu Core Topics Shareable Libraries
 Developers can create custom Monkey C libraries, called Monkey Barrels, that contain source code and resource information that are easily shared across Connect IQ Projects. Monkey Barrels provide an easy way to store and reuse common code and resources that developers find useful. For example, many developers want a quick way to calculate time to sunrise or sunset. With Monkey Barrels, developers can store this code along with other common code and pull it into their various projects when useful. This saves time and effort allowing developers the ability to have maximum creativity. Making a Monkey Barrel
 From Visual Studio Code, Barrels can be created as a new project type: Use Ctrl + Shift + P ( Command + Shift + P on the Mac) to summon the command palette
 Type “New Project” and select Monkey C: New Project 
 When prompted with Set Project Name , enter a name for your new project
 Select the project type Monkey Barrel 
 Select the minimum API level
 Set the parent directory for your new project
 Once the project is created, you can edit your supported products and permissions in the manifest.xml . See Editing the Supported Products for more information. A specific check is in place to ensure that developers cannot have a Barrel with the name “Toybox”. The Barrel has now been created—now it’s time to fill it! Developers can think of Barrels as custom modules. In fact this is exactly how they should be set up: module FooBarrel { (:Bars) // Notice the annotations above the submodule names module Bars { // Create a counter var for the "Current Bars" var currentBars = 0; // Draw a "Bar" function drawBar() { // . . . draw a super awesome "Bar" return Bar; } // Increment the Bar counter function addBar(currentBars) { bars = currentBars; bars ++; return bars; } // Get the current Bars function getCurrentBars() { return currentBars; } } (:BarsToo) // Notice this here too module BarsToo { function fancyBars() { // . . . Do a fancy thing return somethingFancy; } } (:Empty) // An empty annotation module Empty { // A sub-module without an annotation module AlsoEmpty { } } // This module throws an error module throwsError { } } Developers can use annotations to denote sub-modules within their Barrels. Sub-modules with annotations (i.e. the (:Bars) annotation above) allow developers to import certain sections of code without importing the entire Barrel. If a module directly below the namespace is found at compile time that is not decorated with an annotation, a warning will be generated. A module lacking an annotation that is found within a module decorated with an annotation will also generate a warning (i.e. AlsoEmpty module above). See How to Include Barrels for more information on how to include Barrels and specific annotations. Annotations must also be configured in the manifest for the Barrel project: Double click the Barrel manfest.xml 
 Summon the command palette and run the Monkey C: Edit Annotations command
 Select Add Annotation 
 Input your annotation name
 The annotations will be available to use in the Barrel project. Barrels can also include resources. Resources are created and held within a Barrel in the same format as a regular application and are defined in XML format. See the [Resource Compiler] section of the Programmer’s Guide for more info on resources. The compiler will build the resource module as a sub-module of the Barrel’s module. For example, in a Barrel called, IconLibrary the module will look like this: IconLibrary { // Barrel Level Rez { // Rez Level Drawables { // Drawables Level var myIcon = 123; // Resource } } } Developers can reference resources within a Barrel by using the following syntax: @IconLibrary.Drawables.myIcon This makes it easy for developers to pull those resources into their projects without any changes. All files utilized by a Barrel must live in the Barrel project’s root directory, determined by the directory of the manifest.xml file, as importing files external to the project is not supported. Barrels and Versions
 Each Barrel has a unique version ID number. This follows the same numbering system as The Connect IQ SDK ( Major.Minor.Micro.Quailifier or #.#.#.X ). The version qualifier can only be comprised of letters, numbers, and underscores. Exporting a Monkey Barrel
 Monkey Barrels are packaged by the Monkey C compiler in order to satisfy a basic syntactical check of the source code. Note: While Barrels provide the mechanism of code libraries, they contain all of the unmodified source of your Barrel project. Do the following to export your Monkey Barrel: Make sure the manifest file specifies all products supported by the app
 Use the Monkey C: Export Project command to generate an .barrel file.
 If there are no errors ,the barrel is ready to use! How to Include Barrels
 In order to use a Barrel, developers will need to add it to the current project. This can be done through the Visual Studio Code extension or by manually editing a project’s Jungle and manifest file. Adding Barrels to a Project with Visual Studio Code
 Developers can add new Barrels to their project through the command palette: Use the Monkey C: Configure Monkey Barrel command
 Select Add Monkey Barrel 
 Select if you want to add it as a precompiled .barrel file or as a link to the barrel project
 Select the precompiled .barrel file or the Monkey Barrel project .jungle file, depending on the previous selection
 The Barrels and their specified annotations will be added to the default Barrel Jungle file automatically. The manifest file will also be updated with those Barrel dependencies. See the Build Configuration section to see how to deal with Barrels in Jungle configuration files directly. Once this is done, the selected Barrels will be added to your project. Using Monkey Barrels
 Once they have been added to a project, using Barrels is straight forward and simple. It is not necessary for Developers to import Barrels into source files with the using statement, however they will need a using statement if they choose to use aliases for them: // This is a normal Toybox "using" statment using Toybox.System; // This sets up an alias for a "submodule" within a barrel using FooBarrel.Bars as Bars; At this point, the alias has been set up and the Barrel code has been made available in the project. // This is a normal Connect IQ call System.println("Cool Bars"); // This is a general Barrels call (No using statment needed) FooBarrel.BarsToo.fancyBars(); // This is a specific Barrels call (Alias) var globalBars = Bars.getCurrentBars(); // This is a call to use a resource held in a Barrel var icon = UserInterface.loadResource(IconLibrary.Rez.Drawables.myIcon) Run No Evil and Monkey Barrels
 Barrels can be used in conjunction with the Run No Evil testing framework to test discrete sections of code. For more information on the Run No Evil testing framework developers can reference the Run No Evil documentation. Right click on the Barrel project root folder
 Select Run Tests 
 The Barrel code with the correct testing annotations (See Run No Evil documentation), will be tested in the Run No Evil testing framework. Barrels In The Command Line
 Barrels can be compiled and tested via the command line. barrelbuild Calls the Monkey C Barrel compiler. Much like monkeyc the barrelbuild call takes code from multiple files to be included in the library (.barrel file). The -f argument is required as the manifest file path is specified in one of the Barrel’s Jungle files. For more info, run barrelbuild without any arguments to see a full list of argument definitions. &gt; barrelbuild -o &lt;output.barrel&gt; -f &lt;barrel.jungle&gt; barreltest Executes Run No Evil tests on the .barrel file. Requires the -d argument with a valid device id. &gt; barreltest -o &lt;output.barrel&gt; -f &lt;barrel.jungle&gt; -d &lt;device_id&gt; The Connect IQ team has provided a few useful example Barrels for developers to try. To use these Barrels, go to the Garmin Connect IQ GitHub repository . Clone or download the desired Barrels and add them to the project using one of the previously discussed methods.


# [Debugging](https://developer.garmin.com/connect-iq/core-topics/debugging/)nMenu Core Topics Testing and Debugging
 Connect IQ has a couple of different methods for testing and debugging your apps: Basic debugging with println() statements
 Using the Visual Studio Code debugger
 Using the command line debugger ( mdd )
 Basic Debugging
 One way to test Connect IQ apps is to include System.println() statements at strategic points in your app. Within Visual Studio Code, these println() statements will output to the console. On a device, println() statements write to an &lt;APPNAME&gt;.TXT file in the /GARMIN/APPS/LOGS directory in the device file system. These log files are not automatically created, so they must be manually created on the device and named to match the name of the app’s corresponding PRG file. For example, to log output from /GARMIN/APPS/MYAPP.PRG , you must create /GARMIN/APPS/LOGS/MYAPP.TXT . Debugging with Visual Studio Code
 To begin debugging your application select Run &gt; Start Debugging . Make sure you have a source file from the project you wish to debug open in the editor. After selecting the product you want to debug, the app will launch in debug mode in the simulator. Debugging is only supported while running an application on the Connect IQ simulator. Setting a Breakpoint
 Like other projects in Visual Studio Code, to set a breakpoint in the Monkey C editor, highlight a line in the vertical ruler next to the source code and click to set a breakpoint. Viewing Application Status
 When your application hits a breakpoint, you can examine the runtime state in Run and Debug . The Variables view allows you to see your arguments and locals, while the Call Stack allows you to see state at different stack frame. When your application suspends while debugging you will be prompted to open the native Debug perspective. From here, you can view the stack trace within the native Debug view. Clicking on a stack frame within the stack trace will populate the native Variables view with the applicable variables at that stack frame. Global variables will only be visible in the top stack frame; they appear as the $ variable within that stack frame. Debugging with the Command Line
 mdd is the Monkey C command line debugger. Modeled after gdb , mdd allows you to load your executables, set breakpoints, and examine stack frames, local variables, and the global environment. Getting Started
 Make sure you have followed the “Getting Started” instructions to set up the command line environment. Before you begin, start the simulator: &gt; simulator &amp; [1] 27984 &gt; mdd You will be greeted with the following: Connect IQ Version 3.2.0. Type "help" for more information. (mdd) Help is always available from the command line prompt: (mdd) help List of classes of commands: breakpoints -- Making program stop at certain points. data -- Examining data. running -- Running the program. stack -- Examining the stack. status -- Status inquiries. support -- Support facilities. Type "help" followed by a class name for a list of commands in that class. Type "help all" for the list of all commands. Type "help" followed by a command name for full documentation. Command name abbreviations are allowed if defined. Loading and Running an Executable
 To load an executable into mdd , you need the prg , the debug XML and the product the prg is built for. If you compile your prg using the monkeyc command, the debug.xml will also be generated, and Visual Studio Code typically outputs these files in the bin folder of your project. You use the file command to load these into the mdd environment. (mdd) file MyFace.prg MyFace.prg.debug.xml fenix6 Now you can run the executable using the run command: (mdd) r Starting app: C:\Projects\ciq-apps\strava\bin\Strava.prg Setting Breakpoints
 Breakpoints can be assigned to a file/line pair with the break command: (mdd) break \path\to\Thx.mc:1138 Execution will pause when your program executes that line: Hit breakpoint 1, initialize () at Thx.mc:1138 (mdd) Frame Information
 You can inquire about your current stack frame using info frame : (mdd) info frame Stack level 0, frame at 0x10002120 in initialize() at Thx.mc:1138 called by frame at 0x10000b48 Args: self = &lt;0x84&gt; (Thx) Locals: thx = null sen = null You can also use the print command to output variables as well as expressions. (mdd) print thx thx = null Controlling Execution
 You can step to the next line using the next command: (mdd) next The step command will step into a subroutine: (mdd) step The continue command will return to full execution until the next breakpoint is set or the app terminates: (mdd) continue Handling Crashes
 Despite the best debugging efforts, crashes will sometimes happen. There are two general types of on-device crash that can occur related to Connect IQ, which each generate log files: app crashes and device crashes . App Crashes
 App crashes typically result in an app quitting unexpectedly or displaying an ‘IQ!’ icon, but does not cause the entire device to crash or reboot. This kind of crash is most commonly due to a bug in an app, though it can also be due to a bug in Connect IQ itself. Whenever an app crash occurs, a CIQ_LOG.YAML file is written or updated to /GARMIN/APPS/LOGS on the device, and contains information related to the crash that app developers may use to address the problem. Here is what a CIQ_LOG generally looks like: Error: ErrorName Details: Error description. Time: 2018-02-07T19:07:56Z Store-Id: 00000000-0000-0000-0000-000000000000 Store-Version: 0 Device-Id: 006-B0000-00 Device-Version: '0.00' ConnectIQ-Version: 3.0.0 Filename: PRGNAME Appname: DemoAppName Stack: - pc: 0x100000ef File: 'C:\Path\To\source\File.mc' Line: 53 Function: function_causing_error - pc: 0x10000080 File: 'C:\Path\To\source\File2.mc' Line: 30 Function: otherBrokenItems The ConnectIQ-Version entry is not the Connect IQ version of the device. Rather, this refers to the SDK version used by the developer when exporting the application. Note: For devices before API level 3.0.0, a simplified error log will be printed as CIQ_LOG.TXT . Device Crashes
 Device crashes typically cause the device to reboot or freeze. These indicate a Connect IQ or device firmware bug, and should be much less common than app crashes. When a device crash occurs, an ERR_LOG.txt file is written to /GARMIN on the device, containing stack trace information related to the crash. Please provide this file when reporting a crash on our developer forum. Garmin’s device teams can take a look at the device crash logs to determine the cause of the crash and will typically provide a fix in a future firmware release. A Note About Log Files
 When any log file on a device exceeds 5kb in size, it will automatically be archived to &lt;LOGNAME&gt;.BAK , and a new log will be started. Any old .BAK files will be overwritten when the archive occurs, so the max space a log can reach is around 10kb.


# [Unit Testing](https://developer.garmin.com/connect-iq/core-topics/unit-testing/)nMenu Core Topics Unit Testing
 The Connect IQ SDK has Run No Evil, an automated unit testing framework found in the Test module. Run No Evil operates only within the Connect IQ simulator and provides the ability to add asserts and unit test methods to your app. Asserts
 Asserts are a useful way to check for conditions at critical points in your code and will always execute when your app is launched in the simulator. For example, if your app always expects the value of x and y to not be equal: import Toybox.Test; function onShow() { var x = 1; var y = 1; // Prints an error to the console when x and y are equal Test.assertNotEqualMessage(x, y, "x and y are equal!"); } The code above produces the following output in the console when the app is run in the Simulator: Device Version 0.1.0 Device id 1 name "A garmin device" Shell Version 0.1.0 ASSERTION FAILED: x and y are equal! Assert code requires no special compiler commands to execute within the simulator, and are removed by the compiler when building release code. Run No Evil has four different assert flavors: Function Description 
 Test.assert() Assert throws an exception if the test is false 
 Test.assertMessage() Assert throws an exception and outputs a message if the test is false 
 Test.assertNotEqual() Throws an exception if value1 and value2 are not equal 
 Test.assertNotEqualMessage() Throws an exception and outputs a message if value1 and value2 are not equal 
 Unit Tests
 Unit tests are a great way to check discrete pieces of your app for pass/fail criteria. Each test is run independently, so if a test fails or causes a crash, the test will be marked as a failed test and the next test will automatically be executed. This allows an entire suite of tests to be run with a single command in an automated fashion. Unit tests are written mostly like any other class, module, or function in Monkey C, but have the following requirements: Tests methods must be marked with the :test annotation
 Test methods must take a Test.Logger object
 Tests methods that are not global (part of a test class or custom test module) must be static methods
 
 Here is a simple example of a unit test method: // Unit test to check if 2 + 2 == 4 (:test) function myUnitTest(logger as Logger) as Boolean { var x = 2 + 2; logger.debug("x = " + x); return (x == 4); // returning true indicates pass, false indicates failure } The unit tests include a handy logger with different logging levels for more meaningful error reporting. The sample code above uses a “debug” logging level, but the Logger contains a total of three logging levels that can be used to distinguish between different types of errors in your unit test output: Logger.debug() 
 Logger.warning() 
 Logger.error() 
 
 While unit tests are defined in program source code, they are not included in debug or release executables. Running Unit Tests from the Monkey C Extension
 The Monkey C Extension Test Explorer provides a powerful user interface for executing unit tests on your application. You can initiate the test explorer by clicking on the test tube icon on the left. When you start the test explorer, it will enumerate all tests in the code and list them by the module and class they belong to. You can configure which products you want to test by right clicking on an element and selecting Configure Devices . Hitting the play button on a list element will run that test or the collection of tests contained by that element. The test output will be directed to the Test Results tab next to the terminal section. Running Unit Tests from the Command Line
 If you want to run unit tests on your application, build the app with the --unit-test flag on the build command to compile with unit tests. It’s usually easiest to copy and paste the build command from the Visual Studio Code console and add the unit test flag. Then use the connectiq script in your SDK’s bin directory to launch the simulator from the terminal (no arguments required), and use the monkeydo script in your SDK’s bin directory with the /t flag to run the app with unit tests enabled - monkeydo.bat path\to\projects\bin\MyApp.prg /t You may also supply a function name after /t to run the test associated with a single function. The sample unit test above produces the following output in the console: Device Version 0.1.0 Device id 1 name "A garmin device" Shell Version 0.1.0 \------------------------------------------------------------------------------ Executing test myUnitTest… DEBUG (14:16): x = 4 Pass ============================================================================== RESULTS Test: Status: myUnitTest Pass Ran 1 test PASSED (failures=0, errors=0) Connection Finished Closing shell and port If you want to run tests in your monkey barrel , you can use the barreltest script. It supports the same options as the compiler, but can output a PRG that can be used by the test system. Unit test code will not execute unless the compiler is explicitly told to run unit tests. All test code is automatically removed at compile time when your app is exported for use on devices.


# [Exception Reporting Tool](https://developer.garmin.com/connect-iq/core-topics/exception-reporting-tool/)nMenu Core Topics Error Reporting Application (ERA)
 The ERA tool can be used to view your app’s crashes after it has been released on the store. If your app crashes on a device the error report will be collected and aggregated by the ERA server. These reports can be viewed for up to 30 days after a crash occurs. This tool is available in the bin folder of the SDK. Getting Started
 To launch the graphical ERA tool, either run the Monkey C: Start ERA Viewer command from the command palette of Visual Studio Code or run era.jar from the bin/ folder of the SDK. When first running the tool, the Manage Developers window will appear. To use the tool, you must first add a developer identity. Command Line
 The ERA tool can be launched from the command line to retrieve crashes for a single app. This will output the crashes for the given app in a JSON format. &gt; era [-a &lt;arg&gt;] [-k &lt;arg&gt;] Argument Definition 
 -a &lt;arg&gt; The app UUID to retrieve crashes for 
 -k &lt;arg&gt; Developer key for the given app 
 Adding a New Developer
 The Manage Developers window lists all the known developer identities. In this window, you can add a developer, remove a developer, or get information about a selected developer. You can launch this window by selecting Settings &gt; Manage Developers in the menu. If you add any new apps for a developer identity, they will be fetched the next time the ERA viewer is opened. To add a developer, first click on the + button. This will bring up the Add Developer window. In this window, you will need to enter a developer ID and an optional Default Developer Key. If a default developer key is entered, then any new apps for this developer will automatically be assigned this key. If you use multiple keys for your apps, you can override the default key for each app. To obtain your developer ID search for your apps in the app store and click on your developer name. The URL for this page will contain your developer ID. For example, if the URL is https://apps.garmin.com/en-US/developer/e1683f31–54fe–45d9–9aa8-cba39fe7fd1f/apps then the developer ID is e1683f31–54fe–45d9–9aa8-cba39fe7fd1f. To remove a developer click on the - button. This will remove the developer and all its apps from the ERA tool. To view information about a developer click on the + button. This will bring up the Edit Developer window. Viewing App Settings
 The Manage Apps window allows you to see the apps for all the known developers. You can launch this window by selecting Settings &gt; Manage Apps in the menu. The list of apps is color coded to allow easy identification of an app’s status. Font Style App Status Crashes Viewable 
 Normal Released app Yes 
 Gold Beta app Yes 
 Red Invalid key for the app No 
 Strikethrough App is hidden No 
 In this window you can add additional apps, rearrange the apps, and change an app’s settings. To add new apps, click on the + button to bring up the Manage Developers window. After adding a new developer will download all the apps for them to the ERA tool. To rearrange the order of the apps, click on an app and click on the ∧ or ∨ buttons. The order of the apps in this window are reflected in the app selection box in the crash report view. To change an app’s settings choose the app in the list and click on the i button. In the Application Settings window you can change the developer key used for this app as well as hide the app from the drop down box in the crash report view. The app’s developer key will override the default developer key set for the developer. If the Hide this app box is checked then the app will not be shown in the crash report view app list. Viewing Crash Reports
 The crash report view allows you to view all uploaded crash reports for an app in the last 30 days. At the top of this window you can select which app’s crash reports to view. After selecting an app the latest reports will be downlaoded from the server. In the left pane of the window a list of crash reports will be shown. Each unique crash will be identified by file name, function, and line number where the crash occurred. Choosing a crash in the left pane causes the details for the crash to be shown in the right pane. At the top of the right pane the Fixed checkbox can be used to indicate that this particular crash has been fixed. The fixed status will persist across application runs and SDK upgrades. Font Style Crash Status 
 Normal Crash has been viewed. 
 Bold Crash has not been viewed. 
 Strikethrough Crash has been marked as fixed.


# [Profiling](https://developer.garmin.com/connect-iq/core-topics/profiling/)nMenu Core Topics Profiling Applications
 The Connect IQ profiler captures time spent in total within a function and for the code within a function, and lets you examine the different call stacks profiled. The profiler is integrated into the simulator, and the devices will allow hardware profiling as well. Profiling from the Simulator
 To launch the profiler from the Simulator, go to File -&gt; View Profiler . You will see the following: When you reach the point in your application you wish to profile, hit the “Start” button to begin data collection and hit “Stop” to finish. The data will then display in the profiler window: The data collected is as follows: Name Description Notes 
 Function The function signature being called 
 Total Time (us) The total time executing the function in microseconds. This includes all calls during the capture duration. 
 Actual Time (us) The time spent within the function in microseconds. This includes all calls during the capture duration, but&nbsp;ignores time spent calling other functions. 
 Average Time (us) The average amount of time per call spent in the function in microseconds This is the average of the time to execute the function 
 Call Count Number of times the function was called during the sample period 
 Call Stack Indication of which functions invoked the sampled function 
 If you only want to sample for a period, you can set a sample period in Profiler -&gt; Settings . This will automatically stop the profiler after the specified period. Profiling on the Device
 You can profile your app on device by compiling the app with the -k option. To do this in Visual Studio Code, edit the workspace settings edit the Monkey C Compiler Options: After you do that, use Monkey C: Build for Device to create an executable. After you side load and run the program, a file named &lt;appname&gt;.PRF will be generated in the GARMIN\APPS\LOGS folder. You can load the PRF file into the simulator profile tool for analysis using the Load button in the profiler window. Best Practices
 You can re-sort the sampled functions based on the total, actual, and average time spent as well as call count. Each can have value in identifying performance bottlenecks. For example, a function that has a low average time but is repeatedly called can sometimes cause performance bottlenecks. See what functions your application are spending the most time running and use that to focus your optimization efforts.


# [Publishing to the Store](https://developer.garmin.com/connect-iq/core-topics/publishing-to-the-store/)nMenu Core Topics Publishing to the Connect IQ Store
 We’re glad you want to develop for Garmin devices, and we want you to be successful. Be sure to review our guidelines and keep them in mind as you develop your apps. Once your apps are fully tested and ready to go, you can publish and promote your apps to the Garmin Connect IQ App Store. Here’s how to prepare your apps for submission. Make sure the manifest file specifies all products supported by the app
 Use the Monkey C: Export Project command to generate an IQ file, which will contain binaries for each supported device
 Upload the app to the App Store
 Check Supported Products
 It is easy to quickly check the products supported by an app by viewing the manifest XML file in the project root: &lt;iq:products&gt; &lt;iq:product id="fenix3"/&gt; &lt;iq:product id="vivoactive"/&gt; &lt;iq:product id="fr920xt"/&gt; &lt;iq:product id="epix"/&gt; &lt;/iq:products&gt; Exporting the App
 Launch the Export Wizard with the Monkey C: Export Project command in the command palette. After setting the export destination folder the Monkey C extension will generate the .iq file of your project. Publishing the First Version
 To upload the IQ file to your developer account, start by visiting the Submit an App page of the Garmin Developer site. Click on the Submit an App button to fill out the form shown below: Once the IQ file has been validated, add in a description, screen shots, and other details about your app: GDPR
 In April of 2016, the EU Parliament passed the General Data Protection Regulation (GDPR), an act that was designed to harmonize data privacy laws across the European Union (EU). The GDPR provides requirements for the lawful processing of EU Personal Data, including requirements related to data privacy, consent, and digital services. GDPR generally applies to the processing of EU Personal Data, and it may apply to you or your company even if you are not in the EU. Data protection authorities may issue fines up to 4% of annual global turnover or €20 Million, whichever is greater, for non-compliance. . This isn’t legal advice and we encourage you to consult with your legal counsel for guidance. Connect IQ is a global platform, and, as stated in the Connect IQ license agreement , developers are responsible for their apps’ compliance with all applicable laws, including those related to data protection and privacy. Specific responsibilities related to privacy can be found in Section 2 of the Connect IQ license agreement . Developers should review the GDPR to determine what obligations they may have under the GDPR. These obligations may include the following: Asking for consent for collection of personal data.
 Providing access to information on what personal data concerning them is being processed, where and for what purpose.
 Providing access to any personal data collected from them free of charge.
 Ability for a user to erase their presence entirely within your product, including the ability to halt third party processing of personal data.
 
 If your solution collects personal data in any way, including using the Communications permission to collect or retain personal data (potentially in conjunction with Sensor , Sensor History , or Position permissions) or using any other mechanism, you are responsible for ensuring that your solution is in compliance with GDPR. Approval Process
 After your app is successfully uploaded to the app store, the Connect IQ team will review your submission. Aside from special circumstances, such as national holidays, reviews are completed within 72 hours. If you indicate your app uses one or more ANT+ profiles, an additional 48 hours is typically required to complete ANT+ certification. Once certification is complete, we’ll provide ANT+ branding information and a link to the ANT+ Directory to add to your app’s description on the store. While approval is pending, your app will not appear on the Garmin Connect App Store, but you will be able to preview your app and download it yourself for testing. Once it’s approved, you will receive a notification and it will appear on the Connect IQ App Store for all users to download and load to their devices! If for some reason your app is rejected, don’t despair! The Connect IQ team will provide specific reasons for the rejection via email, and may work with you to resolve issues. The app will continue to be available for you to update as needed and re-submit for approval, but it will not be displayed on the Connect IQ App Store until approved.


# [Beta Apps](https://developer.garmin.com/connect-iq/core-topics/beta-apps/)nMenu Core Topics Beta Apps
 Connect IQ beta apps allows developers to test app settings and Garmin Connect integration in production without releasing the app. Uploading a beta app will let you stage your app in production. To use this feature, you will need to create an alternate app id in your manifest using a UUID creator . Beta apps will show up in your uploaded apps, and you can download them to your Garmin device. Once downloaded you can edit app settings in Garmin Connect and Garmin Express and test your developer fields in Garmin Connect. After you upload the beta app, you can update the beta version as many times as you want. When you are ready to release the app, change the app id to your production version in the manifest and upload it without checking the “Beta App” checkbox. Note that the app will have a separate store identifier from your final app, and URLs to the beta will not be visible outside of your account.


# [Trial Apps](https://developer.garmin.com/connect-iq/core-topics/trial-apps/)nMenu Core Topics App Trials
 Since API level 2.3.0 The app trials feature allows developers to enable a special “trial” mode for their app. Enabling trial mode is accomplished by adding a new tag to the manifest under the application tag as follows: &lt;iq:application entry="CommExample" id="a3421feed289106a538cb9547ab12095" name="AppName" launcherIcon="LauncherIcon" type="widget" minSdkVersion="1.3.1"&gt; &lt;iq:trialMode enable="true"&gt; &lt;iq:unlockURL&gt;https://a.custom.unlock.url.info&lt;/iq:unlockURL&gt; &lt;/iq:trialMode&gt; &lt;/iq:application&gt; The unlock URL provides an endpoint for the app store to redirect the user to in order go through whatever you want your app “unlock” process to be. The app store will only accept secured HTTPS-URLs when uploading your iq-file. Also make sure that the enable-attribute of the trialMode tag is set to “true”. The app trials feature is not supported for watch faces. Trial Mode Functionality
 Developers can query the AppBase.isTrial() method to determine if trial mode is active for their app, which can be used to trigger special trial-mode functionality. App trials can also be time-based. The method AppBase.getTrialDaysRemaining() should be overridden if you wish to support a time-based trial. getTrialDaysRemaining() must return a Number that represents how many days are remaining in the trial, or null if time-based trials are to be disabled. If 0 is returned, the app will be prevented from running as the trial will be considered “expired”. By default, when an app is in trial mode, the system will push special trial notifications to the use either to inform them of how many days remain in their trial (if you’ve overridden getTrialDaysRemaining() to return a non-null value), or more generally that trial mode is active. If you do not wish for these notifications to be displayed to the user, you can override AppBase.allowTrialMessages() to return false . Trial App Server API
 Once the app is available in the store, the user can unlock the app by clicking on the unlock button in the store. At this point, the app store will redirect to the provided unlock-URL, adding these parameters to the URL: Parameter Name Description 
 callbackUrl The URL that has to be called back when the unlock-process on your side successfully finished. 
 appUnlockRequestId The app store’s internal unlock-ID which can be stored by the app-developer as reference. 
 appPageUrl The app details page of the app to be unlocked. You should redirect to this page after a successful call to the callback-URL, and ask the user to download the unlocked app for his desired device. 
 So this is what a typical/complete call from the app store to your unlock-URL will look like: https://your.unlock.url.com?appUnlockRequestId=1fe443e5-e76c-4e1c-b82b-2d084bd4c4fe&amp;callbackUrl=https%3A%2F%2Fapps.garmin.com%2FappUnlock%3FappUnlockRequestId%3D1fe443e5-e76c-4e1c-b82b-2d084bd4c4fe&amp;appPageUrl=https%3A%2F%2Fapps.garmin.com%2Fen-US%2Fapps%2Fbf1d944a-8a54-41fa-b7b0-24e651dc88e1 Both the callbackUrl and the appPageUrl will be passed in URL-encoded form. How to use the callbackUrl 
 The callbackUrl -endpoint is secured and can only be used with a (one-legged) OAuth1-signed request. For this you’ll need to obtain your individual set of key/secret credentials from the app store’s “Developer Dashboard”: With these credentials you simply create a standard OAuth1-request and fire it to the callback-URL. (Using a framework which generates all the necessary OAuth-HTTP-Headers is recommended.) A straightforward Java example (using the Signpost-library, and Apache’s HttpClient) would look like this: HttpGet request = new HttpGet("callbackUrl"); OAuthConsumer consumer = new CommonsHttpOAuthConsumer("yourKey", "yourSecret"); consumer.sign(request); HttpClient client = HttpClientBuilder.create().build(); HttpResponse response = client.execute(request); System.out.println("Return code: " + org.springframework.http.HttpStatus.valueOf(response.getStatusLine().getStatusCode())); The following return-codes can be expected: Status Code Status Phrase Description 
 200 OK Everything worked just fine; the app got marked as “unlocked” for the user. 
 202 Accepted When making a successful test-request (see below). 
 401 Unauthorized When the authorization (OAuth) was incorrect. 
 404 Not Found When the requested unlock item was not found. 
 409 Conflict When an app is already being marked as unlocked in the app store. 
 410 Gone When an app is orphaned (e.g. because the app changed ownership due to GDPR). 
 510 Internal Server Error When an unexpected error occurred. 
 You can test your OAuth-implementation without the need of an actual unlock-request. Just make a signed call using your credentials and “test” as appUnlockRequestId . https://apps.garmin.com/appUnlock?appUnlockRequestId=test When receiving a 202, you can be sure that your OAuth-handling is working.


# [Requesting Reviews](https://developer.garmin.com/connect-iq/core-topics/requesting-reviews/)nMenu Core Topics Requesting Reviews
 As a developer, you want your users to review your apps after they’ve had positive experiences. Ideally this would be a low-friction experience to maximize the number of users who leave positive reviews. For compatible devices, the steps to leave a review are as follows: Request a review token
 Receive a token from the store
 Initiate the review process
 
 Requesting a Review Token
 To prevent user harassment, apps must request permission from the app store to perform a review request. The app store validates a number of factors, including if you have recently requested a review from a user and if the user is using the most recent version of the app. The token request can be made with the WatchUi.makeReviewTokenRequest() call. This call is asynchronous, and you must provide this call with a Lang.Method callback to capture the response. Receiving the Token
 When the server responds to your review request, your callback will be invoked with the server response code and optionally the review tokens. The response codes are as follows: Response Description API Level 
 REVIEW_REQUEST_STATUS_GRANTED Request is granted, and token has been provided 4.2.0 
 REVIEW_REQUEST_STATUS_DENIED User does not meet review requirements 4.2.0 
 REVIEW_REQUEST_STATUS_FAILED Cannot make review request at this time 4.2.0 
 If you receive a token it should be valid for the current day. Requesting the Review
 When you are ready for the user to review the app, you can use WatchUi.startUserReview() with the valid token from a token response. This will transition the user to the review flow. Tips
 Keep track of the user’s positive and negative experiences, and request reviews only if the user is having a net positive experience with the app. Harassing the user to leave positive reviews can lead them to leave negative reviews, which defeats the purpose of asking them to review your app.


# [User Experience Guidelines](https://developer.garmin.com/connect-iq/user-experience-guidelines/)nMenu User Experience Guidelines Designing for the Garmin User
 The Connect IQ system allows third party developers to bring their design and experience to Garmin products. This document will go over some of the guidelines of designing an app for a Garmin audience. Customer Focused Devices
 Unlike other platforms, Garmin products are targeted at the customers they serve: The Edge series are the best cycling computers on the market.
 The fēnix® series is the best wearable for the outdoors.
 The Forerunner® series is the best wearable for runners and triathletes.
 The vívoactive® and Venu® series brings the best of Garmin to an active lifestyle audience.
 The Oregon®, GPSMAP®, and Rino® series are the best handheld mapping products on the market.
 
 Think about these distinctions when choosing which products to support. The Wearable User
 One of the synonyms of the word “watch” is “to observe.” When designing smartwatch apps, keep in mind that watches are best when they are used to observe. Great wearable apps stay out of the user’s way and keep the interactions to a minimum. Instead, give the user fast access to the information and key interactions they care about. Remember that wearables are the most personal computing platform ever created. Garmin devices have access to several different sensors, including GPS, heart rate monitors, compass, accelerometer, barometer, gyroscope, as well as the ANT+ network. Let the user see information about themselves in interesting ways. The Cycling User
 The Edge user needs their cycling computer to function flawlessly while they ride, regardless of duration or weather conditions. Create apps that integrate with the existing Garmin cycling experience rather than replacing the experience with your own. Users won’t like it if your apps lower their battery life, no matter how great your experience is. The Outdoor User
 The outdoor user wants to be outdoors and not focused on your app experience. Provide them with an experience that complements what they want to do. Design an autonomous experience that does not assume you are in a connected environment.


# [Design Principles](https://developer.garmin.com/connect-iq/user-experience-guidelines/design-principles/)nMenu User Experience Guidelines Key Design Principles
 Designing applications can be broken down into four steps: Understanding what you are building
 Developing the concepts
 Designing workflows and interactions
 Incorporating the visual design and product personalities


# [Understanding What You Are Building](https://developer.garmin.com/connect-iq/user-experience-guidelines/understanding-what-you-are-building/)nMenu User Experience Guidelines Understanding What You Are Building
 Now that you have identified who your users are, the next step is to identify what they are trying to do. They are using your app to achieve a particular outcome. Focus on the “jobs” they are “hiring” your app to do. The jobs could range from “I want to see the time quickly and clearly” to “I want a quick glance of my key stats without sorting through unwanted information.” Ask yourself, what is the key information that you want to convey to the user? Apps on Garmin devices should be focused on presenting key information to the user quickly and with minimal interaction. Save deep dives for mobile apps or the web. What are the necessary features? Once again, keep it simple. The usability of any design is relative to two variables: Users and tasks. Apps on Garmin devices should be focused on allowing the user to accomplish key tasks quickly with minimal interaction. Save deep dives for mobile apps or the web. Common Use Cases
 Garmin is a trusted brand with athletes, with an audience that extends from aspirational to endurance. Connect IQ allows you to bring your brand or solution in front of this large audience. Customized Watch Faces
 The watch face is not only the home screen of the Garmin wearable experience but also an opportunity for the user to express themselves. Custom watch faces allow you to bring your brand and creativity to our customers. Third-Party Sensors
 Connect IQ allows third-party sensor makers to connect with Garmin devices. Sensors can then record extra activity information that can be displayed in Garmin Connect. Integrating Workout Content
 Connect IQ allows developers to work their content into the Garmin activity experience. New Activities
 Garmin supports a wide range of activities, but Connect IQ developers can let users records workouts not supported natively on the devices, such as dance, in-line skating and more. Extending your Services to Garmin Customers
 Garmin wearables are meant to be worn 24/7. Connect IQ apps allow our users to access your services at a flick of the wrist. Music Services
 Connect IQ allows music content providers to extend their services to Garmin users. Content can be downloaded over Wi-Fi and securely stored on our devices for later playback by users. You can enforce your playback tracking and subscription management within the app. Garmin as Part of a Broader Solution
 Sometimes it’s necessary to architect a solution that involves a variety of technologies. With their programmability, sensors and connectivity options, Connect IQ-compatible devices can often serve as a part of a larger solution.


# [Developing the Concepts](https://developer.garmin.com/connect-iq/user-experience-guidelines/developing-the-concepts/)nMenu User Experience Guidelines Developing the Concepts
 With an understanding of the problem you want to solve and who you are solving it for, you can focus on a design that meets these needs. Now we can begin looking at the important content and workflows to achieve the user’s goals. App Types
 Unlike other platforms, Connect IQ apps have context specific types that define their location in the device interface, as well as their interaction model. Example Description 
 Watch faces are the home screen of Garmin wearables. They do not accept direct user input, but they can have settings that are editable within the Connect IQ mobile app. On devices with API level 3.2, watch faces can have a launchable on-device configuration flow. 
 Data fields are plug-ins that can display information within a Garmin activity. After they are installed, the user can place the data field anywhere within the page loop of their activity. To protect the Garmin experience, data fields aren’t allowed to take input. They can have settings that are editable within the Connect IQ mobile app. On devices with API level 3.2, watch faces can have a launchable on-device configuration flow. 
 Widgets are a carousel of apps that the user can quickly navigate through. The base page has limited input but can push pages to let the user go deeper for more information. 
 In 2019 Garmin introduced Glances . Glances are a scrollable list of key data, and each list item has a displayable metric. The user can select any glance to dig in further. Both widgets and glances will time out after a period of inactivity. 
 Audio content providers function as plug-ins to the music player. The user can select them to be their audio source. When the user launches the audio player, they will have access to the media controls that communicate with your app, but the user can perform deeper interactions by going to the media player sub-menu and tapping on your app icon. From here, you can add flows for downloading and managing content and beginning playback. 
 Device apps are launchable experiences that do not time out. Device apps can take input, manipulate the page stack and communicate with the cloud and with wireless sensors. The user exits them by backing out of the main page. On devices with API level 4.0, you can add a glance for device apps. Examples of device apps include apps that record activities, games and apps that integrate rich content onto the device. 
 The app type you choose should be based on the problem statement of the user. Is your goal to augment the workout experience? You should make a data field. Are you looking to let the user monitor a metric outside of an activity? You should use an app. Does your app have information that updates throughout the day? Add a glance to your device app. The app type impacts your workflow by placing limits on the potential workflows: Watch faces and data fields do not take user input, but the user can enter an app-defined settings flow on the device or can edit settings in mobile.
 Data fields, with permission from the user, can display alerts if the user achieves a milestone.
 Data fields can record additional information into an activity file.
 The base page of a widget has limits placed on the inputs to allow user navigation of the carousel. On button products, this is typically done with the up and down buttons.
 
 Connect IQ Apps and Information Architecture
 Connect IQ apps are typically “information forward,” meaning the key information is presented up front, and there are limited interactions for more information: Data fields always display the key information. Any customized setup flow requires the user to go to the data field settings.
 Widgets should always display the core information on the base page. They can allow the user to enter a flow to see more information.


# [Designing Workflows and Interactions](https://developer.garmin.com/connect-iq/user-experience-guidelines/designing-workflows-and-interactions/)nMenu User Experience Guidelines Designing Workflows and Interactions
 Once you have your information architecture established, you can begin converting it into a workflow. Hierarchical Navigation
 The traditional Garmin user interface is hierarchical, where views are stacked based on the user’s selections. Every device has a standard behavior for navigating the selections and backing out of the hierarchy, but these standard behaviors can be different from product to product. Try to limit the depth of your navigational hierarchy. Focus on quick selections and not forcing the user to make multiple choices. Behaviors
 The following abstract behaviors apply to all Garmin devices. Select Action to pick an item out of a set. 
 Start/Stop Action to mark the beginning or ending. On button products, this is often the same as select. 
 Next/Previous Action to either pick the next or previous item or navigate to the next or previous page in the page loop. On button products, this is often the up/down buttons. 
 Back Action to back out of an app screen or view and return to the previous screen or view. 
 Menu Action that brings up the settings menu for the application. 
 Common Patterns
 Take advantage of the following patterns found on Garmin devices when making the conversion from information architecture to workflow: Example Pattern 
 Page loops are carousels of views. When the user is in a page loop, the user interface presents a set of pages of information that provide different data and insights to the user. There are standard behaviors for going to the next and previous pages. Going past the last page typically loops the user back to the first page. 
 Dialogs are typically a modal screen with a message that the user must confirm reading to continue. These can be used for error messages, instructions or other forms of guidance. 
 Progress bars tell the user to wait for an asynchronous action to be completed. There are two styles of progress bar: A standard progress bar that counts from 0% to 100%, and a busy progress bar for when the completion time cannot be quantified. 
 Confirmations are pages that confirm a user action. They can be used to confirm a decision by the user or add a point of friction if the user is exiting a flow. 
 Selection menus allow a user to choose between two or more items. The items are presented on a one-dimensional list with optional iconography. 
 A Settings menu is typically available from the base view of the application via the menu behavior. The settings menu typically allows the user to alter global settings for the app. 
 Interactions
 When mapping out your workflow, it’s inevitable that you will face some decisions that cannot be solved by common UI patterns. At this point, you’ll need to think about the best way for a user to make the decision on the device. Garmin designs products with this use case in mind, and one key consideration is if the product is touchscreen or push-button. For those who have primarily developed in the mobile space, physical buttons can be foreign. Touchscreens function well in indoor environments, but they can be difficult to use with gloves, when wet or when your body is in motion. For these situations, the tactile feedback of buttons makes for a better experience. Connect IQ does allow for separate, tailored experiences for touchscreens versus push-button devices, but it also provides tools that allow a single implementation for both. Ultimately, it is up to you to choose if you want to tailor your app’s interaction model to these different input patterns or not. Input Patterns
 Here are the common input patterns for Garmin devices: The five-button configuration has three buttons on the left and two buttons on the right. The buttons perform the following actions: Top Left – Press to toggle the backlight. Press and hold to access the controls menu.
 Middle Left – Press for a previous/up behavior. Press and hold for a menu behavior.
 Bottom Left – Press for a next/down behavior.
 Top Right – Press for a select behavior. Commonly used for the start/stop action on Garmin activities.
 Bottom Right – Press for a back behavior.
 
 The touchscreen two-button configuration combines a touchscreen with two navigation buttons: The top button is a start/stop button. Press and hold to access the controls menu.
 The bottom button performs the back behavior. Press and hold for a menu behavior.
 
 The following actions are also standard: Swiping up will perform the previous/up behavior.
 Swiping down will perform the next/down behavior.
 Menus can be dragged and flicked with the touch screen.
 Tapping on a screen item performs a select behavior.
 Swiping right to left performs a back behavior.
 
 The touchscreen one-button edge configuration combines a touchscreen with a power button. All behaviors are done via the touch screen: Swiping left to right will perform the previous/up behavior.
 Swiping right to left will perform the next/down behavior.
 Menus can be dragged and flicked with the touch screen.
 Tapping on a screen item performs a select behavior.
 Tapping the on-screen back button performs the back action.
 Tapping the on-screen hamburger menu performs the menu action.
 
 Mobile App Settings
 Connect IQ allows the developer to have a configurable set of editable app settings available to the user in the Garmin Connect™ mobile app, the Connect IQ™ mobile app or in Garmin Express. These settings can have a label and a prompt. The value can be any of the following: Boolean
 Number
 Text
 Phone
 Email
 URL
 Date
 Password
 
 App settings can be a way to make your app more configurable without adding a complicated on-device UI. Connect IQ apps can be informed when the user changes their settings in mobile to provide instant feedback. Mobile Authentication
 Cloud services require users to authenticate themselves, most often with a username and password. On mobile devices, these flows are very easy, but on Garmin devices with limited input capabilities, entering credentials can be a challenge. Connect IQ has a standard authentication method that allows the device to hand authentication over to the mobile device. The app can choose to hand authentication either to the Garmin Connect mobile app, or in System 5 to the Connect IQ store mobile app. This mechanism requires the cloud service to support OAUTH2 authentication via a web browser view. At the point where you need the user to authenticate, include a dialog that directs the user to open the appropriate app on their phone. If the user has notifications enabled for the appropriate app on their mobile device, they will receive a mobile notification, as well. When they enter the mobile app, they will be prompted to begin authentication on their phone. When credential entry is complete, the web view will close, and the credentials will be sent to the Connect IQ app. At this point, your Connect IQ app should continue with its workflow. Best Practices
 Here are some best practices for defining interactions in your app: Keep input to a minimum. Garmin devices offer a wealth of information to the user. All this information should be available within three to four interactions with the device. The more the user is interacting with an app the less they are paying attention to the task at hand.
 Stick with the up/down page loop model (versus left and right) for the best experience on both. Horizontal page loops do not map well to the button configuration.
 If you’d like to have on-screen buttons for your touchscreen app, make sure the button actions are intuitive and obvious.
 If your app is intended to be used during physical activity, try to limit the number of interactions in your app. Let the user focus on their activity and not your application.
 Use text entry sparingly on device. Instead, use mobile app settings or generate useful default strings that the user can change later in mobile or on web.
 Use the native menus, confirmations and progress bars. They will automatically have the product personality, and users will already be familiar with the interactions.
 The back behavior is one of the most common behaviors on Garmin devices. Avoid modifying this behavior in your app.
 Don’t require the user to use mobile app settings before they can use your app. The app should be usable without requiring the user to enter the settings flow.
 Do not depend on the mobile notification for your authentication flow. Always give clear guidance directing the user to the appropriate mobile app or website within your Connect IQ app.


# [Incorporating the Visual Design and Product Personalities](https://developer.garmin.com/connect-iq/user-experience-guidelines/incorporating-the-visual-design-and-product-personalities/)nMenu User Experience Guidelines Incorporating Visual Design and Product Personalities
 Now that we have established our workflow and interaction paradigms, we can focus on incorporating visual design. Your visual design needs to combine both your brand and the personality of the product you are designing for. Product Personality
 Garmin products have different personalities, depending on the target audience of that product, the core usage of the product, the graphics and industrial design of the product and the hardware and technology used in the product. Screen Technology
 Many Garmin products use a screen technology known as Memory in Pixel (MIP). MIP displays are very low power. They depend on reflecting light, so they look brightest outdoors. The display technology has a limited color palette: Some offer up to 64 colors, while others offer only eight or even black and white. Most Garmin products using MIP displays offer a 64-color palette: 0xFFFFFF 0xFFFFAA 0xFFFF55 0xFFFF00 0xFFAAFF 0xFFAAAA 0xFFAA55 0xFFAA00 
 0xFF55FF 0xFF55AA 0xFF5555 0xFF5500 0xFF00FF 0xFF00AA 0xFF0055 0xFF0000 
 0xAAFFFF 0xAAFFAA 0xAAFF55 0xAAFF00 0xAAAAFF 0xAAAAAA 0xAAAA55 0xAAAA00 
 0xAA55FF 0xAA55AA 0xAA5555 0xAA5500 0xAA00FF 0xAA00AA 0xAA0055 0xAA0000 
 0x55FFFF 0x55FFAA 0x55FF55 0x55FF00 0x55AAFF 0x55AAAA 0x55AA55 0x55AA00 
 0x5555FF 0x5555AA 0x555555 0x555500 0x5500FF 0x5500AA 0x550055 0x550000 
 0x00FFFF 0x00FFAA 0x00FF55 0x00FF00 0x00AAFF 0x00AAAA 0x00AA55 0x00AA00 
 0x0055FF 0x0055AA 0x005555 0x005500 0x0000FF 0x0000AA 0x000055 0x000000 
 The 64-color palette The Forerunner 45 and 55 use an eight-color palette: 0xFFFFFF 0xFFFF00 0xFF00FF 0xFF0000 0x00FFFF 0x00FF00 0x0000FF 0x000000 
 The eight-color palette The other common screen technology for Garmin devices is LCD or AMOLED displays. These offer many more colors and can look vibrant, but they also use more power in outdoor use cases. Visual Theme
 Different Garmin devices have different visual themes. Some devices go for dark text on light backgrounds, while others use a light text on a dark background: Light on Dark Dark on Light 
 
 There can be reasons besides aesthetics for these decisions. On MIP devices, dark on light is context-specific and is used predominately during activities to provide better contrast. Because the screen is reflective, it achieves the best contrast in outdoor environments with a white background and black text. On Edge products, the visual theme changes based on the time of day. These devices use a white background and black text during daylight hours for best contrast. At night, they have a black background and white text to be easier on the eyes in low-light use. Devices with AMOLED or LCD screens use a light text on a black background. By having a dark visual theme, devices with AMOLED displays can extend battery life while still incorporating beautiful imagery into the user interface. Typography
 There are two kinds of system fonts on a Garmin device: the text font and the number font. The text font should be used for textual data and labels, while the number font is used for numerical data. The system fonts that come with the device have been tested for readability for the device and should be used whenever possible. Connect IQ allows developers to import a typeface into an app. These typefaces only allow for one-point size to be imported. Custom typefaces should be used to give a visual accent or to add a branding element to your app. Headers and Footers
 Within the app, it is common to have a header portion at the top of the view. The header can have a small string of text or iconography to give the user context as to where they are within the application. On MIP products with fewer colors, it is common for the header to be a solid color. On LCD or AMOLED displays, the header should be a gradient that fades into black. Imagery
 On devices with LCD or AMOLED screens, subtle imagery on backgrounds can add a visual accent to pages. Best Practices
 When designing across multiple products, show the same content regardless of display size. Rely on standard patterns and system fonts for content to scale appropriately to the display size and resolution.
 Put the most Important information front and center. Device applications are not meant to be the focus of the user’s attention. Clearly place the relevant information on screen, so the user can return to what they need to do quickly.
 If you can only choose one, focus on light-on-dark themes. A light-on-dark theme will still look acceptable on devices with a default dark-on light display. On the other hand, a dark-on-light them will look out of place on an AMOLED display. Dark-on-light themes are best reserved for apps intended for outdoor activities on MIP displays.
 Identify a theme color that speaks to your brand, and use that in your iconography and headers.
 The system fonts have been tested for readability, but you will have varying typeface sizes across devices. Keep any text on device short, or have it flow across multiple pages.


# [Entry Points](https://developer.garmin.com/connect-iq/user-experience-guidelines/entry-points/)nMenu User Experience Guidelines Entry Points
 Connect IQ exposes multiple ways for developer content to integrate with the device. Based on the app type, there may be multiple touchpoints where your app will appear. Here is a comprehensive list: Activity Data Field Screen ( Data fields ) – In native Garmin activities, the user has a page loop of metrics available to them. Users can edit the contents of the pages for the activity. One option is to add a Connect IQ data field as a metric in a page. Once added, the data field can render itself inside of its designated area. On API level 3.2 products and above, the user can configure settings for the data field on the device. This launches into an application-defined workflow. Activity List ( Device apps ) – From the home page of the device, the user can get to the list of supported activities either by pressing the start button or tapping the appropriate place on the touchscreen. Connect IQ apps are listed along with the natively supported Garmin activities. The user can edit the list order on device or in the Garmin Connect mobile app. When a user launches an app from the activity list, the app will run until the user explicitly backs out from the first page. Glance List ( Device apps, Widgets ) – Glances are an evolution of the widget concept. The information of a widget is condensed into a glanceable item, and the collection is presented to the user as a list. Selecting an item from the list launches into the experience. The user can exit by backing out of the base page, but after a period of inactivity, the system will terminate the launched app, as well. On API level 3.1 products, widgets were the only app type to support glances. In API level 4.0, device apps were given the ability to support glances, as well. Media Player ( Audio content providers ) – On products that support music, users can select a music source. The source can be music files on the device, controlling the music player on their phone or music from the audio content provider’s app. When the user switches to a Connect IQ audio content provider, the initial view is displayed. This gives an opportunity to provide onboarding, including authenticating into a cloud service and guiding the user to download music. When the user returns to the media player, they will get the media controls and have a way to return to your interface if they want to change playlists or download more content. Watch Face ( Watch faces ) – On Garmin wearables, the user can choose a watch face to run as the home screen, including installed Connect IQ watch faces. When the user returns to the home screen, the watch face application will launch. The watch face does not take user input. Watch faces render in different ways based on what the device supports: MIP standard – The watch face will request an update every minute. When the user gestures to look at the watch face, the watch face will begin requesting updates every second for a short period.
 MIP always active – The watch face will request a full update every minute but will allow a small portion of the screen to be updated every second. When the user gestures to look at the watch face, the watch face will begin requesting updates every second for a short period.
 AMOLED standard – The screen is off by default. When the user gestures to look at the watch face, the display will enable, and the watch face will begin requesting updates every second for a short period.
 AMOLED always active (version 1) – The watch face operates with a burn-in detection mechanism that will prevent any pixel from being enabled for more than four minutes, or for the watch face from using more than 10% of the screen pixels. When the user gestures to look at the watch face, the display will turn on, the pixel limits are disabled, and the watch face will begin requesting updates every second for a short period.
 AMOLED always active (version 2) - The watch face is prevented from using more than 10% of the screen pixels. When the user gestures to look at the watch face, the display will turn on, the pixel limits are disabled, and the watch face will begin requesting updates every second for a short period.
 
 Widget Loop ( Widgets ) – On wearables that have widgets, the widget loop is available by performing the next/previous behavior from the watch face. On cycling computers, the widget loop is available by swiping down from the top of the screen, then swiping right or left or using the navigation arrows to move between widget pages. The user can use the next/previous behaviors to navigate the widget loop if the widget is on the base page. Other interactions can be captured by the widget and used to push pages onto the page loop. After a period of inactivity, the widget will be terminated, and the user will return to the home screen. Best Practices
 When designing a widget, make sure to design both a launch from widget (full screen) and launch from glance (list item to full screen).
 When launching from a glance, the base page of your widget/app will not have the input restrictions when launching as a widget.
 On certain devices, device apps can be launched from a glance. If your app has a trackable metric, consider creating a glance for it.


# [Views](https://developer.garmin.com/connect-iq/user-experience-guidelines/views/)nMenu User Experience Guidelines Views
 Views are full-screen canvases for your information. They can display text, graphics, animations and other content. View Stack
 Garmin devices have limited screen real estate, so you typically do not have multiple views on the screen at the same time. Instead, views are stacked on top of each other. The user uses the back behavior to remove views from the stack. View Transitions
 The Garmin user interface toolkit offers several transitions to animate your views on and off screen. Views can: Immediately appear
 Slide from the left, right, top or bottom
 Blink onto the screen
 
 You can use these transitions to push a page on top of a page, push a page away to reveal the page below, or replace the current page with another one. Use Transitions to Suggest Page Hierarchy
 A common pattern in Garmin apps is to have a primary view of information and allow interaction via a menu hierarchy. When pushing the menus on screen, have them slide in from the right. Then, when the user dismisses them, they can slide away to the right. Use Transitions to Suggest Page Loops
 Another common pattern in Garmin apps is the page loop, where the main screen offers a carousel of information that the user can loop through. With this pattern, either the up/down buttons or up/down swipes allow navigation between the pages. You can use sliding page transitions to give the illusion of this carousel of pages. Interaction Hints
 Sometimes there isn’t enough visual space to present the user with both information and navigation actions. In those cases, you may want to give a hint on what button to press or where on screen to tap to bring up a selection menu: Button Hint Touch Hint


# [Watch Faces](https://developer.garmin.com/connect-iq/user-experience-guidelines/watch-faces/)nMenu User Experience Guidelines Watch Faces
 Watch faces are a fun way to add personality to a Garmin wearable. Compared to other app types, watch faces are limited in scope — they don’t take input and don’t have a traditional UI flow — but they still require multiple considerations. Color Use
 Connect IQ apps use a lot of different screen technologies, and allows you to support all these technologies in a single app. When designing a watch face you may need to consider the appearance in eight colors, 64 colors or with AMOLED displays. Conversely, you can choose to only support the devices that use the technology that works best for your watch face. This will save in the design and implementation phases but constrain your audience. Screen Size and Shape
 Connect IQ wearables come with many different screen shapes, but the most common are round or square with 1:1 aspect ratio. For devices with 1:1 aspect ratio, planning your watch face with relative coordinates can help you design for several devices at once. Custom Fonts
 Custom fonts liven up watch faces. Due to the variety of resolutions, your design should specify a point size to use for every resolution. Low- and High-Power Modes
 Connect IQ watch faces typically operate in a low-power state where the system requests updates every minute. When the user gestures to look at the watch, the system will request the watch face enter a high-power state. During this period, typically 10 seconds, the watch face can enable timers and play animations. Use this time to add some action to your watch faces. Always Active
 MIP watch faces by default update once a minute. High-power mode does allow drawing seconds or a second hand for a period of time, but sometimes the user wants that kind of information available the moment their eyes focus on the watch. Always-active watch faces can perform a partial update of the screen every second. The update must operate under a 20 millisecond time frame, which does not allow updating the whole screen but can allow for an update on a small portion. For example, the seconds area of this watch face (highlighted in pink) could be updated once a second: Always On (AMOLED)
 Devices with AMOLED displays typically disable the display when not in use to save power, but they do allow the user to enable an always-on mode. Because long-term display use affects the battery life and can wear down the display, Connect IQ has special rules for AMOLED always-on mode. When the watch face enters always-on mode, the watch face will only update every minute, and each update is limited to using 10% of the available pixels of the display. In addition, a burn-in prevention mechanism will further guide the use of the display on some devices. Many AMOLED devices have a setting to disable the gesture that returns the watch face to high power mode to save power. To avoid a poor user experience, it is expected that Connect IQ watch faces for AMOLED devices support always-on mode to keep and watch face visible in these cases. Settings
 Watch faces can be configured using either mobile settings or on-device settings. Mobile settings let the user modify a set of app properties. Your app will be notified when they change. On System 4 and above devices, Connect IQ watch faces can have a launchable configuration flow built into the watch face. Watch face configuration is available to the user in the system Watch Face menu, using the same configuration mechanism as native watch faces. From within the settings flow, you can push and pop views to enable configuration. Best Practices
 Garmin users love data. The best watch faces offer a level of customization that allows users to see pertinent information with a pleasing design aesthetic.
 Not all designs can scale to all devices. Before you begin, choose the most important devices to support, and create your design based on their capabilities. This may require two or three designs if you are attempting a watch face that supports eight-color displays, 64-color displays and AMOLED or LCD displays.
 Users enjoy enabling always-on mode on AMOLED devices. If you support AMOLED devices, always incorporate an always-on mode into your watch face design. Here are some guidelines for adapting a watch face for always on:
 Avoid using much white or blue. Consider using light gray instead.
 Use fonts with thin line weights.
 Minimize the use of static elements that never move (e.g., the center post of analog watch hands).
 If you do have static elements, consider moving elements up to four pixels in any direction every minute while in always-on mode.


# [Data Fields](https://developer.garmin.com/connect-iq/user-experience-guidelines/data-fields/)nMenu User Experience Guidelines Data Fields
 Garmin activities typically present the user with a page loop of data field pages. In the activity settings, the user can subdivide the page using a pre-defined set of data field layouts. In each subdivision, the user can assign a data field that displays a metric relevant to the activity. Custom data fields allow developers to extend the Garmin workout experience. Your data field can compute new metrics, read data from sensors over ANT or Bluetooth Low Energy, show alerts, and record information to Garmin Connect. Handling direct user input is reserved for the activity experience itself. The inputs for your data field should come from the activity, sensors or the configuration. Data Field Layouts
 When designing your data field, you cannot assume the user will choose to give your data field a full-screen presentation. Some users like having multiple pages with one or two data fields, while others will fill their data pages full of information. Your data field should support visually filling a full page, while also providing a summarized view if placed in a smaller presentation. Obscurity
 Based on where the user places your data field on a page, part of the visual area may be obscured by the curvature of the screen. This could reduce your visual area for labels or other elements of your design. Connect IQ will communicate if the top, left, right or bottom of your visual area is obscured by the curvature. Based on this, you can rearrange your visual layout to adapt to the placement, for example by moving labels to the bottom to give them the most visual area. Settings
 Data fields are not allowed to take direct user input, but the user can configure them using mobile and on-device settings. Mobile settings let the user modify a set of app properties. Your app will be notified when they change. On System 4 and above devices, Connect IQ data fields can have a launchable configuration flow built into the watch face. Data field settings are available from the Connect IQ Settings menu item in the activity settings menu. From within the settings, flow you can push and pop views to enable configuration. Alerts
 Because data fields are placed in a page loop, they are not guaranteed to be visible during a workout. If you want to alert the user to an event, you can push a full-page alert to the screen. The alert is dismissible or will auto-dismiss after a period of time. By default, alerts for a data field are disabled. The user needs to go to the activity Settings -&gt; Alerts -&gt; Connect IQ and select the app they wish to enable alerts for. Recording Information to Garmin Connect
 Data fields can define and record up to 16 metrics in an activity file. These metrics can be recorded up to once a second as part of the activity, as part of the lap information or as part of the summary information. If the information is recorded as part of an activity, it can be displayed as an area chart in Garmin Connect. In addition to the data, you also have control over the translatable label, the translatable metric name and the color of the area chart. Best Practices
 If your data field shows a single metric, implementing a SimpleDataField will handle all the labeling and layout logic for you.
 Use the on-device settings flow for authentication, pairing with wireless sensors and configuration flows.
 For recorded data, choose a color that matches your brand but works with the color schemes of Garmin Connect activities in both web and mobile.


# [Menus](https://developer.garmin.com/connect-iq/user-experience-guidelines/menus/)nMenu User Experience Guidelines Menus
 The app can create a menu with a default presentation style that matches the device’s look and feel. If you want to match your branded look and feel, you can use a custom menu instead. By default, menus loop from the last element on the list back to the first but can also continue into a new menu. If you have a very long list of options, consider ways to sort in a predictable and meaningful way, such as alphabetically. Or consider grouping into related categories. Users would then see the category name in the parent menu, and then can select a “parent” option to see the options in a “child” menu. Selection Menu
 Use the selection menu when there is a selectable list of items for the user to navigate. A header and footer at the top and bottom of the menu can give context to the selection. Optional use of icons or images is recommended to highlight the meaning of the selection: For graphic guidance, including the use of color, fonts and icons, see the Product Design Appendix. Settings Menu
 Typically, a menu behavior from the base page will provide access to a settings menu. Settings menus allow users to customize global settings within your application. A header and footer at the top and bottom of the menu can give context to the selection. For graphic guidance, including the use of color, fonts and icons, see the Product Design Appendix. Best Practices
 Group menus into categories as needed. A general rule of thumb is to try to have a maximum of seven items in each list.
 Use toggles for options with on/off choices in settings menus.
 Use checkboxes for multiple selections in settings and selection menus.
 For other selections, provide a secondary menu for users to see all their choices. Show the current selection as subtext in the parent menu list item.
 A common pattern to break up long sets of information is to draw a custom footer element that hints at what lies beneath, and then switch to a new menu if the user goes past the end.


# [Confirmations](https://developer.garmin.com/connect-iq/user-experience-guidelines/confirmations/)nMenu User Experience Guidelines Confirmations
 Confirmations provide the ability to ask the user a question and get a yes or no answer. Confirmations are usually text only with a way to respond positively or negatively. These are useful when trying to add small bits of friction around big decisions. Best Practices
 Confirmations add friction to the experience, so only use them when the friction is necessary. Do not interrupt the user if it isn’t necessary.
 On native confirmations, the choices may be “Yes” or ”No,” or it may be a visual indication based on the product personality. Design for both.
 Be specific with your dialog, so the user understands the choice they are making. And be sure to phrase it in the form of a yes or no question.


# [Progress Bars](https://developer.garmin.com/connect-iq/user-experience-guidelines/progress-bars/)nMenu User Experience Guidelines Progress Bars
 At points where your app needs to do something asynchronous, you should present an indication that the user needs to wait. Progress bars provide a full-page experience that communicates progress. If you don’t have a known progress end point, you can use an infinite progress mode. Percent Progress Infinite Progress 
 
 Best Practices
 Provide a back behavior in case the user wants to cancel the action.
 Be informative, so the user understands what process is taking place.
 If there are multiple processes taking place one after another, try to represent the progress for these in one progress bar, or use the infinite progress. Use the message to keep the user apprised of status.


# [Map Views](https://developer.garmin.com/connect-iq/user-experience-guidelines/map-views/)nMenu User Experience Guidelines Map Views
 For products with onboard cartography, the Garmin UI allows you to push the native map view to the screen. You can overlay your own graphic elements over the map and change the view of the map to design your UI around it. Points and Polylines
 Maps allow bitmaps to be geo-located on the map to highlight points of interest. Maps also allow polylines to be overlaid for display of courses and boundaries. Previewing, Browsing and Tracking
 Map views can be used in three contexts. A map can be pushed to the screen that previews a given area. In this mode, user input is directed to any interface elements on the screen. When browsing, the user can pan and zoom the map to control the focus areas. Finally, tracking will center the map on the user’s GPS location.


# [Localization](https://developer.garmin.com/connect-iq/user-experience-guidelines/localization/)nMenu User Experience Guidelines Localization
 Garmin devices are available all over the world, and Connect IQ is a global marketplace. A single Connect IQ product may have different localized variants that support different languages or may have languages that have different character sets. Connect IQ allows a single device app to accommodate all of these variations. The Connect IQ tools allows for application resources, including text and graphics, to be overridden based on language. The following languages are supported: Arabic
 Bulgarian
 Czech
 Danish
 German
 Dutch
 English
 Estonian
 Finnish
 French
 Croatian
 Hungarian
 Indonesian
 Italian
 Japanese
 Korean
 Latvian
 Lithuanian
 Norsk Bokmål
 Polish
 Portuguese
 Slovak
 Slovenian
 Spanish
 Swedish
 Russian
 Romanian
 Thai
 Turkish
 Ukrainian
 Vietnamese
 Standard Malay
 Simplified Chinese
 Traditional Chinese
 
 When developing a Connect IQ app, you should consider what is necessary to adapt your app for other countries and languages. Best Practices
 All Connect IQ devices support English, but not all devices support all languages. Supporting only English is not a localization strategy.
 Garmin devices allow the user to customize their preferred units for distance, elevation, height, pace, temperature and weight. Look at their preference before displaying any metric of those types.
 Leave enough space for translated text. The height and width of the text may expand or contract based on which language is displayed. The Connect IQ simulator can be used to test your text in multiple languages.
 Use iconography when possible, but be cautious about the cultural significance of images and colors in different cultures.
 Support multiple presentations of the date based on locale.
 Avoid text entry steps when possible.


# [Forerunner 2018](https://developer.garmin.com/connect-iq/user-experience-guidelines/forerunner-2018/)nMenu User Experience Guidelines Forerunner 2018
 Style Guide
 Devices Descent™ Mk2 / Descent™ Mk2i 
 Descent™ Mk2 S 
 fēnix® 5 Plus 
 fēnix® 5S Plus 
 fēnix® 5X Plus 
 fēnix® 6 / 6 Solar / 6 Dual Power 
 fēnix® 6S / 6S Solar / 6S Dual Power 
 fēnix® 6X Pro / 6X Sapphire / 6X Pro Solar / tactix® Delta Sapphire / Delta Solar / Delta Solar - Ballistics Edition / quatix® 6X / 6X Solar / 6X Dual Power 
 Forerunner® 245 
 Forerunner® 55 
 Forerunner® 745 
 Forerunner® 945 
 Forerunner® 945 LTE 
 MARQ® Athlete 
 
 Descent™ Mk2 / Descent™ Mk2i
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 280 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 280 139 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 89 7 True True True False 
 Field 2 0 91 280 98 5 True True False False 
 Field 3 0 191 280 89 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 94 7 True True True False 
 Field 2 0 96 280 88 5 True True False False 
 Field 3 0 186 280 94 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 139 139 9 True False False True 
 Field 3 141 141 139 139 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 280 69 5 True True False False 
 Field 4 0 211 280 69 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 99 7 True True True False 
 Field 2 0 101 139 78 1 True False False False 
 Field 3 141 101 139 78 4 False True False False 
 Field 4 0 181 280 99 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 139 139 3 True False True False 
 Field 2 141 0 139 139 6 False True True False 
 Field 3 0 141 139 139 9 True False False True 
 Field 4 141 141 139 139 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 139 69 1 True False False False 
 Field 4 141 141 139 69 4 False True False False 
 Field 5 0 211 280 69 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 139 69 1 True False False False 
 Field 3 141 70 139 69 4 False True False False 
 Field 4 0 141 139 69 1 True False False False 
 Field 5 141 141 139 69 4 False True False False 
 Field 6 0 211 280 69 13 True True False True 
 7 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 50 139 59 1 True False False False 
 Field 3 141 50 139 59 4 False True False False 
 Field 4 0 110 280 59 5 True True False False 
 Field 5 0 171 139 59 1 True False False False 
 Field 6 141 171 139 59 4 False True False False 
 Field 7 0 231 280 49 13 True True False True 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 51 139 59 1 True False False False 
 Field 3 141 51 139 59 4 False True False False 
 Field 4 0 112 139 59 1 True False False False 
 Field 5 141 112 139 59 4 False True False False 
 Field 6 0 173 139 59 1 True False False False 
 Field 7 141 173 139 59 4 False True False False 
 Field 8 0 234 280 49 13 True True False True 
 Descent™ Mk2 S
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 81 7 True True True False 
 Field 2 0 83 240 74 5 True True False False 
 Field 3 0 159 240 81 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 240 59 5 True True False False 
 Field 4 0 181 240 59 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 66 1 True False False False 
 Field 3 121 87 119 66 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 119 59 1 True False False False 
 Field 4 121 121 119 59 4 False True False False 
 Field 5 0 181 240 59 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 119 59 1 True False False False 
 Field 3 121 61 119 59 4 False True False False 
 Field 4 0 121 119 59 1 True False False False 
 Field 5 121 121 119 59 4 False True False False 
 Field 6 0 181 240 59 13 True True False True 
 fēnix® 5 Plus
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, fin, fre, gre, heb, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe, tur 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 240 82 5 True True False False 
 Field 3 0 163 240 77 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 119 82 1 True False False False 
 Field 3 121 79 119 82 4 False True False False 
 Field 4 0 163 240 77 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 fēnix® 5S Plus
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, fin, fre, gre, heb, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe, tur 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 240 82 5 True True False False 
 Field 3 0 163 240 77 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 119 82 1 True False False False 
 Field 3 121 79 119 82 4 False True False False 
 Field 4 0 163 240 77 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 fēnix® 5X Plus
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, fin, fre, gre, heb, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe, tur 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 240 82 5 True True False False 
 Field 3 0 163 240 77 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 77 7 True True True False 
 Field 2 0 79 119 82 1 True False False False 
 Field 3 121 79 119 82 4 False True False False 
 Field 4 0 163 240 77 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 fēnix® 6 / 6 Solar / 6 Dual Power
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 82 7 True True True False 
 Field 2 0 84 260 92 5 True True False False 
 Field 3 0 178 260 82 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 87 7 True True True False 
 Field 2 0 89 260 82 5 True True False False 
 Field 3 0 173 260 87 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 129 129 9 True False False True 
 Field 3 131 131 129 129 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 260 64 5 True True False False 
 Field 3 0 131 260 64 5 True True False False 
 Field 4 0 196 260 64 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 94 129 72 1 True False False False 
 Field 3 131 94 129 72 4 False True False False 
 Field 4 0 168 260 92 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 129 129 3 True False True False 
 Field 2 131 0 129 129 6 False True True False 
 Field 3 0 131 129 129 9 True False False True 
 Field 4 131 131 129 129 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 260 64 5 True True False False 
 Field 3 0 131 129 64 1 True False False False 
 Field 4 131 131 129 64 4 False True False False 
 Field 5 0 196 260 64 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 129 64 1 True False False False 
 Field 3 131 65 129 64 4 False True False False 
 Field 4 0 131 129 64 1 True False False False 
 Field 5 131 131 129 64 4 False True False False 
 Field 6 0 196 260 64 13 True True False True 
 fēnix® 6S / 6S Solar / 6S Dual Power
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 81 7 True True True False 
 Field 2 0 83 240 74 5 True True False False 
 Field 3 0 159 240 81 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 240 59 5 True True False False 
 Field 4 0 181 240 59 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 66 1 True False False False 
 Field 3 121 87 119 66 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 119 59 1 True False False False 
 Field 4 121 121 119 59 4 False True False False 
 Field 5 0 181 240 59 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 119 59 1 True False False False 
 Field 3 121 61 119 59 4 False True False False 
 Field 4 0 121 119 59 1 True False False False 
 Field 5 121 121 119 59 4 False True False False 
 Field 6 0 181 240 59 13 True True False True 
 fēnix® 6X Pro / 6X Sapphire / 6X Pro Solar / tactix® Delta Sapphire / Delta Solar / Delta Solar - Ballistics Edition / quatix® 6X / 6X Solar / 6X Dual Power
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 280 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 280 139 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 89 7 True True True False 
 Field 2 0 91 280 98 5 True True False False 
 Field 3 0 191 280 89 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 94 7 True True True False 
 Field 2 0 96 280 88 5 True True False False 
 Field 3 0 186 280 94 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 139 139 9 True False False True 
 Field 3 141 141 139 139 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 280 69 5 True True False False 
 Field 4 0 211 280 69 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 99 7 True True True False 
 Field 2 0 101 139 78 1 True False False False 
 Field 3 141 101 139 78 4 False True False False 
 Field 4 0 181 280 99 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 139 139 3 True False True False 
 Field 2 141 0 139 139 6 False True True False 
 Field 3 0 141 139 139 9 True False False True 
 Field 4 141 141 139 139 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 139 69 1 True False False False 
 Field 4 141 141 139 69 4 False True False False 
 Field 5 0 211 280 69 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 139 69 1 True False False False 
 Field 3 141 70 139 69 4 False True False False 
 Field 4 0 141 139 69 1 True False False False 
 Field 5 141 141 139 69 4 False True False False 
 Field 6 0 211 280 69 13 True True False True 
 7 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 50 139 59 1 True False False False 
 Field 3 141 50 139 59 4 False True False False 
 Field 4 0 110 280 59 5 True True False False 
 Field 5 0 171 139 59 1 True False False False 
 Field 6 141 171 139 59 4 False True False False 
 Field 7 0 231 280 49 13 True True False True 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 51 139 59 1 True False False False 
 Field 3 141 51 139 59 4 False True False False 
 Field 4 0 112 139 59 1 True False False False 
 Field 5 141 112 139 59 4 False True False False 
 Field 6 0 173 139 59 1 True False False False 
 Field 7 141 173 139 59 4 False True False False 
 Field 8 0 234 280 49 13 True True False True 
 Forerunner® 245
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, ron, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 86 7 True True True False 
 Field 2 0 86 240 68 5 True True False False 
 Field 3 0 153 240 86 13 True True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 67 1 True False False False 
 Field 3 121 87 119 67 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 Forerunner® 55
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, ron, rus, slo, slv, spa, swe, tur 
 eng, ind, zsm 
 vie 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 208 208 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 208 103 7 True True True False 
 Field 2 0 105 208 103 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 208 68 7 True True True False 
 Field 2 0 70 208 68 5 True True False False 
 Field 3 0 140 208 68 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 208 68 7 True True True False 
 Field 2 0 70 208 68 5 True True False False 
 Field 3 0 140 208 68 13 True True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 208 74 7 True True True False 
 Field 2 0 76 103 61 1 True False False False 
 Field 3 105 76 103 61 4 False True False False 
 Field 4 0 139 208 68 13 True True False True 
 Forerunner® 745
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, ron, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 86 7 True True True False 
 Field 2 0 86 240 68 5 True True False False 
 Field 3 0 153 240 86 13 True True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 67 1 True False False False 
 Field 3 121 87 119 67 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 Forerunner® 945
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 81 7 True True True False 
 Field 2 0 83 240 74 5 True True False False 
 Field 3 0 159 240 81 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 240 59 5 True True False False 
 Field 4 0 181 240 59 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 66 1 True False False False 
 Field 3 121 87 119 66 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 119 59 1 True False False False 
 Field 4 121 121 119 59 4 False True False False 
 Field 5 0 181 240 59 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 119 59 1 True False False False 
 Field 3 121 61 119 59 4 False True False False 
 Field 4 0 121 119 59 1 True False False False 
 Field 5 121 121 119 59 4 False True False False 
 Field 6 0 181 240 59 13 True True False True 
 Forerunner® 945 LTE
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 81 7 True True True False 
 Field 2 0 83 240 74 5 True True False False 
 Field 3 0 159 240 81 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 240 59 5 True True False False 
 Field 4 0 181 240 59 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 66 1 True False False False 
 Field 3 121 87 119 66 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 119 59 1 True False False False 
 Field 4 121 121 119 59 4 False True False False 
 Field 5 0 181 240 59 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 119 59 1 True False False False 
 Field 3 121 61 119 59 4 False True False False 
 Field 4 0 121 119 59 1 True False False False 
 Field 5 121 121 119 59 4 False True False False 
 Field 6 0 181 240 59 13 True True False True 
 MARQ® Athlete
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 86 7 True True True False 
 Field 2 0 86 240 68 5 True True False False 
 Field 3 0 153 240 86 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 67 1 True False False False 
 Field 3 121 87 119 67 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True


# [Edge 2019](https://developer.garmin.com/connect-iq/user-experience-guidelines/edge-2019/)nMenu User Experience Guidelines Edge 2019
 Style Guide
 Devices Edge® 1030 
 Edge® 1030 Plus 
 Edge® 530 
 Edge® 830 
 
 Edge® 1030
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 470 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 234 0 False False False False 
 Field 2 0 236 282 234 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 155 0 False False False False 
 Field 2 0 158 282 154 0 False False False False 
 Field 3 0 315 282 155 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 282 187 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 116 0 False False False False 
 Field 2 0 119 282 115 0 False False False False 
 Field 3 0 237 282 115 0 False False False False 
 Field 4 0 354 282 116 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 187 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 140 92 0 False False False False 
 Field 4 142 283 140 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 140 92 0 False False False False 
 Field 4 142 189 140 92 0 False False False False 
 Field 5 0 283 140 92 0 False False False False 
 Field 6 142 283 140 92 0 False False False False 
 Field 7 0 377 140 93 0 False False False False 
 Field 8 142 377 140 93 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 140 92 0 False False False False 
 Field 3 142 95 140 92 0 False False False False 
 Field 4 0 189 140 92 0 False False False False 
 Field 5 142 189 140 92 0 False False False False 
 Field 6 0 283 140 92 0 False False False False 
 Field 7 142 283 140 92 0 False False False False 
 Field 8 0 377 140 93 0 False False False False 
 Field 9 142 377 140 93 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 140 92 0 False False False False 
 Field 4 142 95 140 92 0 False False False False 
 Field 5 0 189 140 92 0 False False False False 
 Field 6 142 189 140 92 0 False False False False 
 Field 7 0 283 140 92 0 False False False False 
 Field 8 142 283 140 92 0 False False False False 
 Field 9 0 377 140 93 0 False False False False 
 Field 10 142 377 140 93 0 False False False False 
 Edge® 1030 Plus
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 470 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 234 0 False False False False 
 Field 2 0 236 282 234 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 155 0 False False False False 
 Field 2 0 158 282 154 0 False False False False 
 Field 3 0 315 282 155 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 282 187 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 116 0 False False False False 
 Field 2 0 119 282 115 0 False False False False 
 Field 3 0 237 282 115 0 False False False False 
 Field 4 0 354 282 116 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 187 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 140 92 0 False False False False 
 Field 4 142 283 140 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 140 92 0 False False False False 
 Field 4 142 189 140 92 0 False False False False 
 Field 5 0 283 140 92 0 False False False False 
 Field 6 142 283 140 92 0 False False False False 
 Field 7 0 377 140 93 0 False False False False 
 Field 8 142 377 140 93 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 140 92 0 False False False False 
 Field 3 142 95 140 92 0 False False False False 
 Field 4 0 189 140 92 0 False False False False 
 Field 5 142 189 140 92 0 False False False False 
 Field 6 0 283 140 92 0 False False False False 
 Field 7 142 283 140 92 0 False False False False 
 Field 8 0 377 140 93 0 False False False False 
 Field 9 142 377 140 93 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 140 92 0 False False False False 
 Field 4 142 95 140 92 0 False False False False 
 Field 5 0 189 140 92 0 False False False False 
 Field 6 142 189 140 92 0 False False False False 
 Field 7 0 283 140 92 0 False False False False 
 Field 8 142 283 140 92 0 False False False False 
 Field 9 0 377 140 93 0 False False False False 
 Field 10 142 377 140 93 0 False False False False 
 Edge® 530
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 322 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 160 0 False False False False 
 Field 2 0 162 246 160 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 106 0 False False False False 
 Field 2 0 108 246 105 0 False False False False 
 Field 3 0 215 246 106 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 126 0 False False False False 
 Field 3 0 193 246 127 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 79 0 False False False False 
 Field 2 0 81 246 78 0 False False False False 
 Field 3 0 161 246 78 0 False False False False 
 Field 4 0 241 246 79 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 246 127 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 246 63 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 126 0 False False False False 
 Field 3 0 193 122 62 0 False False False False 
 Field 4 124 193 122 62 0 False False False False 
 Field 5 0 257 246 63 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 122 63 0 False False False False 
 Field 6 124 257 122 63 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 122 63 0 False False False False 
 Field 6 124 257 122 63 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 122 62 0 False False False False 
 Field 5 124 193 122 62 0 False False False False 
 Field 6 0 257 122 63 0 False False False False 
 Field 7 124 257 122 63 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 122 62 0 False False False False 
 Field 5 124 193 122 62 0 False False False False 
 Field 6 0 257 122 63 0 False False False False 
 Field 7 124 257 122 63 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 122 62 0 False False False False 
 Field 4 124 129 122 62 0 False False False False 
 Field 5 0 193 122 62 0 False False False False 
 Field 6 124 193 122 62 0 False False False False 
 Field 7 0 257 122 63 0 False False False False 
 Field 8 124 257 122 63 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 122 62 0 False False False False 
 Field 3 124 65 122 62 0 False False False False 
 Field 4 0 129 122 62 0 False False False False 
 Field 5 124 129 122 62 0 False False False False 
 Field 6 0 193 122 62 0 False False False False 
 Field 7 124 193 122 62 0 False False False False 
 Field 8 0 257 122 63 0 False False False False 
 Field 9 124 257 122 63 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 122 62 0 False False False False 
 Field 4 124 65 122 62 0 False False False False 
 Field 5 0 129 122 62 0 False False False False 
 Field 6 124 129 122 62 0 False False False False 
 Field 7 0 193 122 62 0 False False False False 
 Field 8 124 193 122 62 0 False False False False 
 Field 9 0 257 122 63 0 False False False False 
 Field 10 124 257 122 63 0 False False False False 
 Edge® 830
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe 
 eng, ind, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 322 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 160 0 False False False False 
 Field 2 0 162 246 160 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 106 0 False False False False 
 Field 2 0 108 246 105 0 False False False False 
 Field 3 0 215 246 106 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 126 0 False False False False 
 Field 3 0 193 246 127 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 79 0 False False False False 
 Field 2 0 81 246 78 0 False False False False 
 Field 3 0 161 246 78 0 False False False False 
 Field 4 0 241 246 79 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 246 127 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 246 63 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 126 0 False False False False 
 Field 3 0 193 122 62 0 False False False False 
 Field 4 124 193 122 62 0 False False False False 
 Field 5 0 257 246 63 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 122 63 0 False False False False 
 Field 6 124 257 122 63 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 246 62 0 False False False False 
 Field 5 0 257 122 63 0 False False False False 
 Field 6 124 257 122 63 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 246 62 0 False False False False 
 Field 4 0 193 122 62 0 False False False False 
 Field 5 124 193 122 62 0 False False False False 
 Field 6 0 257 122 63 0 False False False False 
 Field 7 124 257 122 63 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 246 126 0 False False False False 
 Field 4 0 193 122 62 0 False False False False 
 Field 5 124 193 122 62 0 False False False False 
 Field 6 0 257 122 63 0 False False False False 
 Field 7 124 257 122 63 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 246 62 0 False False False False 
 Field 3 0 129 122 62 0 False False False False 
 Field 4 124 129 122 62 0 False False False False 
 Field 5 0 193 122 62 0 False False False False 
 Field 6 124 193 122 62 0 False False False False 
 Field 7 0 257 122 63 0 False False False False 
 Field 8 124 257 122 63 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 246 63 0 False False False False 
 Field 2 0 65 122 62 0 False False False False 
 Field 3 124 65 122 62 0 False False False False 
 Field 4 0 129 122 62 0 False False False False 
 Field 5 124 129 122 62 0 False False False False 
 Field 6 0 193 122 62 0 False False False False 
 Field 7 124 193 122 62 0 False False False False 
 Field 8 0 257 122 63 0 False False False False 
 Field 9 124 257 122 63 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 122 63 0 False False False False 
 Field 2 124 0 122 63 0 False False False False 
 Field 3 0 65 122 62 0 False False False False 
 Field 4 124 65 122 62 0 False False False False 
 Field 5 0 129 122 62 0 False False False False 
 Field 6 124 129 122 62 0 False False False False 
 Field 7 0 193 122 62 0 False False False False 
 Field 8 124 193 122 62 0 False False False False 
 Field 9 0 257 122 63 0 False False False False 
 Field 10 124 257 122 63 0 False False False False


# [Vivoactive 2019](https://developer.garmin.com/connect-iq/user-experience-guidelines/vivoactive-2019/)nMenu User Experience Guidelines Vivoactive 2019
 Style Guide
 Devices Venu™ 
 Venu® Sq 
 vívoactive® 4 
 vívoactive® 4S 
 
 Venu™
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 390 390 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 390 194 7 True True True False 
 Field 2 0 195 390 194 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 390 129 7 True True True False 
 Field 2 0 131 390 128 5 True True False False 
 Field 3 0 261 390 129 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 390 129 7 True True True False 
 Field 2 0 131 194 128 1 True False False False 
 Field 3 196 131 194 128 4 False True False False 
 Field 4 0 261 390 129 13 True True False True 
 Venu® Sq
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 12 0 220 240 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 12 0 220 120 0 False False False False 
 Field 2 12 120 220 120 0 False False False False 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 12 0 220 77 0 False False False False 
 Field 2 12 77 220 86 0 False False False False 
 Field 3 12 163 220 77 0 False False False False 
 vívoactive® 4
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 85 7 True True True False 
 Field 2 0 87 260 85 5 True True False False 
 Field 3 0 174 260 86 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 85 7 True True True False 
 Field 2 0 87 129 85 1 True False False False 
 Field 3 131 87 129 85 4 False True False False 
 Field 4 0 174 260 86 13 True True False True 
 vívoactive® 4S
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 218 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 108 7 True True True False 
 Field 2 0 110 218 108 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 71 7 True True True False 
 Field 2 0 73 218 71 5 True True False False 
 Field 3 0 146 218 72 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 71 7 True True True False 
 Field 2 0 73 108 71 1 True False False False 
 Field 3 110 73 108 71 4 False True False False 
 Field 4 0 146 218 72 13 True True False True


# [Venu 2021](https://developer.garmin.com/connect-iq/user-experience-guidelines/venu-2021/)nMenu User Experience Guidelines Venu 2021
 Style Guide
 Devices Venu™ 2 
 Venu™ 2 Plus 
 Venu™ 2S 
 Venu® Sq 2 
 
 Venu™ 2
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 416 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 207 7 True True True False 
 Field 2 0 209 416 207 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 137 7 True True True False 
 Field 2 0 139 416 137 5 True True False False 
 Field 3 0 278 416 138 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 137 7 True True True False 
 Field 2 0 139 207 137 1 True False False False 
 Field 3 209 139 207 137 4 False True False False 
 Field 4 0 278 416 138 13 True True False True 
 Venu™ 2 Plus
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 416 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 207 7 True True True False 
 Field 2 0 209 416 207 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 137 7 True True True False 
 Field 2 0 139 416 137 5 True True False False 
 Field 3 0 278 416 138 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 137 7 True True True False 
 Field 2 0 139 207 137 1 True False False False 
 Field 3 209 139 207 137 4 False True False False 
 Field 4 0 278 416 138 13 True True False True 
 Venu™ 2S
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 360 360 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 360 179 7 True True True False 
 Field 2 0 181 360 179 13 True True False True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 360 119 7 True True True False 
 Field 2 0 121 360 118 5 True True False False 
 Field 3 0 241 360 119 13 True True False True 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 360 119 7 True True True False 
 Field 2 0 121 179 118 1 True False False False 
 Field 3 181 121 179 118 4 False True False False 
 Field 4 0 241 360 119 13 True True False True 
 Venu® Sq 2
 Languages Text Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, vie, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 320 360 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 320 179 0 False False False False 
 Field 2 0 181 320 179 0 False False False False 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 320 113 0 False False False False 
 Field 2 0 115 320 118 0 False False False False 
 Field 3 0 231 320 129 0 False False False False 
 4 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 320 120 0 False False False False 
 Field 2 0 120 159 118 0 False False False False 
 Field 3 161 120 159 118 0 False False False False 
 Field 4 0 239 320 121 0 False False False False


# [Fenix 2022](https://developer.garmin.com/connect-iq/user-experience-guidelines/fenix-2022/)nMenu User Experience Guidelines Fenix 2022
 Style Guide
 Devices epix™ (Gen 2) / quatix® 7 Sapphire 
 fēnix® 7 / quatix® 7 
 fēnix® 7S 
 fēnix® 7X / tactix® 7 / quatix® 7X Solar / Enduro™ 2 
 Forerunner® 255 
 Forerunner® 255 Music 
 Forerunner® 255s 
 Forerunner® 955 / Solar 
 
 epix™ (Gen 2) / quatix® 7 Sapphire
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 416 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 207 7 True True True False 
 Field 2 0 209 416 207 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 132 7 True True True False 
 Field 2 0 135 416 146 5 True True False False 
 Field 3 0 283 416 132 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 142 7 True True True False 
 Field 2 0 142 416 132 5 True True False False 
 Field 3 0 274 416 142 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 208 7 True True True False 
 Field 2 0 210 207 206 9 True False False True 
 Field 3 209 210 207 206 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 103 7 True True True False 
 Field 2 0 105 416 103 5 True True False False 
 Field 3 0 210 416 103 5 True True False False 
 Field 4 0 315 416 103 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 147 7 True True True False 
 Field 2 0 149 207 116 1 True False False False 
 Field 3 209 149 207 116 4 False True False False 
 Field 4 0 267 416 147 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 207 207 3 True False True False 
 Field 2 209 0 207 207 6 False True True False 
 Field 3 0 209 207 207 9 True False False True 
 Field 4 209 209 207 207 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 103 7 True True True False 
 Field 2 0 105 416 102 5 True True False False 
 Field 3 0 209 207 102 1 True False False False 
 Field 4 209 209 207 102 4 False True False False 
 Field 5 0 313 416 103 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 103 7 True True True False 
 Field 2 0 105 207 102 1 True False False False 
 Field 3 209 105 207 102 4 False True False False 
 Field 4 0 209 207 102 1 True False False False 
 Field 5 209 209 207 102 4 False True False False 
 Field 6 0 313 416 103 13 True True False True 
 7 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 73 7 True True True False 
 Field 2 0 75 207 87 1 True False False False 
 Field 3 209 75 207 87 4 False True False False 
 Field 4 0 164 416 87 5 True True False False 
 Field 5 0 253 207 87 1 True False False False 
 Field 6 209 253 207 87 4 False True False False 
 Field 7 0 342 416 74 13 True True False True 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 73 7 True True True False 
 Field 2 0 75 207 87 1 True False False False 
 Field 3 209 75 207 87 4 False True False False 
 Field 4 0 164 207 87 1 True False False False 
 Field 5 209 164 207 87 4 False True False False 
 Field 6 0 253 207 87 1 True False False False 
 Field 7 209 253 207 87 4 False True False False 
 Field 8 0 342 416 74 13 True True False True 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 416 132 7 True True True False 
 Field 2 0 149 138 87 1 True False False False 
 Field 3 0 237 138 87 1 True False False False 
 Field 4 159 133 257 108 4 False True False False 
 Field 5 159 242 257 98 4 False True False False 
 Field 6 0 341 416 73 13 True True False True 
 fēnix® 7 / quatix® 7
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 82 7 True True True False 
 Field 2 0 84 260 92 5 True True False False 
 Field 3 0 178 260 82 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 87 7 True True True False 
 Field 2 0 89 260 82 5 True True False False 
 Field 3 0 173 260 87 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 129 129 9 True False False True 
 Field 3 131 131 129 129 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 260 64 5 True True False False 
 Field 3 0 131 260 64 5 True True False False 
 Field 4 0 196 260 64 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 94 129 72 1 True False False False 
 Field 3 131 94 129 72 4 False True False False 
 Field 4 0 168 260 92 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 129 129 3 True False True False 
 Field 2 131 0 129 129 6 False True True False 
 Field 3 0 131 129 129 9 True False False True 
 Field 4 131 131 129 129 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 260 64 5 True True False False 
 Field 3 0 131 129 64 1 True False False False 
 Field 4 131 131 129 64 4 False True False False 
 Field 5 0 196 260 64 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 65 129 64 1 True False False False 
 Field 3 131 65 129 64 4 False True False False 
 Field 4 0 131 129 64 1 True False False False 
 Field 5 131 131 129 64 4 False True False False 
 Field 6 0 196 260 64 13 True True False True 
 fēnix® 7S
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 240 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 122 240 119 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 76 7 True True True False 
 Field 2 0 78 240 84 5 True True False False 
 Field 3 0 164 240 76 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 81 7 True True True False 
 Field 2 0 83 240 74 5 True True False False 
 Field 3 0 159 240 81 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 119 7 True True True False 
 Field 2 0 121 119 119 9 True False False True 
 Field 3 121 121 119 119 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 240 59 5 True True False False 
 Field 4 0 181 240 59 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 85 7 True True True False 
 Field 2 0 87 119 66 1 True False False False 
 Field 3 121 87 119 66 4 False True False False 
 Field 4 0 156 240 85 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 119 3 True False True False 
 Field 2 121 0 119 119 6 False True True False 
 Field 3 0 121 119 119 9 True False False True 
 Field 4 121 121 119 119 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 240 59 5 True True False False 
 Field 3 0 121 119 59 1 True False False False 
 Field 4 121 121 119 59 4 False True False False 
 Field 5 0 181 240 59 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 59 7 True True True False 
 Field 2 0 61 119 59 1 True False False False 
 Field 3 121 61 119 59 4 False True False False 
 Field 4 0 121 119 59 1 True False False False 
 Field 5 121 121 119 59 4 False True False False 
 Field 6 0 181 240 59 13 True True False True 
 fēnix® 7X / tactix® 7 / quatix® 7X Solar / Enduro™ 2
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 280 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 280 139 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 89 7 True True True False 
 Field 2 0 91 280 98 5 True True False False 
 Field 3 0 191 280 89 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 94 7 True True True False 
 Field 2 0 96 280 88 5 True True False False 
 Field 3 0 186 280 94 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 139 7 True True True False 
 Field 2 0 141 139 139 9 True False False True 
 Field 3 141 141 139 139 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 280 69 5 True True False False 
 Field 4 0 211 280 69 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 99 7 True True True False 
 Field 2 0 101 139 78 1 True False False False 
 Field 3 141 101 139 78 4 False True False False 
 Field 4 0 181 280 99 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 139 139 3 True False True False 
 Field 2 141 0 139 139 6 False True True False 
 Field 3 0 141 139 139 9 True False False True 
 Field 4 141 141 139 139 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 280 69 5 True True False False 
 Field 3 0 141 139 69 1 True False False False 
 Field 4 141 141 139 69 4 False True False False 
 Field 5 0 211 280 69 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 69 7 True True True False 
 Field 2 0 70 139 69 1 True False False False 
 Field 3 141 70 139 69 4 False True False False 
 Field 4 0 141 139 69 1 True False False False 
 Field 5 141 141 139 69 4 False True False False 
 Field 6 0 211 280 69 13 True True False True 
 7 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 50 139 59 1 True False False False 
 Field 3 141 50 139 59 4 False True False False 
 Field 4 0 110 280 59 5 True True False False 
 Field 5 0 171 139 59 1 True False False False 
 Field 6 141 171 139 59 4 False True False False 
 Field 7 0 231 280 49 13 True True False True 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 280 49 7 True True True False 
 Field 2 0 51 139 59 1 True False False False 
 Field 3 141 51 139 59 4 False True False False 
 Field 4 0 112 139 59 1 True False False False 
 Field 5 141 112 139 59 4 False True False False 
 Field 6 0 173 139 59 1 True False False False 
 Field 7 141 173 139 59 4 False True False False 
 Field 8 0 234 280 49 13 True True False True 
 Forerunner® 255
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 83 7 True True True False 
 Field 2 0 85 260 91 5 True True False False 
 Field 3 0 178 260 82 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 93 260 74 5 True True False False 
 Field 3 0 166 260 93 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 129 129 9 True False False True 
 Field 3 131 131 129 129 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 132 260 63 5 True True False False 
 Field 4 0 196 260 64 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 94 129 77 1 True False False False 
 Field 3 131 94 129 77 4 False True False False 
 Field 4 0 173 260 87 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 129 129 3 True False True False 
 Field 2 131 0 129 129 6 False True True False 
 Field 3 0 131 129 129 9 True False False True 
 Field 4 131 131 129 129 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 131 129 63 1 True False False False 
 Field 4 131 131 129 63 4 False True False False 
 Field 5 0 196 260 64 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 129 63 1 True False False False 
 Field 3 131 66 129 63 4 False True False False 
 Field 4 0 131 129 63 1 True False False False 
 Field 5 131 131 129 63 4 False True False False 
 Field 6 0 196 260 64 13 True True False True 
 Forerunner® 255 Music
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 83 7 True True True False 
 Field 2 0 85 260 91 5 True True False False 
 Field 3 0 178 260 82 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 93 260 74 5 True True False False 
 Field 3 0 166 260 93 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 129 129 9 True False False True 
 Field 3 131 131 129 129 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 132 260 63 5 True True False False 
 Field 4 0 196 260 64 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 94 129 77 1 True False False False 
 Field 3 131 94 129 77 4 False True False False 
 Field 4 0 173 260 87 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 129 129 3 True False True False 
 Field 2 131 0 129 129 6 False True True False 
 Field 3 0 131 129 129 9 True False False True 
 Field 4 131 131 129 129 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 131 129 63 1 True False False False 
 Field 4 131 131 129 63 4 False True False False 
 Field 5 0 196 260 64 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 129 63 1 True False False False 
 Field 3 131 66 129 63 4 False True False False 
 Field 4 0 131 129 63 1 True False False False 
 Field 5 131 131 129 63 4 False True False False 
 Field 6 0 196 260 64 13 True True False True 
 Forerunner® 255s
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 218 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 108 7 True True True False 
 Field 2 0 110 218 108 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 76 7 True True True False 
 Field 2 0 76 218 62 5 True True False False 
 Field 3 0 138 218 80 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 70 7 True True True False 
 Field 2 0 72 218 75 5 True True False False 
 Field 3 0 149 218 69 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 108 7 True True True False 
 Field 2 0 110 108 108 9 True False False True 
 Field 3 110 110 108 108 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 77 7 True True True False 
 Field 2 0 79 108 65 1 True False False False 
 Field 3 110 79 108 65 4 False True False False 
 Field 4 0 146 218 72 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 108 108 3 True False True False 
 Field 2 110 0 108 108 6 False True True False 
 Field 3 0 110 108 108 9 True False False True 
 Field 4 110 110 108 108 12 False True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 54 7 True True True False 
 Field 2 0 56 218 52 5 True True False False 
 Field 3 0 110 218 53 5 True True False False 
 Field 4 0 165 218 53 13 True True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 54 7 True True True False 
 Field 2 0 56 218 52 5 True True False False 
 Field 3 0 110 108 53 1 True False False False 
 Field 4 110 110 108 53 4 False True False False 
 Field 5 0 165 218 53 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 218 54 7 True True True False 
 Field 2 0 56 108 52 1 True False False False 
 Field 3 110 56 108 52 4 False True False False 
 Field 4 0 110 108 53 1 True False False False 
 Field 5 110 110 108 53 4 False True False False 
 Field 6 0 165 218 53 13 True True False True 
 Forerunner® 955 / Solar
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ind, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr, zsm 
 zhs, zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 260 15 True True True True 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 260 129 13 True True False True 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 83 7 True True True False 
 Field 2 0 85 260 91 5 True True False False 
 Field 3 0 178 260 82 13 True True False True 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 93 260 74 5 True True False False 
 Field 3 0 166 260 93 13 True True False True 
 3 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 129 7 True True True False 
 Field 2 0 131 129 129 9 True False False True 
 Field 3 131 131 129 129 12 False True False True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 132 260 63 5 True True False False 
 Field 4 0 196 260 64 13 True True False True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 92 7 True True True False 
 Field 2 0 94 129 77 1 True False False False 
 Field 3 131 94 129 77 4 False True False False 
 Field 4 0 173 260 87 13 True True False True 
 4 Fields C Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 129 129 3 True False True False 
 Field 2 131 0 129 129 6 False True True False 
 Field 3 0 131 129 129 9 True False False True 
 Field 4 131 131 129 129 12 False True False True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 260 63 5 True True False False 
 Field 3 0 131 129 63 1 True False False False 
 Field 4 131 131 129 63 4 False True False False 
 Field 5 0 196 260 64 13 True True False True 
 6 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 260 64 7 True True True False 
 Field 2 0 66 129 63 1 True False False False 
 Field 3 131 66 129 63 4 False True False False 
 Field 4 0 131 129 63 1 True False False False 
 Field 5 131 131 129 63 4 False True False False 
 Field 6 0 196 260 64 13 True True False True


# [Instinct 2022](https://developer.garmin.com/connect-iq/user-experience-guidelines/instinct-2022/)nMenu User Experience Guidelines Instinct 2022
 Style Guide
 Devices Instinct® 2 / Solar / Dual Power / dēzl Edition 
 Instinct® 2S / Solar / Dual Power 
 
 Instinct® 2 / Solar / Dual Power / dēzl Edition
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 112 71 3 True False True False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 176 176 15 True True True True 
 Field 2 113 1 62 62 15 True True True True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 108 71 3 True False True False 
 Field 2 0 72 176 104 13 True True False True 
 Field 3 113 1 62 62 15 True True True True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 108 55 3 True False True False 
 Field 2 0 56 176 65 0 False False False False 
 Field 3 0 122 176 54 13 True True False True 
 Field 4 113 1 62 62 15 True True True True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 108 71 3 True False True False 
 Field 2 0 72 87 104 9 True False False True 
 Field 3 88 72 88 104 12 False True False True 
 Field 4 113 1 62 62 15 True True True True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 108 71 3 True False True False 
 Field 2 0 72 87 76 9 True False False True 
 Field 3 88 72 88 76 12 False True False True 
 Field 4 32 149 110 27 0 False False False False 
 Field 5 113 1 62 62 15 True True True True 
 Instinct® 2S / Solar / Dual Power
 Languages Text Fonts Number Fonts Glance Fonts 
 ara, bul, ces, dan, deu, dut, eng, est, fin, fre, gre, heb, hrv, hun, ita, lav, lit, nob, pol, por, ron, rus, slo, slv, spa, swe, tur, ukr 
 eng, ind, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 vie 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 104 64 3 True False True False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 156 156 15 True True True True 
 Field 2 109 0 54 54 15 True True True True 
 3 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 93 64 3 True False True False 
 Field 2 0 64 156 92 13 True True False True 
 Field 3 109 0 54 54 15 True True True True 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 93 49 3 True False True False 
 Field 2 0 50 156 57 0 False False False False 
 Field 3 0 108 156 48 13 True True False True 
 Field 4 109 0 54 54 15 True True True True 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 93 64 3 True False True False 
 Field 2 0 64 78 92 9 True False False True 
 Field 3 78 64 78 92 12 False True False True 
 Field 4 109 0 54 54 15 True True True True 
 5 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 93 64 3 True False True False 
 Field 2 0 65 78 66 0 False False False False 
 Field 3 78 65 78 66 0 False False False False 
 Field 4 30 131 96 24 0 False False False False 
 Field 5 109 0 54 54 15 True True True True


# [Edge 2022](https://developer.garmin.com/connect-iq/user-experience-guidelines/edge-2022/)nMenu User Experience Guidelines Edge 2022
 Style Guide
 Devices Edge® 1040 / 1040 Solar 
 Edge® Explore 2 
 
 Edge® 1040 / 1040 Solar
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, heb, hrv, hun, ita, nob, pol, por, rus, slo, slv, spa, swe 
 eng, ind, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 470 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 234 0 False False False False 
 Field 2 0 236 282 234 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 155 0 False False False False 
 Field 2 0 158 282 154 0 False False False False 
 Field 3 0 315 282 155 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 282 187 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 116 0 False False False False 
 Field 2 0 119 282 115 0 False False False False 
 Field 3 0 237 282 115 0 False False False False 
 Field 4 0 354 282 116 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 187 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 186 0 False False False False 
 Field 3 0 283 140 92 0 False False False False 
 Field 4 142 283 140 92 0 False False False False 
 Field 5 0 377 282 93 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 282 92 0 False False False False 
 Field 5 0 377 140 93 0 False False False False 
 Field 6 142 377 140 93 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 282 92 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 282 186 0 False False False False 
 Field 4 0 283 140 92 0 False False False False 
 Field 5 142 283 140 92 0 False False False False 
 Field 6 0 377 140 93 0 False False False False 
 Field 7 142 377 140 93 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 282 92 0 False False False False 
 Field 3 0 189 140 92 0 False False False False 
 Field 4 142 189 140 92 0 False False False False 
 Field 5 0 283 140 92 0 False False False False 
 Field 6 142 283 140 92 0 False False False False 
 Field 7 0 377 140 93 0 False False False False 
 Field 8 142 377 140 93 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 282 93 0 False False False False 
 Field 2 0 95 140 92 0 False False False False 
 Field 3 142 95 140 92 0 False False False False 
 Field 4 0 189 140 92 0 False False False False 
 Field 5 142 189 140 92 0 False False False False 
 Field 6 0 283 140 92 0 False False False False 
 Field 7 142 283 140 92 0 False False False False 
 Field 8 0 377 140 93 0 False False False False 
 Field 9 142 377 140 93 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 140 93 0 False False False False 
 Field 2 142 0 140 93 0 False False False False 
 Field 3 0 95 140 92 0 False False False False 
 Field 4 142 95 140 92 0 False False False False 
 Field 5 0 189 140 92 0 False False False False 
 Field 6 142 189 140 92 0 False False False False 
 Field 7 0 283 140 92 0 False False False False 
 Field 8 142 283 140 92 0 False False False False 
 Field 9 0 377 140 93 0 False False False False 
 Field 10 142 377 140 93 0 False False False False 
 Edge® Explore 2
 Languages Text Fonts Number Fonts Glance Fonts 
 ces, dan, deu, dut, eng, fin, fre, gre, hrv, hun, ind, ita, nob, pol, por, rus, slo, slv, spa, swe, vie, zsm 
 zhs 
 zht 
 jpn 
 kor 
 tha 
 1 Field Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 400 0 False False False False 
 2 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 199 0 False False False False 
 Field 2 0 201 240 199 0 False False False False 
 3 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 132 0 False False False False 
 Field 2 0 134 240 132 0 False False False False 
 Field 3 0 268 240 132 0 False False False False 
 3 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 79 0 False False False False 
 Field 2 0 81 240 158 0 False False False False 
 Field 3 0 241 240 159 0 False False False False 
 4 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 98 0 False False False False 
 Field 2 0 100 240 98 0 False False False False 
 Field 3 0 200 240 98 0 False False False False 
 Field 4 0 300 240 100 0 False False False False 
 4 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 79 0 False False False False 
 Field 2 121 0 119 79 0 False False False False 
 Field 3 0 81 240 158 0 False False False False 
 Field 4 0 241 240 159 0 False False False False 
 5 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 240 78 0 False False False False 
 Field 3 0 160 240 78 0 False False False False 
 Field 4 0 240 240 78 0 False False False False 
 Field 5 0 320 240 80 0 False False False False 
 5 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 240 156 0 False False False False 
 Field 3 0 238 119 78 0 False False False False 
 Field 4 121 238 119 78 0 False False False False 
 Field 5 0 318 240 82 0 False False False False 
 6 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 240 78 0 False False False False 
 Field 3 0 160 240 78 0 False False False False 
 Field 4 0 240 240 78 0 False False False False 
 Field 5 0 320 119 80 0 False False False False 
 Field 6 121 320 119 80 0 False False False False 
 6 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 78 0 False False False False 
 Field 2 121 0 119 78 0 False False False False 
 Field 3 0 80 240 156 0 False False False False 
 Field 4 0 238 240 78 0 False False False False 
 Field 5 0 318 119 82 0 False False False False 
 Field 6 121 318 119 82 0 False False False False 
 7 Fields A Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 240 78 0 False False False False 
 Field 3 0 160 240 78 0 False False False False 
 Field 4 0 240 119 78 0 False False False False 
 Field 5 0 320 119 80 0 False False False False 
 Field 6 121 320 119 80 0 False False False False 
 Field 7 121 240 119 78 0 False False False False 
 7 Fields B Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 78 0 False False False False 
 Field 2 121 0 119 78 0 False False False False 
 Field 3 0 80 240 156 0 False False False False 
 Field 4 0 238 119 78 0 False False False False 
 Field 5 121 238 119 78 0 False False False False 
 Field 6 0 318 119 82 0 False False False False 
 Field 7 121 318 119 82 0 False False False False 
 8 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 240 78 0 False False False False 
 Field 3 0 160 119 78 0 False False False False 
 Field 4 0 240 119 78 0 False False False False 
 Field 5 0 320 119 80 0 False False False False 
 Field 6 121 320 119 80 0 False False False False 
 Field 7 121 240 119 78 0 False False False False 
 Field 8 121 160 119 78 0 False False False False 
 9 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 240 78 0 False False False False 
 Field 2 0 80 119 78 0 False False False False 
 Field 3 121 80 119 78 0 False False False False 
 Field 4 0 160 119 78 0 False False False False 
 Field 5 121 160 119 78 0 False False False False 
 Field 6 0 240 119 78 0 False False False False 
 Field 7 121 240 119 78 0 False False False False 
 Field 8 0 320 119 80 0 False False False False 
 Field 9 121 320 119 80 0 False False False False 
 10 Fields Layout Name Left Top Width Height Obscurity Flags Obscure Left Obscure Right Obscure Top Obscure Bottom 
 Field 1 0 0 119 78 0 False False False False 
 Field 2 121 0 119 78 0 False False False False 
 Field 3 0 80 119 78 0 False False False False 
 Field 4 121 80 119 78 0 False False False False 
 Field 5 0 160 119 78 0 False False False False 
 Field 6 121 160 119 78 0 False False False False 
 Field 7 0 240 119 78 0 False False False False 
 Field 8 121 240 119 78 0 False False False False 
 Field 9 0 320 119 80 0 False False False False 
 Field 10 121 320 119 80 0 False False False False


# [Connect IQ FAQ](https://developer.garmin.com/connect-iq/connect-iq-faq/)nMenu Connect IQ FAQ Overview
 Welcome to the Connect IQ FAQ. This section provides articles on your most frequently asked questions, pro tips written by Connect IQ experts, and deep dives into popular topics. Bitmaps and Fonts
 How do I optimize bitmaps in my app? 
 How do I use custom fonts? 
 
 Watch Faces
 How do I make my watch face update every second? 
 How do I make a watch face for AMOLED products? 
 How do I override the goal animation? 
 
 Communication
 How do I use REST services? 
 How do I use the Connect IQ Mobile SDK? 
 
 Advanced Topics
 How do I create a Connect IQ Background Service? 
 How do I use a MapView? 
 How do I create an Audio Content Provider?


# [How Do I Get My Watch Face to Update Every Second](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-get-my-watch-face-to-update-every-second/)nMenu Connect IQ FAQ How do I Make My Watch Face Update Every Second?
 Since API level 2.3 Some devices support updating the watchface every second. These devices will run normal updates via the onUpdate() method at the top of each minute like other devices, but will also call the onPartialUpdate() method each second. The onPartialUpdate() method has very strict limits set on execution time, and must complete within these limits. If the execution limit is exceeded, the onPowerBudgetExceeded() method will be invoked in the WatchFaceDelegate, and partial updates will stop executing for the remainder of the app life-cycle. Minimizing the number of pixels updated on the display during onPartialUpdate is important because refreshing the display is an expensive part of the update process. For this reason, the Connect IQ API provides a couple of useful tools: Dc.setClip() and BufferedBitmap . The Dc.setClip() method is used to restrict the rendering window when drawing during an onPartialUpdate() callback. All pixels in the active clipping area are considered modified every time any pixel in the clip is modified. For more complex graphics, resources can be rendered off-screen in one or more BufferedBitmap objects and copied as a single object to redraw background pixels during onPartialUpdate() . Rendering in a BufferedBitmap should be completed during onUpdate() since it is not subject to the execution time limits as onPartialUpdate() . The Analog watch face, included in the SDK samples, is an example of a watchface that uses every second watchface updates. module WatchUi { class WatchFace extends Toybox.WatchUi.View { //! onPartialUpdate() is called each second as long as the device //! power budget is not exceeded. //! It is important to update as small of a portion of the display as possible //! in this method to avoid exceeding the allowed power budget. To do this, the //! application must set the clipping region for the Graphics.Dc object using //! the setClip method. Calls to Toybox.System.println() and Toybox.System.print() //! will not execute on devices when this function is being invoked, but can be //! used in the device simulator. //! @param [Graphics.Dc] dc The drawing context //! @since 2.3.0 function onPartialUpdate(dc); } }


# [How Do I Use REST Services](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-use-rest-services/)nMenu Connect IQ FAQ How do I communicate with REST services?
 The Connect IQ Communication API is the API that brings the wearable web to Garmin devices. However, there are some subtleties to how to expose a web service to a Garmin device. The Bluetooth Smart Connection
 Because all of the communication takes place over a Bluetooth Smart (you may know this as Bluetooth LE or BLE) connection the device is bandwidth limited. Data transfers through the Connect IQ SDK will have a transfer speed less than 1 Kb/s, generally between 400 and 800 bytes/s. A single tweet being pulled from Twitter’s API can be upwards of 2.5 Kb. We’ll do some magic under the hood to minimize the amount of data that’s transferred from the phone to the watch but you can quickly see how pulling a user’s last few Tweets could be somewhat time consuming. Less Is More
 This classic proverb couldn’t be more true when considering JSON responses or messages between a Connect IQ app and a companion mobile app. If you are writing a web service to return tweets which your Connect IQ app will be calling consider what information you really need to have at the Connect IQ level. You can probably get away with only having the text of a Tweet and the username of the person who Tweeted said Tweet. Now you’re looking at only having to transfer about 250 bytes per Tweet. Referencing the example result on this Twitter API page, a resulting Tweet’s JSON would be: { "coordinates": null, "favorited": false, "truncated": false, "created_at": "Mon Sep 24 03:35:21 +0000 2012", "id_str": "250075927172759552", "entities": { "urls": [ ], "hashtags": [ { "text": "freebandnames", "indices": [ 20, 34 ] } ], "user_mentions": [ ] }, "in_reply_to_user_id_str": null, "contributors": null, "text": "Aggressive Ponytail #freebandnames", "metadata": { "iso_language_code": "en", "result_type": "recent" }, "retweet_count": 0, "in_reply_to_status_id_str": null, "id": 250075927172759552, "geo": null, "retweeted": false, "in_reply_to_user_id": null, "place": null, "user": { "profile_sidebar_fill_color": "DDEEF6", "profile_sidebar_border_color": "C0DEED", "profile_background_tile": false, "name": "Sean Cummings", "profile_image_url": "http://a0.twimg.com/profile_images/2359746665/1v6zfgqo8g0d3mk7ii5s_normal.jpeg", "created_at": "Mon Apr 26 06:01:55 +0000 2010", "location": "LA, CA", "follow_request_sent": null, "profile_link_color": "0084B4", "is_translator": false, "id_str": "137238150", "entities": { "url": { "urls": [ { "expanded_url": null, "url": "", "indices": [ 0, 0 ] } ] }, "description": { "urls": [ ] } }, "default_profile": true, "contributors_enabled": false, "favourites_count": 0, "url": null, "profile_image_url_https": "https://si0.twimg.com/profile_images/2359746665/1v6zfgqo8g0d3mk7ii5s_normal.jpeg", "utc_offset": -28800, "id": 137238150, "profile_use_background_image": true, "listed_count": 2, "profile_text_color": "333333", "lang": "en", "followers_count": 70, "protected": false, "notifications": null, "profile_background_image_url_https": "https://si0.twimg.com/images/themes/theme1/bg.png", "profile_background_color": "C0DEED", "verified": false, "geo_enabled": true, "time_zone": "Pacific Time (US &amp; Canada)", "description": "Born 330 Live 310", "default_profile_image": false, "profile_background_image_url": "http://a0.twimg.com/images/themes/theme1/bg.png", "statuses_count": 579, "friends_count": 110, "following": null, "show_all_inline_media": false, "screen_name": "sean_cummings" }, "in_reply_to_screen_name": null, "source": "Twitter for Mac", "in_reply_to_status_id": null } Using your web service to parse and minimize the data down to the aforementioned fields would result in a much smaller JSON object: { "text": "Aggressive Ponytail #freebandnames", "username": "sean_cummings" } Limiting the data to just what you need to display, and use will result in a much faster communications transaction. Of course, writing and hosting your own web service can be a bit much for a simple, glanceable widget.


# [How Do I Make a Watch Face for AMOLED Products](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-make-a-watch-face-for-amoled-products/)nMenu Connect IQ FAQ How do I Make a Watch Face for AMOLED Products?
 Since API level 3.1.0 The Venu is the first Garmin watch with an AMOLED screen, AMOLED displays provide vibrant colors with a high pixel density, but over time the organic materials used to create the display will decay. In order to mitigate the decay and prolong the screen life in general, a protective mechanism is deployed to watches that have AMOLED screen, such as Venu. What Qualifies as Burn-In
 Pixels in an AMOLED display only draw power when illuminated, so a pixel is considered on when rendering any color other than black, and is considered off when and only when rendering black pixel. Burn-in protection is only activated when Connect IQ watch face is in foreground and after system enters sleep mode. Under such conditions, if more than 10% of the screen pixels are on or any pixel is on for longer than 3 minutes, the system will shut off the screen. Most of the existing Connect IQ watch faces will trip the burn-in protector, however there is still hope to have an always-on watch face on AMOLED screens. Best Practices for AMOLED Screens
 Now on AMOLED Garmin products, your apps can have breathtaking presentations of information and gorgeous imagery, while still retaining days of battery life. However, now that we have given you all these gorgeous colors, could you, like, not use them? Please? Here is the challenge with AMOLED – every pixel draws power. If you want your apps to fall within the regular amount of battery life, you want to have as much black on screen as possible, especially in screens that are showing activity information. You’ll notice that with most of the native applications, black is the new black. It’s okay to work a periodic splash screen or gradient into your apps – make the app look great! – but for screens that are supposed to show constantly updating data, the blacker the better. Also, if you have header and footer gradients, try to have the darker parts at the outer edges. Just remember this handy guide when doing app layouts for AMOLED screens: How to Create Always-On Watch Faces
 Always On watch faces behave differently from MIP to AMOLED. With MIP screens, you can use View.onPartialUpdate to update a portion of the screen every second. With AMOLED screen, this is no longer allowed. Instead, when WatchUi.onEnterSleep is called, you are allowed to render a watch face that must obey the rules of the AMOLED burn-in protector: No more than 10% screen pixels can be on
 No pixel can be on longer than 3 mins
 
 Ways you can prevent burn in are by drawing the time with a thin font, shifting the time every minute as not to repeatedly leave the same pixels on, and not having static tick marks that leave the same pixels on. Note: App can detect whether a product has screen protection enforced by checking the value of DeviceSettings.requiresBurnInProtection . How to Test Your Always-On WatchFace
 Waiting for your watch face to run for 3 minutes or longer can be very painful. Luckily, the Connect IQ simulator ships with a new feature to simulate a 24-hour run within minutes. Simply go to ‘File-&gt;View Screen Heat Map’ to open the ‘Screen Burn-in Simulation’ dialog, then click the ‘Start’ button and let the time fly. Note: The menu option is only enabled when simulating a WatchFace on a device that supports screen protection, such as Venu.


# [How Do I Create a Connect IQ Background Service](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-create-a-connect-iq-background-service/)nMenu Connect IQ FAQ How do I create a Connect IQ Background Service?
 This post was written by Jim Miller, a Connect IQ developer in Phoenix, AZ. One of the new features in API level 2.3.0 is background services , or the ability for a Connect IQ application to have a service that runs even if the main application isn’t running. Background services have different abilities than the main process; a watch face or data field that can’t do communications itself, but the background process can! The most common example of this right now is a watch face that displays weather information from the internet. When something happens in the background, that process can optionally prompt the user if they want to start the main application, or the background can just collect data for the next time the main application runs. I’ll be talking about background services that take advantage of temporal events. In simple terms, it’s a process that’s time driven: it runs every “x” minutes, or can be set to run at a certain time. Temporal events can fire at most every 5 minutes, and will run at most 30 seconds each time it runs. The focus here will be on background processes that don’t try to start the main app when something happens, but just collect data for the main process. I’ve created a very basic watch face with a background service on the developer forum and included a .zip of the project in the first post so you can see the code and try it out yourself. The watch face itself displays the time, and the last data seen from the background service (plus a counter, etc). And all the background does is return a string with an “hh:mm” timestamp. While it isn’t useful, it does show the basics of backgrounding with a temporal event. In this case, there’s really isn’t much in the View class, but the things to look at are in App class and the file with the background process - the ServiceDelegate . When doing an app with backgrounding, there are a few things that come into play. In the sample project, you’ll see how these pieces all fit together. The Background Annotation
 To save memory, each time the background service runs only the necessary code is loaded. Background services have a 32 KB heap, so things can get tight! The (:background) annotation is used to indicate what classes, modules, and variables need to be available when the background service runs. The main App class is loaded by default, but you want to use the annotation on things like the ServiceDelegate and any things it may use or reference. (:background) class BgbgServiceDelegate extends Toybox.System.ServiceDelegate { Using it doesn’t mean that it’s only in the background service; classes, modules, and variables will be available in both the main process and background process. Service Delegate
 A background service can be triggered by different kinds of system events: step goal achievement, sleep/wake times, and temporal events, which are discussed below. The ServiceDelegate allows you to define what your app should execute when these events occur. The AppBase.getServiceDelegate() is how the service delegate in your code is found. Use the methods in the Toybox.Background module to register your service to fire on given triggers. Temporal Events
 Background.registerForTemporalEvents() is used to set how often the background temporal event runs. In the sample code, I do it as part of AppBase.getInitialView() after doing a check to make sure the app is running on a device that supports backgrounding. //register for temporal events if they are supported if(Toybox.System has :ServiceDelegate) { canDoBG=true; Background.registerForTemporalEvent(new Time.Duration(5 * 60)); } else { Sys.println("****background not available on this device****"); } Background.deleteTemporalEvent() can turn off the background process if desired. With a combination of those calls, you can get a bit of control over when a temporal event runs. For example, you can do things like not starting the temporal event until there is a connection to a phone, deleting the temporal event when your app no longer needs it, etc. Note: Normally when you have started a temporal event process, it will run even when the parent app isn’t running. With watch faces only the temporal event for the currently selected watch face will run. With some temporal events, you may want to pass an error status back to the main process instead of data. A good example of this would be a background service that does communications. In many cases, you will be passing back the data you received (I often just pass back the dictionary from the callback), but in the case of an error, I just pass back a Number representing the error. Then in AppBase.onBackgroundData() , I use instanceof Number to check if I got data or an error, and handle the error or data as needed. Here’s a simple example of that: function onBackgroundData(data) { if(data instanceof Number) { //indicates there was an error, and "data" is the error code } else { //got good "data" } } Interprocess Communication
 You pass data from your background service to the main process using Background.exit() in your ServiceDelegate function onTemporalEvent() { var now=Sys.getClockTime(); var ts=now.hour+":"+now.min.format("d"); Sys.println("bg exit: "+ts); //just return the timestamp Background.exit(ts); } AppBase.onBackgroundData() is how the main process gets the latest data from what the service returned by Background.exit() . In the main process, when it first starts, I’ll see if data is in the object store, and if so, then you display that as a “last known value”. If you don’t do something like this with a watch face, each time you leave the watch face and come back, there wouldn’t be any data until the background runs again. function onBackgroundData(data) { $.counter++; var now=Sys.getClockTime(); var ts=now.hour+":"+now.min.format("d"); Sys.println("onBackgroundData="+data+" "+counter+" at "+ts); bgdata=data; App.getApp().setProperty(OSDATA,bgdata); Ui.requestUpdate(); } You can’t use AppBase.setProperty() in the background process to pass data in the object store or settings; if you try, an exception is thrown. You also can’t pass information between the main process and the background with global variables. The word “process” is important here: global variables are per process, so the same global is only global for that process. A variable defined globally exists in both the main process and background process, but each maintains its own copy and they’re never synced.. That been said, the only way to pass data from the main app to the background service is as a property. Your ServiceDelegate can retrieve it with AppBase.getProperty() . It can be something in the object store or from settings. Make sure to handle the case where the background may not have the data it needs here, as there are things that may not yet have valid values. The background can run more than once before the main process sees it in AppBase.onBackgroundData() . The main process only sees the last one, not all of them, but in the background process you can use Background.getBackgroundData() to get what’s currently queued for the main process, but not yet delivered. You can combine that with what the background process has that’s new, and return it all. Other Points
 Watch Faces - Watch faces are a bit different than other app times when it comes to if/when a background service runs, and this is by design. The background service for a watch face will only be run if that watch face is the “active” watch face (the one currently selected to be used). Think of the case where you have two watch faces installed, that both get weather data from the same source, with a limit on requests per day. There’s no reason for the background service for the non-active watch face to run, as it would just use up the quota of requests per day.
 Size of response to makeWebRequest() calls - If you are doing Communications.makeWebRequest() calls in your background process, one thing to keep in mind is the size of the response you get back. The background process has limited memory. When a response is received, there must be enough memory to contain both the response and to build the dictionary passed back to your callback.
 Notes about the Simulator: - You can test backgrounding in the simulator. In the case of temporal events, they will occur as scheduled, but under the “Simulation” menu, you can trigger the background process to run.
 
 There is a known issue with the simulator with background apps: the simulator will run the background services of apps you’ve tested in it, even if it isn’t the “active” app being tested. So if you are testing “app a” and then switch to “app b”, the background for “app a” will run as well as the background for “app b”. Even if your current target doesn’t have a background service the simulator may attempt to start it. The Connect IQ team is aware of the issue and will address it in a upcoming release As you can see, background services are a powerful new addition to the Connect IQ toy box. They allow your app to periodically poll the internet for information, including watch faces and data fields. What can you use them for? About The Author Jim Miller is a Connect IQ developer in Arizona. “In early 2015, I had a forerunner 15, and liked the GPS and step tracking. Then the original vívoactive was announced, and I pre-ordered it, and downloaded the CIQ 1.0.0 SDK the same week!” You can see his apps on the app store and find him on Instagram , his Connect IQ Facebook Page , or on the Connect IQ forums .


# [How Do I Optimize Bitmaps](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-optimize-bitmaps/)nMenu Connect IQ FAQ How do I optimize bitmaps in my app?
 In our world of HTML, megapixels, and gigabytes it can be easy to forget the resource usage of bitmap images. Connect IQ’s constrained embedded environment requires developers to consider the cost of bitmaps when making pages. Thankfully, the Connect IQ SDK provides a number of tools to control your image costs while make a great looking app. Bit Depth
 The bit depth of the image refers to how many bits are being used to represent each pixel. For every bit you add per pixel, you double the number of colors you can represent as well as double the memory used for the entire image. This affects how many colors you can represent in the image, and the amount of memory the image will use when it is loaded from resources. In this table, we show the number of colors and the memory size of a 100 x 100 image. The higher the bit depth, the more colors you can use at the cost of more memory used. Bit Depth Colors Image Size (KB) 
 1 2 1.22 
 2 4 2.44 
 4 16 4.88 
 8 256 9.77 
 16 65536 19.53 
 Connect IQ supports images of bit depth of 1 BPP, 2 BPP, 4 BPP, 8 BPP, and 16 BPP. Palettes
 Different Connect IQ devices have different display bit depths. Some products are able to display thousands of colors, while others are constrained to 16 colors. In general devices fall under three categories: 16 Color Palette: The product is only able to display 16 colors
 RGB222: The product is able to display 64 colors. In this scenario, 2 bits are available for red, green, and blue.
 RGB565: The product is able to display 65535 colors. In this scenario, 5 bits are available for red and blue, and 6 bits are available for green.
 
 The Dc.setColor API takes an RGB888 color as an input. It will always map the input color to the closest color available on the device. Product Colors Bit Depth 
 Fenix 3 16 (Palette) 4 
 Fenix 3 HR 16 (Palette) 4 
 Quatix 3 16 (Palette) 4 
 D2 Bravo 16 (Palette) 4 
 D2 Bravo Titanium 16 (Palette) 4 
 Forerunner 230 16 (Palette) 4 
 Forerunner 235 16 (Palette) 4 
 Forerunner 630 16 (Palette) 4 
 Forerunner 735xt 16 (Palette) 4 
 Forerunner 920xt 16 (Palette) 4 
 EPIX 64 (RGB222) 8 
 Fenix 5 64 (RGB222) 8 
 Fenix 5 Plus 64 (RGB222) 8 
 Fenix 6 Series 64 (RGB222) 8 
 Forerunner 245 64 (RGB222) 8 
 Forerunner 645 64 (RGB222) 8 
 Forerunner 945 64 (RGB222) 8 
 Vivoactive 64 (RGB222) 8 
 Vivoactive HR 64 (RGB222) 8 
 Vivoactive 3 64 (RGB222) 8 
 Vivoactive 3 Music 64 (RGB222) 8 
 Venu 65535 (RGB565) 16 
 EDGE 520 65535 (RGB565) 16 
 EDGE 820 65535 (RGB565) 16 
 EDGE 820 Explore 65535 (RGB565) 16 
 EDGE 1000 65535 (RGB565) 16 
 EDGE 1000 Explore 65535 (RGB565) 16 
 Oregon 7 Series 65535 (RGB565) 16 
 Rino 7 Series 65535 (RGB565) 16 
 16 Color Palette
 While the goal is to always provide the best display possible, sometimes a device are constrained by the display technology used or by the amount of memory used by the underlying screen buffer. The choice to only support a 16 color palette is often made to sacrifice color depth at the expense of other product features. For devices that use a 16 color palette, the colors are programmed into the device. The Graphics color constants map directly to the 16 available colors RGB222
 Some devices have 64 available colors. These colors are chosen using 2 bits for red, 2 bits for green, and 2 bits for blue. The graphics system will internally represent bitmaps as 8 bits per pixel. RGB565
 Some devices have 65535 available colors. These colors are chosen using 5 bits for red, 6 bits for green, and 5 bits for blue. The graphics system will internally represent bitmaps as 16 bits per pixel. Resources
 Connect IQ has a number of options to help developers specify how they want their images imported. &lt;!-- Use the dithering option to enable or disable auto dithering of the image --&gt; &lt;bitmap id="Logo" x="center" y="12" filename="Logo.png" dithering="none"&gt; &lt;!-- The palette option allows you to reduce the bit depth of an image. Connect IQ will pick a bit depth based on the number of colors specified in the palette. If your image does not have transparency, use the disableTransparency option to remove the extra color used to represent transparent --&gt; &lt;palette disableTransparency="true"&gt; &lt;!-- Logo is black on white text, so using four colors to get shading while reducing the color depth to 2 bpp --&gt; &lt;color&gt;FFFFFF&lt;/color&gt; &lt;color&gt;AAAAAA&lt;/color&gt; &lt;color&gt;555555&lt;/color&gt; &lt;color&gt;000000&lt;/color&gt; &lt;palette&gt; &lt;/bitmap&gt; There’s a lot of options in that block, so let’s go through them one by one. Dithering
 Connect IQ by default uses Floyd-Steinberg dithering when importing images. The dithering algorithm helps correct for the error when mapping a high color image to a low color space representation. This is preferable when importing a photograph, but when importing a graphic it can introduce random pixels that are not wanted. To directly map colors, set the dithering attribute to “none”. &lt;bitmap id="Logo" x="center" y="12" filename="Logo.png" dithering="none"&gt; Palette
 When importing images, Connect IQ will always default to the best available bit depth for the device. This means on 16 color devices the images will be imported as dithered 4 bit images, while on RGB222 devices the images will import as dithered 8 bit 64 color images. We want to make sure the Doge looks as recognizable as possible. This also means that, by default, images for a Vivoactive will take twice as much memory as images for the Fenix 3. That’s fine if you have a one image watch face, but in the tight constraints of a data field it could be the difference between working and running out of memory. If you have a low color image, reducing the bit depth can save precious runtime memory. By setting the import palette, you can communicate the total number of colors the image should use. &lt;palette disableTransparency="true"&gt; &lt;!-- Logo is black on white text, so using four colors to get shading while reducing the color depth to 2 bpp --&gt; &lt;color&gt;FFFFFF&lt;/color&gt; &lt;color&gt;AAAAAA&lt;/color&gt; &lt;color&gt;555555&lt;/color&gt; &lt;color&gt;000000&lt;/color&gt; &lt;palette&gt; This block says the image should only use four colors - white, light gray, dark gray, and black. The palette is bound to the colors available on a device. If you specify colors not available on a device, they will be mapped to the closest available colors. On 16 color and RGB222 devices the resource compiler automatically uses an extra color - the transparent color - to represent transparent areas. Disabling transparency tells the resource compiler that the image doesn’t have any transparent areas, saving one color in the converted image and potentially reducing bit depth. With the four colors set and transparency resource compiler creates a 4 bit image; with no transparency it will create a 2 bit image for a 50% memory savings. In general, use low bit depth images to save memory when possible. If you have a logo that can be represented with a small number of colors, use the palette and disable dithering to make a sharper image with a lower bit depth. Remember: great looking 16 color images will work across all wearables. 64 color images add some shading options, but you’ll need to weigh the balance of image quality and memory savings. Edge bike computers have better color representation, but using high bit depth images can quickly eat your runtime memory as well.


# [How Do I Override the Goal Animations](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-override-the-goal-animations/)nMenu Connect IQ FAQ How do I Override The Goal Animation?
 Since API level 1.3.0 The screen displayed when activity tracking goals are reached can be overridden by the active watchface. This is done by implementing the getGoalView() function in the application’s AppBase class. class AppBase { function getGoalView(goalType); } The ‘getGoalView()’ function is passed one of the supported goal view types: ‘GOAL_TYPE_STEPS’, ‘GOAL_TYPE_FLOORS_CLIMBED’, or ‘GOAL_TYPE_ACTIVE_MINUTES’. Not all types are supported on every product. The application can return a view to be displayed from this function, or null to allow the system to display the default goal display. Goal Views can start animations, similar to the main WatchFace view when onExitSleep() is triggered. Goal Views are displayed for approximately 10 seconds. When they expire, the system will call ‘getInitialView()’ to switch back to the main WatchFace view.


# [How Do I Use Custom Fonts](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-use-custom-fonts/)nMenu Connect IQ FAQ How do I use custom fonts?
 This guest post was written by Hermo Terblanche , a Connect IQ developer in South Africa. Have you ever seen an app in the Connect IQ app store that made you wonder, “That is so cool! How did the developer do that?” In order to draw attention to your app you need to stand out from the rest, by for example applying some really cool font tricks. I am going to let you in on some of my secrets from my own Connect IQ creations . Hopefully this will inspire you to create your very own jaw-dropping apps for Garmin Connect IQ devices. Let’s jump straight into the magic! You’ll need the following tools: BMFont - For exporting fonts to the required format for Connect IQ. You can read more about this in the Programmer’s Guide as well as the UX Guide 
 Graphics editor / Tool - For editing font png files. I prefer to use Photoshop to achieve the desired effects, but they can also be achieved using GIMP 
 
 Font Reflection
 This technique is really simple and could easily be achieved in one of two ways: Approach A
 For the watch face Summer Sunset , I used a free font called Sunset that I downloaded and exported to a PNG using BMFont. This font combines each number and its corresponding reflection into a single glyph. This means that when you draw a number, it draws both the number and reflection as a single character. The benefit of this approach is efficiency: you only need a single font which requires fewer resources and results in a smaller compiled PRG file. Also, your code also runs cheaper as you only need a single statement to draw the number which is more battery friendly. Finally, you don’t have to separately manage the positioning of drawing a number’s reflection, making this the simplest approach. The downside is that you cannot have separate colors for the number and its reflection because the glyph is treated as one atomic character, and only one color can be applied to the glyph as a whole. To see the skyline behind the time, you first draw the skyline, then you specify a transparent background color for the font and finally draw the time on top of the skyline: //draw skyline here .. //load custom font var font = Ui.loadResource( Rez.Fonts.Sunset ); //set the time's color and draw it dc.setColor(Gfx.COLOR_DK_GREEN, Gfx.COLOR_TRANSPARENT); dc.drawText(timeX,timeY, font, timeStr, Gfx.TEXT_JUSTIFY_CENTER); This approach is the most straightforward and does not need any further image processing of the font once it has been exported using the BMFont tool. Approach B
 The Reflection watch face is a bit more advanced and involves some image processing, but it offers the benefit of specifying a different color for the time and the reflection. This approach uses two separate fonts. For this I also downloaded a free font and exported it to a PNG using BMFont. I then duplicated the *.PNG and *.FNT files and renamed them to something meaningful so I could easily distinguish between the files of the two different fonts. Using some Photoshop skills I transformed each glyph in the duplicated PNG file to look like a reflected character. It is important to keep in mind with this approach is that it works best with a monospaced font; having constant glyph sizes in both fonts makes it easier to align the normal and reflected time when drawing. Without going into too much detail about the exact image processing steps, here is a basic outline of what to do: For each glyph (one at a time):
 Use the selection tool to select a glyph
 Use the transform menu and flip the selection vertically
 Using the transform menu, either skew or distort the selection to get the desired angle of the character. Keep in mind that you cannot skew too much because you want the reflection of the time to still fit within the screen. In the screenshot above you will notice that the bottom of the reflected “1” touches the screen boundary. A more skewed effect will cause the reflected “1” to be clipped. You have to experiment a few times to get it right. This step is the most challenging, but also the most rewarding one!
 You have to move the transformed selection to align it alongside other transformed glyphs. This makes it easier to specify the character coordinates in the *.FNT file.
 Save the png for the reflection font once all glyphs have been transformed.
 In Photoshop, use the selection tool to find the new x, y coordinates for each transformed glyph, and change the corresponding values in the duplicated *.FNT file.
 Make sure to point the file property in the duplicated *.FNT file to the duplicated *.PNG (reflected font).
 In code load your two fonts, and after you’ve drawn the normal time, you draw the same time using the reflection font. For the reflected time, you need to align the characters with the bottom of the normal time’s characters.
 
 Below is an illustration of some of the glyphs from the normal font and their corresponding reflected glyphs in the reflection font. //load custom font for the normal time var normalFont = Ui.loadResource( Rez.Fonts.Normal ); //load custom font for the reflected time var reflectedFont = Ui.loadResource( Rez.Fonts.Reflected ); //set the normal time's color and draw it dc.setColor(Gfx.COLOR_DK_GREEN, Gfx.COLOR_TRANSPARENT); dc.drawText(timeX,timeY, normalFont, timeStr, Gfx.TEXT_JUSTIFY_CENTER); //set the reflected time's color and draw it dc.setColor(Gfx.COLOR_ORANGE, Gfx.COLOR_TRANSPARENT); dc.drawText(offsetX,offsetY, reflectedFont, timeStr, Gfx.TEXT_JUSTIFY_CENTER); Fonts With Two Colors
 Connect IQ supports only one color in custom fonts. This is because the font’s PNG is a grayscale image and therefore has only one channel. You cannot create a font to display multiple colors. Below is an illustration of the concept that is not possible within a single font: But fear not! With some clever tricks it is possible to create the effect of a font that displays multiple colors. The watch face Watch Me displays its time using two colors: white border and blue fill. The magic behind this trick involves a combination of two fonts with different masks. Below is an illustration of some of the glyphs from the two different font masks. The top image is the font for the border, while the bottom font is for the inner fill. An easy way to remember which is which, is to remember that white is the area that will be drawn onto the screen in a color of your or the user’s choice. The top mask is the original font that was exported using the BMFont tool. For the bottom mask I created a duplicate of the top mask, and then basically inverted the colors to ensure it will only draw the inner area in a specific color. //load custom font for the border var borderFont = Ui.loadResource( Rez.Fonts.Border ); //load custom font for the inner fill var innerFillFont = Ui.loadResource( Rez.Fonts.InnerFill ); //set the time's border color and draw it dc.setColor(Gfx.COLOR_DK_GREEN, Gfx.COLOR_TRANSPARENT); dc.drawText(timeX,timeY, borderFont, timeStr, Gfx.TEXT_JUSTIFY_CENTER); //set the time's inner fill color and draw it dc.setColor(Gfx.COLOR_ORANGE, Gfx.COLOR_TRANSPARENT); dc.drawText(timeX,timeY, innerFillFont, timeStr, Gfx.TEXT_JUSTIFY_CENTER); Font With a Diagonal Orientation
 The idea to write text with an orientation other than horizontal is not something I innovated; I first saw it in another watch face in the store. Being a curious developer I had to try it out myself. The result of this experiment can be seen in my watch face South Africa . The time is displayed diagonal in either an ascending or descending orientation based on a user’s preference. Each orientation is created with its own separate font. You need to apply a rotation factor to each glyph in your font PNG. Rotating the glyphs will result in glyphs that are slightly bigger than the original. Below is an illustration to get an idea of what the PNG for each font looks like after all glyphs have been rotated: When drawing text diagonally, you can no longer draw the string as a single entity; otherwise you’ll just end up with a horizontal line of text with tilted characters, similar to what you now see in the above illustration. The real trick is to draw each character individually, but for each character adjust the y and x coordinates appropriately. For descending orientation, you need to increase the y coordinates, and for ascending you need to decrease it. The x coordinate will always increase in both scenarios. The glyphs have to overlap each other in order to create the diagonal effect. This is where a transparent background color does the trick! The angle of rotation that you would like for your font is all up to you and you can experiment with different degrees of rotation in your graphics editor. In order to know where to draw the next character, you could maintain an array of coordinates. It is a lot easier to manage and draw diagonal text using a monospaced font because any character can be drawn at the same coordinate without causing gaps of varying size between adjacent characters. //predefined coordinates based on diagonal angle and orientation var ascCoords = [[21,143],[42,129],[62,119],[73,108],[93,95]]; var descCoords = [[21,34],[42,48],[62,58],[73,69],[93,82]]; //set background color transparent to prevent clipping of characters dc.setColor(Gfx.COLOR_WHITE, Gfx.COLOR_TRANSPARENT); //string to be drawn var time = clock.hour.format("d") + ":" + clock.min.format("d"); var coords, font; //determine the font and coordinates to use based on orientation if(Orientation == "Descending"){ coords = descCoords; font = Ui.loadResource(Rez.Fonts.fontDesc); } else{ coords = ascCoords; font = Ui.loadResource(Rez.Fonts.fontAsc); } //draw each character individually for( var i = 0; i &lt; time.length(); i++ ) { var char = time.substring(i,i+1); dc.drawText(coords[0], coords[1], font, char, Gfx.TEXT_JUSTIFY_LEFT); } Dynamic Color Filling
 In my signature watch face NoFrills , I use an easy trick to create a special effect that makes the time fill up with water. It effectively serves as a progress gauge for activity tracking, while at the same time conserves real estate on the screen. Talk about a dual-purpose clock! You only need a single font for this trick, and best of all: there is no image processing required. Only the power of Connect IQ is enough to achieve this! Again, a monospace font provides the best results and is simpler to work with. Determine the size and coordinates of the area (rectangle) that the text you would like to draw, will occupy on the screen.
 Draw a filled rectangle of this size at the predetermined coordinates. The color of this rectangle should be the color that you would normally have used for the text.
 Draw any special effects on top of the filled rectangle, but before you draw the text. In NoFrills’ case, I draw the filled rectangle that represents the water level.
 Set the foreground color of your text to transparent and the background color to something else, like the background color of the screen. This effectively creates a mask that clips everything you have drawn in the previous steps.
 Now draw your text on top of it all, compile and run it and finally stare in awe at your amazing production!
 //load custom font var font = Ui.loadResource( Rez.Fonts.MyFont ); //draw filled rectangle to represent text's color dc.setColor(Gfx.COLOR_WHITE, Gfx.COLOR_WHITE); dc.fillRectangle(rectX, rectY, width, height); //draw filled rectangle to represent water level dc.setColor(Gfx.COLOR_BLUE, Gfx.COLOR_BLUE); dc.fillRectangle(effectX, effectY, width, effectHeight); //create and draw the clipping mask dc.setColor(Gfx.COLOR_TRANSPARENT, Gfx.COLOR_BLACK); dc.drawText(timeX, timeY, font, timeString, Gfx.TEXT_JUSTIFY_CENTER); You can find Hermo on Twitter , Facebook , Instagram , and the Connect IQ Developer Forum . See Hermo’s Connect IQ apps in the Connect IQ Store .


# [How Do I Use a Mapview](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-use-a-mapview/)nMenu Connect IQ FAQ How do I use a MapView?
 Garmin built itself as a company by making location aware products, and has grown to make products that serve automotive, aviation, marine, fitness, and outdoor markets. A cornerstone to location awareness is digital cartography. Garmin products are often used outside of cell coverage, and our users depend on us to know where you are even when disconnected from the cloud. For over a decade Garmin has been digitizing the world and putting maps on devices of all shapes and sizes. With the addition of MapView objects, Connect IQ now allows your apps to take advantage of the digital cartography included on Garmin devices. You can use MapView objects to provide location context to the user, provide a preview of a course or route, or let the user browse their surroundings. Integrating Map Views
 Let’s talk through a common use case on Garmin devices. Assume the use case where you have a cloud database of routes that the user can choose to download to the device. You want to give the user a preview of the route on the map and give a clear call to action to the user to download. You also want to allow the user to touch the map to browse the route. Setting The Scene
 The first thing you need to do is tell the map where on the Earth you want to focus the user’s attention. The method setMapVisibleArea allows you to set a bounding box of Location objects that define what part of the world should render on screen. Overlaying Content
 MapView objects allow for two kinds of overlays: markers and polylines . A MapMarker instance represents a single location on the map. You can use either the default Garmin pin, or you can provide your own BitmapResource object. If you use a custom marker, you need to set the pixel that will be drawn at the exact location (the hotspot). If you pass an array of MapMarker objects to the MapView instance, it will add all of them to the map. Calling setMapMarker will clear whatever markers are currently set. A MapPolyline instance represents a series of coordinates, like a course. You can set the width and color of the polyline. You can set the polyline for a MapView using setPolyline . A MapView instance can only have one MapPolyline instance set at any given time. Preview and Browse
 Going back to our example, remember that we want to allow the user to have a preview of the route with a call to action, but let them browse the content if they want a closer look. The MapView class handles both use cases in a single View using the map mode . In MAP_MODE_PREVIEW the map view centers on an area. You can add a layout above the map with buttons and selectables to provide context and actions. You can use setScreenVisibleArea to communicate to the MapView instance what portion of the map is not obscured by your user interface. Switching the map mode to MAP_MODE_BROWSE changes the map view to a browse interface. The browse interface will be same browse interface used natively by the device. Tying it Together
 We want to show the user a preview of the course we want to download before they download it, but how can we show it before we download the full course? One way to bring a polyline to your app is with a Google Polyline Algorithm Format . This allows you to send a polyline to your Connect IQ app as a string that can be decoded back into a polyline. The function below will decode a polyline string into an array of Location objects. To conserve memory, it will begin skipping over coordinates as the polyline grows in size, essentially downscaling the line as it grows in length. // Constant used to downscale detail as // line grows in length to conserve memory const MAX_POLYLINE_OBJECT_COUNT = 233; // Returns the decoded polyline string // in an array of longitudes and latitudes function decodePolyline(polyline) { polyline = polyline.toCharArray(); var len = polyline.size(); var indexJump = Math.ceil(len / MAX_POLYLINE_OBJECT_COUNT); var poly = []; var index = 0; var lat = 0; var lng = 0; var skipIndex = 0; while (index &lt; len) { var byte = 0; var shift = 0; var result = 0; do { byte = polyline[index].toNumber() - 63; result = result | ((byte &amp; 31) &lt;&lt; shift); shift += 5; index++; } while (byte &gt;= 32 &amp;&amp; index &lt; len); var dlat = ((result &amp; 1) ? ~(result &gt;&gt; 1) : (result &gt;&gt; 1)); shift = 0; result = 0; do { byte = polyline[index].toNumber() - 63; result = result | ((byte &amp; 31) &lt;&lt; shift); shift += 5; index++; } while (byte &gt;= 32 &amp;&amp; index &lt; len); var dlng = ((result &amp; 1) ? ~(result &gt;&gt; 1) : (result &gt;&gt; 1)); lat += dlat; lng += dlng; if (indexJump == 0 || skipIndex % indexJump == 0) { var p = new Position.Location({:latitude=&gt;lat/1e5, :longitude=&gt;lng/1e5, :format=&gt;:degrees}); poly.add(p); } skipIndex++; } return poly; } In our UI we want to allow the user to switch between our user interface with the call to action and allowing them to browse. Rather than pushing and popping the map view with different modes, we can use a single view and switch modes in the delegate. class MapSampleMapDelegate extends Ui.BehaviorDelegate { var mView; function initialize(view) { BehaviorDelegate.initialize(); mView = view; } function onBack() { // if current mode is preview mode them pop the view if(mView.getMapMode() == Ui.MAP_MODE_PREVIEW) { Ui.popView(Ui.SLIDE_UP); } else { // if browse mode change the mode to preview mView.setMapMode(Ui.MAP_MODE_PREVIEW); } return true; } function onSelect() { // on enter button press chenage the map view to browse mode mView.setMapMode(Ui.MAP_MODE_BROWSE); return true; } } Now in a single view we can provide a UI with a call to action and preview of the course and allow the user to browse the content as well. Conclusion
 Hopefully you can see from this that the MapView class is a powerful addition to the Toybox. By combining Garmin digital cartography with your content, you can bring a whole new level of location awareness to your apps.


# [How Do I Use the Connect IQ Mobile SDK](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-use-the-connect-iq-mobile-sdk/)nMenu Connect IQ FAQ How do I use the Connect IQ Mobile SDK
 The first step to writing a partner powered Connect IQ app is getting your partner app and Connect IQ app connected. The Partner SDK provides the tools for you to do this how you feel it best fits into the flow of the app. We’re going to take a look at a couple different approaches using the Disc Golf sample featured in this previous blog post . Get the Latest Connect IQ Mobile SDK
 Make sure you have the latest Partner SDK from the developer site . Staying up to date keeps you in sync with the latest APIs and functionality. Note\ : iOS developers should get the latest SDK from the developer site. An important update was made to the iOS mobile SDK to support upcoming devices. Checking for Garmin Connect Mobile
 The Partner SDKs are designed to work in unison with Garmin Connect Mobile. This means the user of your partner app will need to have Garmin Connect Mobile installed. The Partner SDKs provide an API to check the status of Connect Mobile as well as an API to open the Garmin Connect Mobile store page (with an optional simple dialog). Connect First
 You may be using your Connect IQ app to augment the functionality of your partner app/existing mobile app. If this is the case you also probably don’t want to force a user to select a device before using the rest of your mobile app. We’ll handle this case by providing a menu option to select a device; this is also a good option to include even if you require a device connection so the user has the ability to change which device is connected within the app. When a user selects that menu option we’ll launch a new page which lists the connected devices, save the device the users selects and then close the page. In iOS, the showConnectIQDeviceSelection call will launch GCM for the device list and will re-launch your app with a list of paired CIQ devices. It is important to configure your app to be re-launched by GCM for this to work. Checking If the Connect IQ App Is Installed
 Finally you’ll need to make sure your Connect IQ app is installed on the device the user selected regardless of the flow you use to connect. The Partner SDKs provide APIs to check the status of an app. If the app isn’t installed you’ll want to prompt the user to install your Connect IQ app before proceeding. You’ll want to prompt the user to install your Connect IQ app before proceeding. The Partner SDKs provide APIs to open the Connect IQ store – within Connect Mobile – to your app’s store page. Use the showConnectIQStoreForApp: API in iOS or openStore API in Android. Now that you have established the connection with the device, you can now use the Communications.transmit API to send a message directly from a Connect IQ app to a wearable and the sendMessage to put a message in the Connect IQ app mailbox from your mobile app. Note that if the Connect IQ app is not running, the message will persist until the app is opened by the user. This allows a phone app to update information for the watch app even if the watch app is not currently running. See it in Action: The Connect IQ Disc Golf App
 If you want to see all of this in action, you can check out the Connect IQ Disc Golf sample. You can download the Connect IQ app from the Connect IQ Store and the Android partner app from the Play Store . The source code for both applications is available on GitHub .


# [How Do I Create an Audio Content Provider](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-create-an-audio-content-provider/)nMenu Connect IQ FAQ How do I create an Audio Content Provider?
 In 2018 Garmin has launched multiple music capable wearable products that allow users to leave their phone at home while they live their active lifestyle. Users can copy their music library directly to the device, or they can install a Connect IQ audio content provider app that acts as a bridge between the wearable and a Content Delivery Network (CDN). Audio content providers enable third-party music services to deliver protected content. They can download content from a CDN via Wi-Fi directly to the watch, and act as a plug-in to the native media player. The content is encrypted before it reaches disk and decrypted during playback. This post explains all the roles an audio content provider fills as well as the basics of implementation. Syncing Content to the Device
 The Garmin music wearables interact with third party services by syncing content to the device for later playback. Users can launch the music app in a sync configuration state that lets them select what content they want to sync down to the device. The sync configuration user interface is defined by the audio content provider app. If you want your interface to be consistent with the device look and feel, the WatchUi.Menu2 class will do much of your implementation for you. If you want to tailor your look and feel to your brand, the WatchUi.CustomMenu provides much more flexibility. Audio content provider apps can download content from a content delivery network via restful services directly to the watch. To get a song onto the watch the following should occur: The Connect IQ app uses a web API to request an audio file download 
 The back-end service will serve up the audio file from the CDN 
 The Connect IQ app will store the downloaded audio file on the watch’s file system. As the data is written to the filesystem the content is encrypted; no un-encrypted content ever gets written to the filesystem. 
 Content downloaded by audio content provider apps are protected in several ways: Music apps and audio files stored in hidden folders on device 
 Apps and audio files are encrypted using AES–128. 
 App can destroy all downloaded and reset encryption key in a single call 
 Each application gets access to a storage sandbox. The storage files are encrypted and cannot be accessed by any other apps on the system. The system will initiate a sync after the configuration step. The user will be prompted to start a sync, and if they agree the device will activate Wi-Fi, and upon connection the system will request the app create a SyncDelegate . The delegate is used to notify the app that a sync has started, has been stopped, and to determine if a sync is needed. In the onStart method of the SyncDelegate , the app needs to download the songs chosen in the sync configuration step. The app notifies the system of the sync progress, so the UI can be updated. Playback
 Once the content is downloaded, the Connect IQ app can serve up the audio files to the native media player for playback. They can either use the media controls to control playback, or the user can select what content they want to listen to by entering the playback configuration mode of the app. Playback Configuration
 When the user enters playback configuration, the app should allow them to change their audio content (playlists, books, or podcasts) within the app. The interface for playback configuration is defined by the audio content provider. This flow allows a user to control what songs to playback. The app can allow the user to choose from playlists or individual songs. The app can choose to start playback from this flow using Media.startPlayback() , or let the user select play from the media player. Playback
 Playback is driven by the media player, but the app can decide what media player controls to display and what content to play. This is enabled by defining a Media.ContentDelegate class. The content delegate is responsible for providing a Media.ContentIterator that provides the media player an iterator of Media.ContentRef instances that represent the downloaded songs. The content iterator also provides a Media.PlaybackProfile that allows customization of the media player interface. The skip buttons can be disabled on a per-song basis, and Media.ContentRef metadata will display in the player. As audio is played, the media player sends playback information to the ContentDelegate that can be used for reporting purposes. The Connect IQ app can store the reporting information for each play of a song and send it back to the provider via web calls, or during sync. Hints and Tips
 The Toybox.Media module provide tools for downloading and interfacing with audio content, but for keeping reporting information you should take advantage of the Toybox.Application.Storage module. The Connect IQ storage system provides a simple key/value system for persisting content, but values are limited to 8KB. If you’re storing lots of playback information, it is important to design an approach with these limits in mind. It’s best to use a flat structure, as nested tables will quickly grow past your 8 KB limit. Store playlist ids ( Px ) in a top-level array using a known key (“playlists”). Give each playlist and song id ( Sx ) their own dictionary entry in Storage. In playlists store the song id references, and in song ids store the ContentRef id and an array of plays. This allows each song to use most of the storage for song playback storage. Conclusion
 With Connect IQ audio content provide apps you can: Deliver your protected content securely to Garmin music-enabled wearables via your existing content delivery web services
 Provide your users the ability to listen to their favorite content from your service while leaving their phone behind
 Provide an experience that integrates seamlessly with the native watch user interface
 Maintain accurate royalty calculations by caching playback information in encrypted app storage to send to your reporting services via the web during sync


# [How do I Integrate Connect IQ and Travis CI](https://developer.garmin.com/connect-iq/connect-iq-faq/how-do-i-integrate-connect-iq-and-travis-ci/)nMenu Connect IQ FAQ How do I integrate Connect IQ and Travis CI?
 This pro-tip was written by Achim Seufert . You probably have already seen them all over GitHub ; these fancy little badges indicating among other things that a project’s build-process is passing or failing. Check Bootstrap ’s main-page for example: They’re pretty much becoming a standard for projects using build-tools like Maven , Gradle , npm , etc. The badges actually aren’t a feature of GitHub itself, but originate from services like TravisCI , AppVeyor , or David . The README files of GitHub projects, usually plain Markdown-files being rendered to HTML, simply point to automatically generated images provided by these services. In this tutorial I’ll show you how to use TravisCI to build and track status of your Connect IQ project. Getting Started
 TravisCI is a free-of-charge continuous-integration-service for open-source projects that seamlessly integrates with your GitHub repository. Whenever you push some changes to your repository, TravisCI will fire up a fresh VM which can run a set of tasks which usually include compiling your code, executing unit-tests, packaging, and so on. Furthermore there’s a wide variety of options that let you define notifications being sent from TravisCI in case one of these tasks will fail or behave in an unexpected way. Our goal should be to have TravisCI build and package a Connect IQ-app and visualize the outcome of these tasks with either passing or failing. Building via the Command Line
 At this point I’m assuming that you already have created a GitHub repository containing your Connect IQ project. The most important task is getting our app built and packaged via command line instead of using the Visual Studio Code extension . This can be achieved by invoking the Monkey C compiler through the monkeybrains.jar library which can be found in the bin-folder of your Connect IQ SDK. We also have to keep in mind that this should run on a UNIX-based console, since TravisCI starts a Linux-VM for us. As a side note it’s good to know that TravisCI is stateless, meaning you don’t have to worry about cleaning up your environment after a build; you’ll get a fresh VM every time a build gets triggered. Our compile/package command should look something like this: java -jar "${MB_HOME}/bin/monkeybrains.jar" ${PARAMS} ${SOURCES} We basically just use Java and execute the JAR’s main-class, passing in some params and sources. In order to make things a bit more generic and convenient, I’ve created a shell-script ( mb_runner.sh ) which wraps the calls to the monkeybrains.jar . Place it in your project root alongside the manifest.xml . The params are built automatically; source and resources will also automatically be found and passed over. Finally, the script can also be used to package the app. Compiling and packaging an app requires a “Developer Key” (see the Getting Started in the Programmer’s Guide). The three things the script needs in order to run are: The MB_HOME environment variable to be set and pointing to your Connect IQ SDK
 The MB_PRIVATE_KEY environment variable to be set and pointing to your private key
 A file called mb_runner.cfg , also residing in your project-root, which contains a few details specific to your app. Check out the mb_runner.cfg.sample and adjust the settings to fit your needs.
 If you want to see more details about mb_runner read the README.md . Running the following will build and package your app: ./mb_runner.sh package Prepare the Project/Repository for TravisCI
 There are three more things to do: Create the .travis.yml config file in your repository-root
 In your repository root you’ll need to create a simple shell-script travis.sh in which we’ll be preparing/invoking the mb_runner script
 Link your repo with TravisCI
 The .travis.yml file should look like this: language: java jdk: oraclejdk8 before_script: - sudo apt-get install -qq dos2unix script: - ./travis.sh Here we simply tell TravisCI to use a default Java environment (with Oracle’s JDK8 installed), install the required dos2unix package, and run the travis.sh shell script shown below. This will prepare our freshly created VM-environment so we can run our actual MonkeyC-compile-job: #!/bin/bash # travis.sh script to SDK_URL="/connect-iq/sdks/connectiq-sdk-win-2.2.4.zip" SDK_FILE="sdk.zip" SDK_DIR="sdk" PEM_FILE="/tmp/developer_key.pem" DER_FILE="/tmp/developer_key.der" ### wget -O "${SDK_FILE}" "${SDK_URL}" unzip "${SDK_FILE}" "bin/*" -d "${SDK_DIR}" openssl genrsa -out "${PEM_FILE}" 4096 openssl pkcs8 -topk8 -inform PEM -outform DER -in "${PEM_FILE}" -out "${DER_FILE}" -nocrypt export MB_HOME="${SDK_DIR}" export MB_PRIVATE_KEY="${DER_FILE}" ./mb_runner.sh package As you can see, we’re downloading/extracting the Connect IQ SDK, generating a new private key for compilation/packaging, and setting the environment variables accordingly before running the mb_runner script. After committing/pushing the three new files ( mb_runner.sh , mb_runner.cfg , .travis.yml ) to your repo you can finally link it to TravisCI as a final step. Just head over to the TravisCI homepage and log in using your GitHub credentials. Navigate to your account-settings and simply select the repository you want to activate. And that’s it! From now on every new commit/push to your repository will trigger TravisCI and compile/package your app. If any build errors occur when committing a change you’ll get notified about it. Adding Badges to the README
 As a reward for our hard work we now can decorate our repository’s main page by adding the status-banner. Replace [username] , [reponame] , [branchname] with values that fit to your project: ![Build Status](https://travis-ci.org/[username]/[reponame].svg?branch=[branchname])](https://travis-ci.org/[username]/[reponame]) Of course you can put up an extra banner for each branch (master, development, etc.) you have. Including a Companion App
 If you happen to have an Android or iOS companion app along with your Connect IQ app, you could easily combine the build-process of both apps. If you’re having an Android app for example, then you’ll want to have it built by TravisCI as well. Since you’re already booting up a fresh Java-environment for this, you can just run your Connect IQ app build immediately afterwards. TravisCI will then return a combined result of both jobs meaning, if one fails then it will be an overall failure. For such a case, the .travis.yml file could look something like this: language: android jdk: oraclejdk8 android: components: - tools - platform-tools - tools - build-tools-25.0.2 - android-25 licenses: - android-sdk-license-.+ - '.+' before_install: - mkdir "$ANDROID_HOME/licenses" || true - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" &gt; "$ANDROID_HOME/licenses/android-sdk-license" - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd" &gt; "$ANDROID_HOME/licenses/android-sdk-preview-license" # the following part will be used to perform a compile-/package-run for the ConnectIQ-app; # afterwards we change into the "android"-subfolder and continue with the standard Android Gradle-build before_script: - sudo apt-get install -qq dos2unix script: - cd ciq &amp;&amp; ./travis.sh - cd ../android &amp;&amp; ./gradlew build mb_runner Submodule
 Instead of manually adding the mb_runner script to you project root, you also can include it as a Git submodule by running the following in your project root: git submodule add https://github.com/4ch1m/mb_runner.git This will create a mb_runner subdirectory, containing the mb_runner.sh file. You will still have to add/create a mb_runner.cfg file in your project’s root and adjust it to your needs. Conclusion
 Continuous integration has become a necessity of modern software project. Having TravisCI watch over your sources - ensuring that everything is still in a “buildable” state - makes commiting/pushing your code to the repo less frightening. Using the above techniques you can bring continuous integration to your Connect IQ GitHub projects. Achim Seufert is a developer in Würzburg, Germany. Check out his GitHub and website .


# [Reference Guides](https://developer.garmin.com/connect-iq/reference-guides/)nMenu Reference Guides Overview
 This section provides a reference guide for the tools that power the Connect IQ system. Section Topics See Also 
 Monkey C Reference Deep dive into the Monkey C language 
 Jungle Reference Covers the jungle build configuration language Build Configuration via Jungles 
 Monkey Motion Reference Covers the Monkey Motion tool used for animation conversion Animations 
 Monkey Graph Reference Covers the Monkey Graph tool used for testing FIT developer fields FIT Developer Fields 
 Devices Reference Detailed information about each supported Connect IQ device


# [Monkey C Reference](https://developer.garmin.com/connect-iq/reference-guides/monkey-c-reference/)nMenu Reference Guides Monkey C Language Reference
 Monkey C is an object-oriented language built from the ground up, designed for easy app development on wearable devices. If you’ve worked with dynamic languages in the past like Java™, PHP, Ruby, or Python™, Monkey C should be very familiar. The goal of Monkey C is to round the sharp edges of app development, allowing developers to focus more on the customer and less on resource constraints. Monkey C compiles into byte code that is interpreted by a virtual machine, similar to Java. Also like Java, objects are allocated on the heap, and the virtual machine cleans up memory. Language Essentials
 Data Types
 Monkey C is a duck typed language [1] , and does not have true primitive types. The Boolean , Char , Number , Long , Float , and Double types are all objects, which means primitives can have methods just like other objects. In languages like Java or C++, types must be declared for each function parameter and return value. The Monkey C compiler does not verify type safety, however, and instead runtime errors occur when functions mishandle objects. This provides great flexibility to developers, but in exchange the compiler cannot perform static type checking like in C++ or Java. Using operators like instanceof and has can help avoid potential typing issues. The basic data types supported by Monkey C are: Type Description Example 
 Number 32-bit signed integer var x = 5; 
 Float 32-bit floating point number var y = 6.0; 
 Long * 64-bit signed integer var l = 5l; 
 Double * 64-bit floating point number var d = 4.0d; 
 Boolean true and false var bool = true; 
 Char UTF–32 character var c = 'x'; 
 String * A sequence of characters var str = "Hello"; 
 Symbol A lightweight constant identifier (See Symbols for more info) var sym = :mySymbol; 
 Monkey C also supports two container types: Type Description Example 
 Array * Fixed size, numerically indexed, single dimensional list of objects var arr = new [1, 2, 3]; 
 Dictionary * An associative array or hash table that maps keys to values var dict = {one=&gt;1, two=&gt;2}; 
 *Requires heap allocation, which requires more memory than a 32-bit type. Keywords
 There are several keywords, operators, and reserved words in the Monkey C programming language that cannot be used as variables or symbols in your programs: Operator Description Example 
 and Logical AND, equivalent to &amp;&amp; See Logical Operators 
 as Assign an alias to a module denoted by a using statement See Using Statements 
 break Break out of a loop or a switch-case block See Loops and Switch-Case Statements 
 catch Catch a thrown Exception See Exception Handling 
 case Specify a case in a switch block See Switch-Case Statements 
 class Declare a new class See Classes and Objects 
 const Declare a new constant See Constants 
 continue Continue to executing the current flow, primarily used within loops See Loops 
 default Specify a default case in a switch block See Switch-Case Statements 
 do Start a do loop See Loops 
 else Specify an alternate case in an if block See If Statements 
 enum Declare a new enumeration See Enumerations 
 extends Declare a class that inherits from another class See Classes and Objects 
 false Logical false See If Statements 
 finally Specify a block of code to always execute in a try block See Exception Handling 
 for Start a for loop See Loops 
 function Declare a new function See Functions 
 has Check whether an object has a particular symbol See Instanceof and Has 
 hidden Specify a protected object member, equivalent to protected See Data Hiding 
 if Start an if block See If Statements 
 instanceof Check object type See Instanceof and Has 
 me Refer to the current object instance See Classes and Objects 
 module Declare a new module See Modules 
 NaN An invalid or undefined value, “Not a Number” NA 
 native Reserved for internal use NA 
 new Create a new instance of an object See Miscellaneous Operators 
 null A null value See Declaring Variables 
 or Logical OR, equivalent to || 
 private Specify a private object member See Data Hiding 
 protected Specify a protected object member See Data Hiding 
 public Specify a public object member See Data Hiding 
 return Specify a value to return from a function See Functions 
 self Refer to the current object instance See Classes and Objects 
 static Declare a static variable or function See Static Members 
 switch Start a switch block See Switch-Case Statements 
 throw Throw an exception See Exception Handling 
 true Logical true See If Statements 
 try Start a try-catch block to handle exceptions See Exception Handling 
 using Import a module for use in the app See Using Statements 
 var Declare a new variable See Declaring Variables 
 while Start a new while loop or set a condition for a do loop See Loops 
 Operators
 Monkey C supports several useful operators outlined below. In the examples below, assume a = 10 , b = 5 , x = 1 , y = 0 , m = true , and n = false . Arithmetic Operators
 Operator Description Example 
 + Add two operands; unary positive a + b results in 15; +a is 10 
 - Subtract the second operand from the first; unary negative a - b results in 5; -a is –10 
 * Multiply two operands a * b results in 50 
 / Divide the dividend by the divisor a / b results in 2 
 % Modulus, provides the remainder after division a % b results in 0 
 ++ Increment a numeric value by one, may be prefix or postfix a++ results in 11 
 -- Decrement a numeric value by one, may be prefix or postfix a-- results in 9 
 The + operator is also used to concatenate String values. Relational Operators
 Operator Description Example 
 == Check to see if two operands are equal a == b is false 
 != Check to see if two operands are not equal a != b is true 
 &gt; Check to see if the left operand is greater than the right operand a &gt; b is true 
 &lt; Check to see if the left operand is less than the right operand a &lt; b is false 
 &gt;= Check to see if the left operand is greater than or equal to the right operand a &gt;= b is false 
 &lt;= Check to see if the left operand is less than or equal to the right operand a &lt;= b is false 
 Logical Operators
 Operator Description Example 
 &amp;&amp; , ‘and’ Logical AND, which is true if both values are true m &amp;&amp; n is false 
 || Logical OR, which is true if either value is true m || n is true 
 ! Logical NOT, which reverses the value of a logical expression !(m &amp;&amp; n) is true 
 In Monkey C the following apply: * If an object is not null , it is evaluated as true . A value of 0 is evaluated as false . * A ! applied to a Number or Long is the same as applying a ~ . When comparing non-Boolean values in logical expressions: * The expression x &amp;&amp; y first evaluates x . If x is false , its value is returned; otherwise, y is evaluated and the resulting value is returned. * The expression x || y first evaluates x . If x is true , its value is returned; otherwise, y is evaluated and the resulting value is returned. Bitwise Operators
 Bitwise operators perform operations on binary values, bit-by-bit. These adhere to conventions illustrated by the following truth table: p q p &amp; q p | q p ^ q 
 0 0 0 0 0 
 0 1 0 1 1 
 1 1 1 1 0 
 1 0 0 1 1 
 Assume p = 3 and q = 1 . If written as byte values in binary, p is 0000 0011 and q is 0000 0001 . Operator Description Example 
 &amp; Bitwise AND, which copies a bit to the result if it exists in both operands p &amp; q results in 1 (0000 0001) 
 | Bitwise OR, which copies a bit to the result if it exists in either operand p | q results in 3 (0000 0011) 
 ^ Bitwise XOR, which copies a bit to the result if it exists in either operand, but not both p ^ q results in 2 (0000 0010) 
 ~ Bitwise NOT, two’s compliment, which effectively “flips” the bits ~q results in –2 (1111 1110) 
 All numeric values in Monkey C are signed values, indicated by the high-order bit. Assignment Operators
 Operator Description Example 
 = Assign the value from the right operand to the left operand b = a assigns b the value of a (10) 
 += Add the right operand and left operand and assign the result to the left operand a += b equivalent to a = a + b (15) 
 -= Subtract the right operand from the left operand and assign the result to the left operand a -= b equivalent to a = a - b (5) 
 *= Multiply the right operand with the left operand and assign the result to the left operand a *= b equivalent to a = a * b (50) 
 /= Divide the right operand from the left operand and assign the result to the left operand a /= b equivalent to a = a / b (2) 
 %= Divide the right operand from the left operand and assign the remainder to the left operand a %= b results in 0 
 &lt;&lt;= Left shift the left operand by the right operand and assign the result to the left operand x &lt;&lt;= y equivalent to x = x &lt;&lt; y (1) 
 &gt;&gt;= Right shift the right operand by the left operand and assign the result to the left operand x &gt;&gt;= y equivalent to x = x &gt;&gt; y (1) 
 &amp;= Bitwise AND the right operand by the left operand and assign the result to the left operand x &amp;= y equivalent to x = x &amp; y (0) 
 |= Bitwise OR the right operand by the left operand and assign the result to the left operand x |= y equivalent to x = x | y (1) 
 ^= Bitwise XOR the right operand by the left operand and assign the result to the left operand x ^= y equivalent to x = x ^ y (1) 
 Miscellaneous Operators
 Operator Description Example 
 ? and : The ternary operator, a shorthand form of if-else var myBool = a &gt; 5 ? true : false 
 new Create a new instance of an object var myTimer = new Toybox.Timer.Timer 
 Operator Precedence
 Operator precedence determines which parts of an expression will be evaluated first. The list below groups the operators by precedence, the highest appearing at the top of the table, and the lowest at the bottom. Precedence Operators 
 1 new ! ~ () 
 2 * / % &amp; &lt;&lt; &gt;&gt; 
 3 + - 
 4 == != &lt; &lt;= &gt; &gt;= 
 5 &amp;&amp; and 
 6 || or 
 Variables and Expressions
 Comments
 Commented statements are ignored by the compiler. Monkey C supports multi-line ( /* */ ) and single-line ( // ) comments. Here is an example of a multi-line comment: /* This is a multi-line comment. Notice that the information continues to appear as a comment as long as it remains inside the comment delimiters. */ Single-line comments may appear on their own line, or may appear in-line with other Monkey C code: using Toybox.System; // This is a single-line comment on its own line System.println("Hello World!"); // This comment shares a line with code that will execute Declaring Variables
 All variables must be declared before use with the var keyword. Since Monkey C is a duck typed language [1] , it is not necessary to delcare each variable’s type. var x = 5; // A 32-bit integer value var myString = ""; // An empty string var n = null; // Null value var f = 4.0d; // A 64-bit floating point value The flexibility of duck typing means there are things watch out for: var arr = new[10]; // Create a new array; since the values are unassigned, they are initialized as 'null' var z = arr[0] + 5; // Attempt to add a Number to a null array element. UnexpectedTypeException! Constants
 Constants, declared with the const keyword, are named, immutable values that support all basic data types. These are useful for storing unchanging values that may be used repeatedly throughout code. Constants must be declared at the module or class level and cannot be declared within a function. It is important to note that with data structures like arrays, const works in a way similar to Java’s final keyword. For example, a const array prevents the array from being replaced by a new instance, but the elements of the array may be modified. const PI = 3.14; const EAT_BANANAS = true; const BANANA_YELLOW = "#FFE135"; Symbols
 Symbol objects are lightweight constant identifiers. When the Monkey C compiler finds a new symbol, it will assign it a new unique value. This allows symbols to be used as constants without explicitly declaring a constant: using Toybox.System; var a = :symbol_1; var b = :symbol_1; var c = :symbol_2; System.println(a == b); // Prints true System.println(a == c); // Prints false Symbols are also useful as keys in data structures like dictionaries: var person = {:title=&gt;"George", :name=&gt;"Taylor"}; One other important use for symbols is to reference method implementations for calls to Object.method() or when assigning callbacks with Method . In this instances, if a method myMethod{...} has been implemented, it can be referenced as a callbacks using the symbol :myMethod . See the section on Callbacks for more in-depth examples. Enumerations
 Enumerations are constant mappings from a Symbol to a Number value, created using the enum keyword. Unless explicitly set, the first symbol in an enumeration is assigned a value of 0 , and each subsequent symbol is automatically assigned the value of the previous unassigned symbol plus one. Enumeration symbols can be used just like constants (that’s essentially what they are), and like constants, enumerations must be declared at the module or class level. // Automatically incremented enumeration enum { Sunday, // 0 Monday, // 1 Tuesday, // 2 Wednesday, // 3 Thursday, // 4 Friday, // 5 Saturday // 6 } // Enumeration initialized with an explicit starting value enum { x = 1337, // x = 1337 y, // y = 1338 z, // z = 1339 a = 0, // a = 0 b, // b = 1 c // c = 2 } Arrays
 Array objects are fixed-size, numerically indexed lists of objects. All members of an array do not need to be the same type of object. Like variables, arrays in Monkey C are typeless, so it is not necessary to declare an array’s type. There are two ways to create a new array: // A new array with ten empty slots, initialized to 'null' var myArray = new[10]; // A new five-slot array with assigned values var myArray = [1, 2, 3, 4, 5]; Array elements are expressions, so it’s also possible to build multi-dimensional arrays: var myArray = [[1, 2], ["one", "two"]]; Although Monkey C does not have a direct way of creating an empty, two-dimensional array, it can be done: // Specify the array sizes var first_dimension_size = 2; var second_simension_size = 100; // Create an empty one-dimensional array var myArray = new [first_dimension_size]; // Initialize the sub-arrays to complete the two-dimensional array for(var i = 0; i &lt; first_dimension_size; i += 1) { myArray[i] = new [second_dimension_size]; } When using this technique, it’s important to pay close attention to the array dimensions. The example above only makes three Array allocations to provide 200 slots, but were the dimensions reversed, this would make 101 allocations, using a lot more memory to provide the same number of slots. Dictionaries
 Dictionary objects, also called associative arrays or hash tables, are data structures similar to Array objects that map key-value pairs. Keys and values can be any type of Object , and each key-value pair does not need to be the same type combination within a given dictionary. using Toybox.System; var x = {}; // Declare a new, empty Dictionary var myDictionary = { "a" =&gt; 1, "b" =&gt; 2 }; // Declare a new Dictionary with initialized values myDictionary.put("c", "three"); // Add a new key-value pair with a String value System.println(myDictionary["a"]); // Prints "1" System.println(myDictionary["c"]); // Prints "three" System.println(myDictionary["d"]); // Prints "null" (there is no key "d") The Object class has a built-in hashCode() method that automatically hashes (indexes) the keys added to a Dictionary. This provides an efficient way of looking up the arbitrarily ordered Dictionary values. Dictionaries automatically resize and rehash as items are added or removed, which makes them extremely flexible, but comes at a cost: Insertion and removal of Dictionary contents can cause performance problems if there is excessive resizing and rehashing
 Dictionaries are not as space-efficient as either Object or Array type objects because they require extra memory allocation space
 
 The built-in hashCode() method is adequate in most cases, but if a custom Object type is used as keys in a Dictionary, it may be beneficial to override it to avoid index collisions and reduce lookup time: class Monkey { var mLengthInCentimeters; var mWeightInKilograms; initialize(length, weight) { mLengthInCentimeters = length; mWeightInKilograms = weight; } // Return a unique Number as the hash code for Monkey objects used as keys in Dictionaries. // For the record, this is a pretty terrible hashing function. function hashCode() { return (Math.pow(self.mLengthInCentimeters, self.mWeightInKilograms)).toNumber();; } } var rhesusMacaque = new Monkey(53.4, 7.7); var capuchin = new Monkey(48.3, 4.2); var mandrill = new Monkey(82.9, 32.3); var monkeyContinents = { rhesusMacaque =&gt; "Asia", capuchin =&gt; "South America", mandrill =&gt; "Africa" } Flow Control
 If Statements
 In Monkey C, if statement are the most basic of the available flow control statements. They are used to execute a certain section of code only if a particular Boolean expression evaluates to true . The expression evaluated by the if statement cannot be an assignment. Values or objects that will evaluate to true include: A value of true 
 A non-zero Number 
 A non-null Object 
 
 As an example, this prints a message to the console when the value of result is greater than zero: using Toybox.System; var result = 5; if (result &gt; 0) { System.println("Result is greater than zero"); } The else keyword can be added to an if block for more complex branching. Once an expression evaluates to true , its associated block of statements are executed and any remaining statements in the if block are skipped: using Toybox.System; var a = false; var b = true; if (a == true) { // 'a' is false, so this will not execute System.println("The variable 'a' is true!"); } else if (b == true) { // 'b' is true, so this block will execute System.println("The variable 'b' is true!"); } else { // Since the previous block has executed, this is skipped System.println("Neither is true!"); } Statements may also be nested. In the example below, b and c are only evaluated if a is equal to 1: using Toybox.System; if (a == 1) { if (b == true) { System.println("The variable 'b' is true!"); } else if (c == true) { System.println("The variable 'c' is true!"); } } Lastly, Monkey C supports the ternary operator, which is a simple, alternative syntax for a basic if-else statement. The general form is: var result = testExpression ? whenTrueExpression : whenFalseExpression Where testExpression is evaluated to determine whether it is true , whenTrueExpression is the true result, and whenFalseExpression is the false result. The value of the resulting expression is assigned to the result variable. If resulting expression does not resolve to a value (e.g. something like a System.println() statement), the result variable is assigned a value of null . // If 'a' is true, 'myValue' is assigned a value of 1; otherwise, it is assigned a value of 2. var myValue = a ? 1 : 2; Switch-Case Statements
 A switch statement is another type of flow control statement that may have multiple execution paths rather than the single path offered by if statements. A switch statement first evaluates a condition, which must be an object—assignments are not allowed. Any number of successive case statements are allowed within a switch block, each followed by either an object or an instanceof expression. When the switch evaluation is either equal to or an instance of a case statement, the matching case block will execute. For example, these two examples function similarly: using Toybox.System; // An if-else block checking the myValue variable if (myValue == 1) { System.println("The value is 1!"); } else if (myValue == 2) { System.println("The value is 2!"); } else { System.println("The value is not 1 or 2!"); } // A switch-case block checking the myValue variable switch (myValue) { case 1: System.println("The value is 1!"); break; case 2: System.println("The value is 2!"); break; default: System.println("The value is not 1 or 2!"); } All statements following the matching case block, including subsequent case blocks, are executed in sequence until a break statement is encountered. At this point, the switch block terminates and the remaining case blocks are skipped. This behavior, called fall through , is illustrated below: using Toybox.System; switch (myValue) { case 1: System.println("The value is 1!"); // Since there is no 'break', this will "fall through" and execute // the code in the next case block until its break statement is reached case 2: System.println("The value is 2!"); break; default: System.println("The value is not 1 or 2!"); } A switch block may also have a single, optional default case, which handles all cases not explicitly handled by one of the preceding case statements. A final break statement is not required because control flow will naturally fall out of the switch block at the end of the block, but it may be included if preferred. Since switch statements can switch on objects or object types, it’s possible to perform more sophisticated actions. Below is a snippet of an app that receives an Ant payload that must be handled differently depending on how the message is coded: var payload = message.getPayload(); switch (payload[MESSAGE_CODE_INDEX]) { case instanceof Number: System.println("Valid code!"); case Toybox.Ant.MSG_CODE_EVENT_CHANNEL_CLOSED: // Open the channel ... break; case Toybox.Ant.MSG_CODE_EVENT_RX_FAIL_GO_TO_SEARCH: // Search for device ... break; case Toybox.Ant.MSG_CODE_EVENT_CRYPTO_NEGOTIATION_FAIL: // Data not encrypted, so handle appropriately ... break; case Toybox.Ant.MSG_CODE_EVENT_CRYPTO_NEGOTIATION_SUCCESS: // Data encrypted, so handle appropriately ... break; case Toybox.Ant.MSG_CODE_EVENT_TX: // Update data and send out the next part of the message ... default: System.println("Invalid response!"); } Deciding whether to use switch instead of if is often a matter of personal preference. In some cases, switch blocks may be more readable, particularly when there are a relatively large number of cases to consider. Fall through can also be a useful tool depending on the needs of a particular application. Scoping in Switch Blocks
 Variables declared within the switch block are scoped at the switch block level. Variables may also be enclosed by curly braces within a case block to limit scope to that case block. All variables defined at the switch block level must be initialized before being used in any subsequent case statements. For example: switch (myValue) { case true: // Variable 'a' is scoped at the switch block level var a = 1; case 1: // Results in a compiler error because 'a' was not initialized in this case block var z = a; break; case "B": { // Variable 'a' is scoped at the code block level within the curly braces, so no scoping // conflict with 'a' at the switch block level var a = true; break; } case instanceof MyClass: // Results in a compiler error because 'a' has already been defined in the switch block var a = "Hello!" default: // No errors because 'a' was defined in the first case and initialized at the beginning of // the default case a = 0; var b = a; } Loops
 Monkey C supports for , while , and do-while loops. Loops are used to repeat statements until conditions specified by an expression are met. All loops require braces enclosing their block of statements, and single-line loops are not supported. The while and do-while loops have a familiar syntax: // A do-while loop var myCounter = 0; do { // Do something myCounter++; } while (myCounter &lt; 10); // A while loop myCounter = 0; while (myCounter &lt; 10) { // Do something myCounter++; } Monkey C allows variable declaration in for loops, which also have a familiar syntax: var myArray = [1, 2, 3, 4, 5]; for (var i = 0; i &lt; myArray.size(); i++) { // Do something until 'i' is greater than or equal to the array size } Flow control within loops can be managed by using the break and continue statements: using Toybox.System; // This for loop should only print the values 5, 6, and 7. for (var i = 0; i &lt; 10; i += 1) { if (i &lt; 5) { continue; } System.println(i); if (7 == i) { break; } } Exception Handling
 Monkey C supports structured Exception handling for non-fatal errors in the form of try-catch blocks: try { // Attempt to execute this code } catch (e) { // Catch and handle any exceptions thrown } Multiple catch statements are allowed to handle more than one possible exception type. When an exception is thrown, the first matching catch block will execute, and all subsequent catch blocks will be skipped (if a generic Exception handler is used, it’s a good idea to place last). An optional finally statement can be placed at the end of a try-catch block, which will execute regardless of whether an exception has been thrown. try { // Attempt to execute this code } catch (e instanceof MyExceptionClass) { // Catch and handle the MyExceptionClass exception } catch (e) { // Catch all other exception types } finally { // Execute this after the preceding try and catch statements are completed } To throw an Exception , use The throw keyword: throw new Lang.Exception(); If an exception is not handled, an Unhandled Exception error will occur at runtime. The Connect IQ API throws exceptions in a few instances instances, such as SymbolNotAllowedException and UnexpectedTypeException . Refer to the API Documentation for more details about the various Exception types. Functions
 Functions (also called methods) are the meat [2] of an application, defining discrete, callable units of code. They can exist in a class, module, or appear in the global module. Defining a Function
 Monkey C functions can take arguments, but because Monkey C is a dynamically typed language [1] , argument types are not declared. Below is a simple function that takes a single ‘myValue’ argument and multiplies it by two: function myFunction(myValue) { var result = myValue * 2; } Dynamic typing makes it easy to accidentally write functions that may not work under every circumstance. The example above works great if you provide a Number as an argument, but won’t be as happy if it’s passed a String. For this reason, it’s often a good idea to do some basic type checking within functions to make sure functions receive what’s expected. Returning Values From Functions
 It is not necessary to declare the return value of a function, thanks to dynamic typing, but all functions in Monkey C will still return a value. A return value may be specified with a return keyword: function myFunction(myValue) { var result = myValue * 2; return result; } The return statement is optional, and if a function doesn’t have one, it will return a “garbage” value from the viewpoint of the caller. Calling Functions
 To use a function or a method, simply use the function call syntax: // Call myFunction() and pass it an argument of '2', but do nothing with the result myFunction(2); // Call myFunction(), pass it an argument of '2', and assign the result to the 'myResult' variable var myResult = myFunction(2); It is also possible to call a function or method within another function or method: function myOtherFunction() { var result = myFunction(2); // Do some other stuff with the result here } Classes and Objects
 Classes are blueprints that bundle data and operations together into an instance of the class, called an object . Variables, functions, and other classes (often referred to as members ) can be defined within a Monkey C class. Objects are compiled and cannot be modified at runtime, so all variables must be declared in either a local function, the class instance, or the parent module before they can be used. Defining Classes
 A class is defined using the class keyword. For example, here is a simple class that defines a circle with an mRadius member, representing the radius of a circle: class Circle { var mRadius; } Creating Objects
 To create an instance of a class, use the new keyword: var myCircle = new Circle(); This doesn’t do too much that’s useful yet. However, when an object is instantiated with the new keyword, memory for the object is allocated and its initialize() method is automatically called, acting as a constructor. An initialize() method has been implemented in the Circle class below, which sets a radius value whenever a new Circle is created: class Circle { var mRadius; function initialize(aRadius) { mRadius = aRadius; } } // Create a new circle with a radius of 2 var myCircle = new Circle(2); If classes are nested, the outermost class must first be instantiated before and enclosed class may be instantiated. Accessing Class Members
 Within a method implementation, the current object instance can be referred to with either the self or me keywords. These may be used for disambiguating instance variables from local variables, or simply for clarity. For example, here’s the Circle class with new methods to calculate its circumference and surface area that use the self keyword to refer to the mRadius instance variable: using Toybox.Math as Math; class Circle { var mRadius; function initialize(aRadius) { mRadius = aRadius; } function getCircumference() { return 2 * Math.PI * Math.pow(self.mRadius, 2); // 2*PI*r } function getArea() { return Math.PI * Math.pow(self.mRadius, 2); // PI*r^2 } } Nested classes in Monkey C do not have access to the members of the enclosing class. Inheritance
 Inheritance allows one class to be based on another class, which helps speed development time and promotes code re-use. Instead of defining entirely new classes for similar objects, new classes can inherit members from existing classes. For example, a new Sphere class can be defined that shares a lot of the same characteristics of a circle by using the extends keyword to inherit from the Circle class: using Toybox.Math as Math; using Toybox.System as System; class Circle { var mRadius; function initialize(aRadius) { mRadius = aRadius; } function getCircumference() { return 2 * Math.PI * Math.pow(self.mRadius, 2); // 2*PI*r } function getArea() { return Math.PI * Math.pow(self.mRadius, 2); // PI*r^2 } function describe() { System.println("Circle!"); } } class Sphere extends Circle { function initialize(aRadius) { Circle.initialize(aRadius); } // Notice Sphere has no getCircumference() method implemented here. Instead, it inherits the // getCircumference() method from the Circle class and may use it as if it were its own method. function getArea() { return 4 * Math.PI * Math.pow(self.mRadius, 2); // 4*PI*r^2 } function describe() { System.print("I'm a Sphere! My parent is a "); Circle.describe(); } } The only thing not inherited from the parent class (also called a base class or superclass) is an initialize() method, which must be implemented separately for Sphere. In this case, it’s just calling the parent class’s initialize() method to set a radius. Monkey C does not implicitly call a parent class’s initialize() method, so child classes must explicitly call the base class constructor. Examples of this can be seen in the samples distributed with the Connect IQ SDK anywhere something like a View class is extended. The getArea() method from the Circle class won’t work for spheres, so a new getArea() method was also implemented to override the getArea() the method from the Circle class. Lastly, describe() methods were added to each class to let each object type describe itself. Let’s put these classes to work: // Create new objects var myCircle = new Circle(5); var mySphere = new Sphere(5); System.println(myCircle.getCircumference()); // 31.415928 System.println(myCircle.getArea()); // 78.539818 myCircle.describe(); // "Circle!" System.println(mySphere.getCircumference()); // 31.415928 (same as a circle of the same radius) System.println(mySphere.getArea()); // 314.159271 mySphere.describe(); // "I'm a Sphere! My parent is a Circle!" Notice the describe() method from Sphere calls the parent’s describe() method directly using the parent class’s symbol. The superclass.memberMethod() is valid in Monkey C, but the superclass.memberVariable syntax is not supported. Static Members
 In some cases, certain class members need to be accessible within an object without creating an instance of an object. For example, imagine a unit conversion class that only contains unit conversion constants: class Conversion { const FEET_PER_METER = 3.28084; const MILE_PER_KILOMETER = 0.621371; const TABLESPOONS_PER_CUP = 16; ... } var meters = 32; var myConverter = new Conversion(); // Create an instance of the Conversion class System.println(meters * myConverter.FEET_PER_METER + " feet"); // Prints "104.986877 feet" Normally, it would be necessary to first create an instance of the Conversion class before using any of the members within the class, including variables, constants, enumerations, or functions. If the static keyword is applied to the constants, however, it’s possible to use them without instantiating the Conversion class: class Conversion { static const FEET_PER_METER = 3.28084; static const MILE_PER_KILOMETER = 0.621371; static const TABLESPOONS_PER_CUP = 16; ... } var meters = 32; System.println(meters * Conversion.FEET_PER_METER + " feet"); // Prints "104.986877 feet" Another advantage to static members is that they belong to the class rather than to a particular instance of the class. This means that something like a static variable can be shared between mutliple instances of class, and if its value is changed in one instance, the new value is immediately available in all instances: class BananaBunch { static var mNumberOfBananas = 10; } var bunchOne = new BananaBunch(); var bunchTwo = new BananaBunch(); System.println(bunchOne.mNumberOfBananas); // 10 System.println(bunchTwo.mNumberOfBananas); // 10 bunchOne.mNumberOfBananas = 12; // Change the value of the static variable System.println(bunchOne.mNumberOfBananas); // 12 System.println(bunchTwo.mNumberOfBananas); // 12 - notice this one also reflects the change! Data Hiding
 Class members have three levels of access— private , protected , and public . The private modifier specifies that the member can only be accessed in its own class. The protected modifier specifies that the member can only be accessed by its own class or one of its subclasses. The hidden keyword is synonymous with the protected keyword. A public access modifier is the default, but it can also be explicitly specified. When the public access modifier is used for an enumeration, variable, or function, those members are visible to all other classes. using Toybox.System as System; class MyClass { protected var mVariable; } // This will produce a runtime error since it's trying to access a protected variable from myClass function myFunction() { var myObject = new MyClass(); System.println(myObject.mVariable); } Variables that are public or protected may be accessed using either one of the following formats: var x = mMmemberVariable; var y = self.mMemberVariable; Data hiding is only available at a class member level. Modules in Monkey C have no concept of data hiding, and classes are always public. Instanceof and Has
 Monkey C provides two operators to do runtime type checking that need some special attention: instanceof and has . Monkey C’s object-oriented design patterns in conjunction with the has and instanceof operator enables software that has implementations for many devices in a single code base. The instanceof operator checks whether an object instance inherits from a given class: using Toybox.System; var value = 5; if (value instanceof Lang.Number) { System.println("Value is a number"); } The has operator checks whether a given object has a particular symbol, which may be a public method, instance variable, or even a class definition or module. For example, accelerometer data is available in Sensor.Info , but not all products have an accelerometer. Attempting to use this data on certain products may cause the app to crash with a Symbol Not Found error. To avoid this, the has operator can be used to check for accelerometer support: using Toybox.Sensor as Sensor; var sensorInfo = Sensor.getInfo(); if (sensorInfo has :accel &amp;&amp; sensorInfo.accel != null) { var accel = sensorInfo.accel; var xAccel = accel[0]; var yAccel = accel[1]; System.println("x: " + xAccel + ", y: " + yAccel); } Callbacks
 Functions in Monkey C are not first class, so cannot be passed as arguments to other functions to be used as callbacks. Since functions are bound to the object in which they are created, Method objects must be used to create callbacks. One approach is to use a combination of a function and its object instance: class MyClass { function operation(a, b) { // The code here is really amazing. Like mind blowing amazing. } } function myFunction() { var myObject = new MyClass(); // Create a new instance of MyClass var myMethod = myObject.method(:operation); // Get a callback for the "operation" method from myObject myMethod.invoke(1, 2); // Invoke myObjects's "operation" method } Unlike classes, modules do not inherit from Object so do not have access to the method() function. However, a new instance of Method can be created, which allows module-level functions to be invoked as callbacks in a similar fashion: using Toybox.Lang as Lang; module MyModule { function operation() { // Some more amazing code. Only an infinite number of monkeys typing randomly over an // infinite period of time could write something this good. } } function myFunction() { var myMethod = new Lang.Method(MyModule, :operation); myMethod.invoke(); } A Method object will invoke a method on the instance of the object it came from, and keeps a strong reference to the source object. Weak References
 Monkey C is reference counted , which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly, which is important in low memory environments. The kryptonite of reference counting are circular references . A circular reference happens when a cycle is formed in the reference chain. For example, imagine that object C references an object A, while object A references object B and object B references object A: After a while, C gets invited to sit at the cool-kid table, so it dereferences A to go hang out with its real friends: The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other . The memory used by A and B are now unavailable to objects from the cool-kids table, which is generally not a good thing. However, sometimes A and B really do need to reference each other. In these cases, you can use a weak reference , which keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled. To create a weak reference, use the weak() method, an Object method available to all Monkey C objects. // We would make a "Hans and Franz" reference here but certain advertising has probably made them uncool. var weakReference = myObject.weak() If calling weak() on one of the immutable types ( Number , Float , Char , Long , Double , String ), then it returns the object itself. Otherwise, it will return a WeakReference instance. Weak references have a stillAlive() method to check if a weak reference is still valid, and have a get() method to create a strong reference to an object: if (weakReference.stillAlive()) { var strongReference = weakReference.get(); strongReference.myMethod(); } Remember to only keep the strong reference within the needed scope! Modules
 Monkey C modules serve a purpose similar to Java packages, but can contain variables, functions, classes, and other modules: module MyModule { class MyClass { var mValue; } var moduleVariable; } function myFunction() { MyModule.moduleVariable = new MyModule.MyClass(); } It is common for static methods to exist at the module level instead of belonging to a particular class. Unlike classes, however, modules have no concept of inheritance or data hiding (the extends and hidden keywords are not supported for modules). Using Statements
 Modules can be imported into another class or module with the using keyword, scoping the module to the class or module in which they are defined. using Toybox.System; function myFunction() { System.print("Hello"); } Modules may also be assigned an alias with the as clause, useful for shortening module names or when a different naming scheme is preferred: using Toybox.System as Sys; function myFunction() { Sys.print("Hello"); } Once imported, all classes inside a module must be referenced through their parent module. Scoping
 Monkey C is a message-passed language. When a function is called, the virtual machine searches a hierarchy at runtime in the following order to find the function: Instance members of the class
 Members of the superclass
 Static members of the class
 Members of the parent module, and the parent modules up to the global namespace
 Members of the superclass’s parent module up to the global namespace
 The code below illustrates: using Toybox.System; // A globally visible function function globalFunction() { System.println("This is the global function!"); } module Parent { function parentFunction() { System.println("This is the parent's function!"); globalFunction(); // May call a globally visible function } class Child { function childFunction() { System.println("This is the child's function!"); globalFunction(); // May call a globally visible function parentFunction(); // May call a function in our parent module staticChildFunction(); // May call a static function within the class } static function staticChildFunction() { System.println("This is the child's static function!"); globalFunction(); // May call a globally visible function parentFunction(); // May call a function in our parent module // Static methods can't call instance methods (childFunction) but still have access to parent modules! } } } In some cases, it may be more efficient to search from the global namespace instead of the current scope with the bling symbol $ , which refers to the global scope: using Toybox.System as System; function myFunction() { System.println("Hello Hello"); } class MyClass { function myFunction() { System.println("Every time I say goodbye you say hello"); } function() { $.myFunction(); // Call the global myFunction() myFunction(); // Call the instance myFunction() } } Using bling can improve runtime performance when referring to a global variable. Because Monkey C is dynamically typed, referencing a global variable will search your object’s inheritance structure and the module hierarchy before it will eventually find the global variable. Instead, we can search globals directly with the bling symbol: using Toybox.System as System; var familyFortune = "There's always money in the banana stand."; module BluthCompany { class BananaStand { function getMoney() { // At runtime, the VM will search: // 1. The BananaStand // 2. The BananaStand's superclass, Toybox.Lang.Object // 3. The BluthCompany module // 4. The BluthCompany module's parent globals // ...and finally finds the family fortune! System.println(familyFortune); // This will search only the global namespace for the family fortune. Thanks bling! System.println($.familyFortune); } } } While Monkey C will normally search the entire object hierarchy for an object, when the bling symbol is used, only the global space is checked. If nothing is found there, the virtual machine will not traverse back down the object hierarchy looking and will instead return a Symbol Not Found error. Switch blocks have some additional scoping rules, which can be found in the Switch-Case Statements section. Annotations
 Monkey C allows associating symbols with class or module methods and variables. Annotations are used to communicate additional intentions to the compiler, and are sometimes used to add new features without changing the Monkey C grammar. For example, Run No Evil tests require annotations to demark sections of code that are meant only for testing: // A test class containing a Run No Evil test method denoted by (:test) class TestMethods { (:test) static function testThisClass(x) } The following annotations have special meanings to the Monkey C compiler: :background Denotes code blocks available to the Background process. :debug Code blocks decorated with this annotation will not be included in release builds at compile time. :release Code blocks decorated with this annotation will not be included in debug builds at compile time. :test Denotes code blocks available to the Test module for Run No Evil tests For reference, annotations are written into the debug.xml file generated in a project’s ‘bin’ directory by the compiler when a project is built. This is different than Monkey Typing, where a thousand monkeys over infinite time write the works of Shakespeare. &nbsp;↩ 
 mmm_meat &nbsp;↩


# [Jungle Reference](https://developer.garmin.com/connect-iq/reference-guides/jungle-reference/)nMenu Reference Guides Jungle Reference Guide
 Welcome to Jungles [1] , the build language for Connect IQ apps. This guide will cover the following topics: The syntax of the jungle build language
 Using build exclusions to tailor your apps at build time
 Managing monkey barrels 
 Using Jungles with Visual Studio Code or from the command line 
 
 Jungle Syntax
 Jungle files contain build instructions that are made up of qualifiers , local variables , and values . Jungle files may also contain comments . Each build instruction is made up of qualifier-value or variable-value pairs separated by an equal sign ( = ), and terminate with a new line character. Qualifiers are analogous to the device and family qualifiers described in the previous section. They are treated as reserved words, can only be set equal to other qualifiers, and are globally scoped. Qualifiers and their properties can be used with the dereference operator $(VAR) and are evaluated after all Jungle files for a project have been processed. Project Qualifiers
 Project qualifiers specify global information that applies across the project. Project qualifiers have x properties that can be referenced by following project with a dot ( . ) and a property name: Qualifier Description 
 manifest Path to the manifest file for the project 
 optimization Specifies the optimization level for the project. See the --optimization compiler option for details 
 typecheck Specifies the type check level. See the --typecheck compiler option for details 
 Device Qualifiers
 Device qualifiers have six properties that can be referenced by following a qualifier with a dot ( . ) and a property name: Qualifier Description 
 annotations Monkey Barrel annotations applicable to this qualifier 
 barrelPath Monkey Barrel file ( .barrel ) paths applicable to this qualifier 
 excludeAnnotations Annotations to exclude when building for this qualifier 
 lang The language(s) supported by this qualifier 
 personality Monkey style file ( .mss ) paths applicable to this qualifier 
 resourcePath Resource file ( .xml ) paths applicable to this qualifier 
 sourcePath Source file ( .mc ) paths applicable to this qualifier 
 Local Variables
 Variables are a convenient way of re-using values, such as long path strings. Unlike qualifiers, local variables have no properties, cannot be set equal to a qualifier, and are locally scoped. Variables can be used with the dereference operator $(VAR) and are evaluated after the Jungle file in which they are defined has been processed. Values
 Values are a list of one or more string values that represent the value of a particular qualifier, qualifier property, or local variable. Multiple list items are separated by semicolons ( ; ). Comments
 Lines preceded with a hash mark ( # ) are treated as comments and are ignored by the compiler. A basic Jungle file build instruction will use this pattern (comments are optional): # This is a comment qualifier[.property] = value Jungle files must be named with a .jungle extension, and are kept in the root of the Connect IQ project. Note: Dereferenced qualifiers are evaluated “lazily”, which means that when building for a specific device, all qualifiers and properties are resolved for that device after all Jungle files are processed, while local variables will be resolved after processing the Jungle files in which they are defined. The exception to lazy evaluation is when a qualifier or local variable is dereferenced when setting that qualifier or variable, in which case the qualifier or variable is evaluated during Jungle file processing. Sources and Resources
 Setting source and resource paths are a common use for Jungles. In addition to tailoring source code and resources to particular devices to improve user experience, it can also help with memory management since only the sources defined in the Jungle file are compiled into the executable. As a practical example, assume an application will use a shared set of resources for fēnix devices contained in a fenix-resources directory at the root of the project. Since these products are not all in the same families , a custom Jungle file must be written to tell the compiler these devices should use this shared resources folder. We can start by setting the resource path for fēnix 5: # Set the fenix 5 resource directory fenix5.resourcePath = $(fenix5.resourcePath);fenix-resources Let’s break this down a little: fenix5.resourcePath The device qualifier for the fēnix 5 defined in the default Jungle file followed by the resourcePath property $(fenix5.resourcePath); The original value of the fenix5.resourcePath property, accessed with the dereference operator $(VAR) . The default Jungle file defines the base resource path as the resource directory in the root of the project, and all devices inherit this. It also defines device-specific and family-specific resource directories that can be used implicitly in any project. Including this in the resource path ensures that the device can still look in these directories for resources if required resources aren’t found in more device-specific locations. If this is omitted, it would tell the compiler to only look for fenix 5 resources in the fenix-resources directory. fenix-resources The shared directory we want to add as a resource location for the device. If this looks familiar, it’s because it’s pretty similar in concept to setting PATH environment variables . Path precedence goes from left to right in Jungle files, so the compiler will process inherited resources first before processing resources found within ‘fenix-resources’, which can potentially override resources already defined. Adding the fenix-resources directory to other fēnix devices just requires similar instructions for each additional device: # Set the fenix 5 resource locations fenix5.resourcePath = $(fenix5.resourcePath);fenix-resources # Set the fenix 3 resource locations fenix3.resourcePath = $(fenix3.resourcePath);fenix-resources ... Setting source paths works in essentially the same way, allowing apps to selectively include specific source code on a per-device or per-device family basis. As an example, consider an app that has common code shared by all products in the source folder and product-line specific source code in other folders: wearable-source for wearable devices, edge-source for bike computers, and handheld-source for handheld mapping units. The following demonstrates how to use a jungle to configure this project: # Reset the base source path to include only source files in the source folder. The # default source path includes source files in the project folder and all subfolders. base.sourcePath = source # Set the source path for wearable devices by device family round.sourcePath = $(round.sourcePath);wearable-source semiround.sourcePath = $(semiround.sourcePath);wearable-source # Set the source path for edge devices by device edge530.sourcePath = $(edge530.sourcePath);edge-source edge830.sourcePath = $(edge830.sourcePath);edge-source edge1030.sourcePath = $(edge1030.sourcePath);edge-source # Set source path for handheld devices by device gpsmap66.sourcePath = $(gpsmap66.sourcePath);handheld-source oregon7xx.sourcePath = $(oregon7xx.sourcePath);handheld-source rino7xx.sourcePath = $(rino7xx.sourcePath);handheld-source Localization Resources
 Localization strings are a kind of resource in Connect IQ, but have a slightly different syntax since multiple languages may be supported by a single device or device family. Suppose an application supports both English and Spanish, and all of the fēnix English localization resources are stored in a fenix-resources-eng directory, while the Spanish localization resources are kept in a fenix-resources-spa directory. # Set the fenix 5 English language resource location fenix5.lang.eng = $(fenix5.lang.eng);fenix-resources-eng # Set the fenix 5 Spanish language resource location fenix5.lang.spa = $(fenix5.lang.spa);fenix-resources-spa # Set the fenix 3 English language resource location fenix3.lang.eng = $(fenix3.lang.eng);fenix-resources-eng # Set the fenix 3 Spanish language resource location fenix3.lang.spa = $(fenix3.lang.spa);fenix-resources-spa ... The lang qualifier property is used in this build instruction to specify that a localization resource is being set, and is followed by an additional ISO 639–2 language code localization qualifier to indicate for which language the supplied resource locations are intended. A list of supported localization qualifiers can be found in the Strings section. Specifying an unsupported localization qualifier will result in an error at compile time. When specifying localization resources within Jungle files, the supported languages must also be set in a project’s manifest, otherwise the associated localization overrides will be ignored. Excluded Annotations
 In some cases, there are specific modules, classes, methods, or variables that should only be used by a subset of devices, but excluding an entire source file is excessive. The excludeAnnotations qualifier property allows build instructions to specify specific annotations that will be excluded when an application is built. This may help save memory during app execution on a device. A common reason for excluding source is when an application uses one algorithm that takes advantage of the latest APIs on newer devices, but must use a simpler algorithm on older devices that don’t have the latest APIs available. For example, the following example shows an app that has two methods—one that uses the newer Sensor.AccelerometerData , and one that relies on Sensor.Info.accel data: import Toybox.WatchUi; const experimental = Toybox.Sensor has :AccelerometerData; class MyAmazingAppView extends WatchUi.View { function onUpdate(dc) { sharedLogic(); if (experimental) { // If a newer device, call the new logic newHotnessLogic(); } else { // If an older device, call the old logic oldAndBoringLogic(); } } function newHotnessLogic() { // Advanced functionality using Sensor.AccelerometerData } function oldAndBoringLogic() { // Basic functionality using Sensor.Info.accel data } function sharedLogic() { // Shared logic } } This will function properly as-is, but all of the code is included regardless of the build target. If the app is approaching memory limits, it may be useful to exclude the unused method, especially if the method is sufficiently large and impacts available memory. To do this, set the excludeAnnotations qualifier property in the Jungle file to the appropriate annotation value: # By default, exclude the new, experimental logic base.excludeAnnotations = experimental # Exclude the old, boring logic from fenix 5 fenix5.excludeAnnotations = boring Then, update the application to use annotations: import Toybox.WatchUi; (:boring) const experimental = false; (:experimental) const experimental = Toybox.Sensor has :AccelerometerData; class MyAmazingAppView extends WatchUi.View { function onUpdate(dc) { // If a newer device, call the new logic // otherwise, call the old logic myAlgorithm(); } (:experimental) function myAlgorithm() { sharedLogic(); if (experimental) { newHotnessLogic(); } else { throw new MyException("Toybox.Sensor.AccelerometerData not supported!"); } } (:boring) function myAlgorithm() { sharedLogic(); oldAndBoringLogic(); } (:experimental) function newHotnessLogic() { // Advanced functionality using Sensor.AccelerometerData } (:boring) function oldAndBoringLogic() { // Basic functionality using Sensor.Info.accel data } function sharedLogic() { // Shared logic } } Monkey Barrel Management
 Barrels can also be added manually to the project’s main Jungle file using the barrelPath qualifier property: # Include all the Barrels from the 'barrels' directory at the root of the project base.barrelPath = barrels # Include a specific Barrel from the 'barrels' directory base.barrelPath = barrels/IconLibrary.barrel # Include multiple, specific Barrels from the 'barrels' directory base.barrelPath = barrels/IconLibrary.barrel;barrels/GraphLibrary.barrel It’s also possible to use the annotations qualifier property to import select, annotated portions of a barrel. This is useful when a Barrel contains a library of classes and methods, but an application only needs to use a fragment of the library. For example, assume the GraphLibrary barrel imported above contains several different graphing methods, but an application only needs to use a bar graph. The Barrel author was kind enough to annotate each method, so rather than using the entire Barrel, we can limit imported code to only those methods that are needed: # Import the 'bar' annotated method from the GraphLibrary Barrel base.GraphLibrary.annotations = bar In order for the compiler to correctly resolve Monkey Barrels, Barrel dependencies must also be added to the project’s manifest file: &lt;iq:barrels&gt; &lt;iq:depends name="IconLibrary" version="0.0.0"/&gt; &lt;/iq:barrels&gt; Once completed, the specified Barrels will be available for use in a project. Defining Project Dependencies
 What if a quick change is made to a developer’s barrel code in the development process of a dependant application? It would be cumbersome to export a barrel and update the dependencies in the manifest.xml every time the code is changed in the Barrel project. Connect IQ application projects can have direct Monkey Barrel project dependencies removing the need for these steps. Adding a Barrel project dependency is done by specifying the Jungle file or files of the project or projects depended upon within the barrelPath . Jungle files can be specified individually or grouped in the barrelPath . For example, a developer is creating an application, but she wants to include a standard set of icons that define her brand. She realizes in development that she needs to add a few more icons and decides to finally create that super specialized function that she is always needing. She can work dynamically on both projects and link her application project to her Barrel code by adding the Barrel project’s Jungle file to the barrePath like this: # Include a specific Barrel project base.barrelPath = MyIconBarrel/MyIconBarrel.jungle Another developer is working on a math intensive application. Thankfully, someone has created an extensive MathLibrary Barrel that he has pulled in. He also has a local MyIconLibrary Barrel project with some standard icons. He has a set of icons for round devices defined in a roundIcons.jungle file that he wants to use in his application. He includes both the packaged MathLibrary.barrel and his own roundIcons defined in his local barrel project like this: # Include a specific Barrel from the 'barrels' directory and a Jungle from a Barrel project base.barrelPath = barrels/MathLibrary.barrel;MyIconBarrel/roundIcons.jungle Our second developer realizes that he wants to support rectangle devices as well. These have been defined in a rectangleIcons.jungle . He includes multiple build instructions from MyIconBarrel by grouping the Jungle files in square brackets [] like this: # Include a specific Barrel from the 'barrels' directory and multiple Jungles from a Barrel project base.barrelPath = barrels/MathLibrary.barrel;[MyIconBarrel/roundIcons.jungle;MyIconBarrel/rectangleIcons.jungle] Take a look at the [Monkey Barrels](/connect-iq/core-topics/shareable/ Libraries#shareablelibraries) chapter to learn more about Monkey Barrels and how they can be used. The Default Jungle File
 The Connect IQ SDK includes a default Jungle file, which is always applied to projects even if no custom Jungle files are present. It defines a base qualifier, which represents all source files ( .mc ) contained in the project, and all resource files found in the resources at the root of a Connect IQ project. It also defines default device, family, and language qualifiers that are the basis for the qualifier scheme described in the previous section. When a project is built, the instructions from the default Jungle file are applied first, then any instructions from custom Jungle files are applied. This makes it possible for customizations to override the default build instructions. Using Jungles with Visual Studio Code
 By default, each project is configured to look for a monkey.jungle file in the root of the project and will use it if it exists. However, if a project is organized differently or a different Jungle file name is preferred, the Jungle file location can be set easily by going to File &gt; Preferences &gt; Settings and editing the Monkey C settings: Figure 2: Specifying a project’s Jungle file in Visual Studio Code Using Jungles from the Command Line
 For those who prefer to use the monkeyc shell command to build projects rather than Visual Studio Code, the -f option is required and accepts a list of Jungle files, separated by semicolons ( ; ) or colons ( : ): monkeyc -o myApp.prg myApp.mc -d fenix5 -f monkey.jungle;monkey2.jungle In lieu of this new option, the -z option to specify resource paths, the -x option to specify build exclusions, the -m option to specify the manifest file, and the ability to specify source paths have been deprecated and will be removed in a future SDK release. Here is a general description of how this will work: When specifying a Jungle file with the -f option, the default Jungle file will first be applied to the project before the specified Jungle file is applied
 If more than one Jungle file is provided after the -f option, precedence will be given to the build instructions in the last Jungle file in the list
 If no resource or source options are specified, either as a Jungle file the compiler will attempt to apply the default Jungle file to the project
 Use of both the -f option and any deprecated options in combination is not allowed and will cause a compiler error
 
 The manifest file of the project must be specified within a Jungle file passed at the command line and any Jungle can contain this specification. Here is what it looks like: project.manifest = manifest.xml There can be only one [2] manifest file defined within the set of jungle files provided. When relative paths are used within a jungle file the path will be resolved against the Jungle file’s parent directory. Relative paths within the default.jungle are resolved against the parent directory of the manifest file that is found. Note: Legacy projects using -m , -x , -z , and/or supplying source files at the command line will result in a compiler warning. Resist urge… to make… reference… &nbsp;↩ 
 When multiple manifests are found, one must destroy the other and absorb its power to become the strongest manifest. &nbsp;↩


# [Monkey Motion Reference](https://developer.garmin.com/connect-iq/reference-guides/monkey-motion-reference/)nMenu Reference Guides Monkey Motion
 The Monkey Motion UI tool or the command line can be used to import your animations. Using the Monkey Motion UI
 To use the Monkey Motion tool’s user interface, launch the executable, monkeymotion (Windows/Linux) or monkeymotion.app (Mac), either from the command line or using the Visual Studio Code Monkey C extension with the Monkey C: Open Monkey Motion command from the command palette. When initially launched, the tool will populate a list of devices that support Connect IQ Animations: The Monkey Motion Tool The developer can then select which devices to encode an animation for. A Connect IQ project manifest file can be loaded into the tool if the developer prefers which causes the tool to mark any devices that are both supported by the project as well as that support Connect IQ Animations as selected. If a developer wishes to tweak the file encoding to use something other than the default settings, the advanced tab offers more options: The Monkey Motion Tool Advanced Settings The Monkey Motion tool generates a Monkey Motion Manifest (or .mmm) file for each animation processed. The manifest will contain mappings between a device and a Monkey Motion (or .mm) file containing the binary of the encoded file. It is possible for a single animation to produce multiple .mm files since different encodings will be created based off of a video’s target resolution and the bits per pixel of the device. In addition to generating encodings of the input, the tool can be used for scrubbing the encoded animation: Monkey Motion Scrubbing If the developer wishes to scrub a previously encoded animation, the File menu option can be used to select Load Animation , which accepts Monkey Motion Manifest files as input. Using the Command Line
 Videos can also be encoded at the command line using the monkeym script. The following options are available at the command line: Argument Definition Valid Values Default Value Notes 
 -a &lt;arg&gt; The target alpha channel mask for a YUV encoded video file A valid, resolvable YUV encoded video file NA Optional 
 -c &lt;arg&gt; The preferred color depth (bits per color channel) of the animation See Color Depth for AMOLED Devices for more information A value between 1 and 6 6 Optional 
 -d &lt;arg&gt; Target devices Device qualifiers separated by a colon (:); devices that support orientation changing should be followed by ‘-portrait’ or ‘-landscape’ to determine the appropriate resolution when encoding a full screen animation NA Required 
 -e &lt;arg&gt; The identifier of an animation resource that should be exported along with the Monkey Motion encoded files Any value that starts with a letter NA Optional 
 -f &lt;arg&gt; The target frame rate of the animation A value between 1 and 10 is recommended; higher frame rates will be subject to the speed in which the animation can be decoded See Frame Rate Considerations for more information 10 for YUV encoded videos; GIF files can have a delay rate encoded within the animation, which will apply if not specified Optional 
 -h Print help information NA NA Optional 
 -m &lt;arg&gt; Manifest file to specify the devices to build for A path to a project manifest file Empty Optional 
 -o &lt;arg&gt; The output file path A valid, resolvable file path The target animation file path Optional 
 -p &lt;arg&gt; The target compression level of the encoded animation A value between 1 and 7 See Compression Level Impact for more information 5 Optional 
 -q &lt;arg&gt; The target image quality of the encoded animation A value between 1 and 3 See Considerations for more information 3 Optional 
 -r &lt;arg&gt; The target resolution of the animation (if not the device screen size) &lt;width&gt;x&lt;height&gt; where width and height are the numeric values of the target resolution (ex: 40x40) NA Optional 
 -s &lt;arg&gt; The target image scaling quality of the animation A value between 1 and 3 If applicable, 3 Optional 
 -v &lt;arg&gt; The target animation file A valid, resolvable YUV / GIF file NA Required 
 -w Print Monkey Motion warnings NA NA Optional 
 Considerations
 The Monkey Motion tool offers several advanced settings options, which introduce multiple areas of consideration. This section offers developers a few tips, case studies, and generally more in-depth information with the intention of them finding the most beneficial video encoding configurations. Image Quality Considerations
 Specifying an image quality value of 3 provides lossless compression (lossless in the sense that the encoder always uses the closest color available in the palette for each pixel), whereas specifying a value of 2 or 1 may allow further compression at the expense of making color substitutions which allow for better compression (lossy). Frame Rate Considerations
 The maximum frame rate of an animation is limited by both decoding time, which increases with higher compression, and by the amount of motion in the input video. Note: Because Connect IQ devices do not support vertical synchronization, high frames rates could potentially result in screen tearing. Compression Level Impact
 Compression level effects both compression and decoding overhead. Videos where the majority of the frame does not change from frame to frame can benefit from higher compression levels such as 9 without much consideration to the performance impact. For videos with lots of motion all over the screen, selecting a higher compression level may cause slower playback (due to the extra overhead necessary to decompress). For reference, this is a table showing the correlation between compression level and decoding time of a GIF file (with a high degree of complexity) running on the Fēnix 5 Plus: Compression Level Monkey Motion File Size (KB) Frame Decoding Time (ms) 
 1 981 30 
 2 883 36 
 3 798 38 
 4 758 39 
 5 728 39 
 6 711 40 
 7 703 40 
 At the same time, it is possible in some cases of these high motion, hard to compress videos that using a lower compression level may actually result in a smaller file size. For reference, this is another table showing the correlation between compression level and decoding time of a different GIF file (again with a high degree of complexity) running on the Venu: Compression Level Monkey Motion File Size (KB) Frame Decoding Time (ms) 
 1 602 58 
 2 602 60 
 3 602 60 
 4 601 61 
 5 600 64 
 6 599 71 
 7 600 84 
 The compression level of 6 actually produces the smallest file size. However, in this scenario, it would be better to accept the negligible size increase and use the compression level 1 because the decoding overhead would be much less. When in doubt about trying to get the maximum frame rate for a high motion video, a developer should start at compression level 1 and work their way up (knowing it may make the frame rate / size worse). Note: The decoding time on high color resolution devices can potentially be affected more dramatically. Complexity Level Impact
 Like the video compression level, the complexity of the video also has a direct impact on animation file size, as well as decoding performance. The complexity is determined by both the variations within the same frame and the variations among successive frames. For reference, sample GIF files were encoded for the Fēnix 5 Plus using a compression level of 5 to test the complexity impact. Low Complexity
 Frame Count: 30 Monkey Motion File Size: 107 KB Average Frame Decoding Time: 8 ms Medium Complexity
 Frame Count: 25 Monkey Motion File Size: 412 KB Average Frame Decoding Time: 26 ms High Complexity
 Frame Count: 24 Monkey Motion File Size: 758 KB Average Frame Decoding Time: 39 ms Color Depth for AMOLED Devices
 AMOLED devices use the RGB565 color format, i.e., red / blue can never exceed 5 bits per pixel. Specifying the value of 5 for AMOLED devices, which will reduce green from 6 to 5 bits per pixel, could potentially result in improving the animation’s compression without causing a visually noticeable difference considering the 256 color palette restriction. Memory Impact
 Each animation is considered a rendering layer. When an animation is added to a View , it will be assigned a frame buffer (in the form of a BufferedBitmap), which is worth a single frame of raw pixel data. For example, if the color depth is 8 bits, then a 240x240 animation will take roughly 58 KB (240 x 240 x 1) of memory out of the Connect IQ app memory budget. Overlay Frame Memory
 In the context of a View with animations, native drawables added to a View are grouped into a single layer, known as the “overlay” layer. The overlay frame is needed to ensure a smooth playback experience and will only be created on demand. Currently, the overlay buffer takes a full screen’s worth of memory from the app memory budget (in the form of a BufferedBitmap, like animations). Case Studies
 For reference, these tables show the memory impact of animations played on the Fēnix 5 Plus, which has a 240x240 screen resolution and 8bpp color depth. A View with two animations and no native drawables: Layer Resolution Frame Buffer Size (KB) 
 Animation 1 240x240 58 
 Animation 2 40x40 1.6 
 Overlay N / A 0 
 Total: 60 KB A View with two animations and native drawables: Layer Resolution Frame Buffer Size (KB) 
 Animation 1 240x240 58 
 Animation 2 40x40 1.6 
 Overlay 240x240 (fixed) 58 
 Total: 118 KB


# [Monkey Graph Reference](https://developer.garmin.com/connect-iq/reference-guides/monkey-graph-reference/)nMenu Reference Guides Monkeygraph Reference
 We can use the Monkeygraph tool to create a preview of data recorded in . The Monkeygraph tool requires the following: A FIT file with the recorded developer data
 An IQ file of the app (you can acquire an IQ file via the [App Export Wizard]).
 The tool will allow you to test how charts will look before uploading your app for review. There are two ways that you can use the Monkeygraph tool included with the SDK: Launching the Monkeygraph tool in Visual Studio Code:
 Summon the command palette
 Select Monkey C: Open Monkey Graph 
 This launches a new window for the Monkeygraph tool. Launching the Monkeygraph tool with the command line:
 You can start the Monkeygraph tool with following from the command line: $ monkeygraph Using the Monkeygraph tool:
 Click on “File”
 Click “Open IQ File”
 Select the IQ File generated from your project
 Click “Open FIT File”
 Select the Fit file with the recorded developer data
 A new view will launch a graph showing the data: And here we see some secondary data on another page:


# [Visual Studio Code Extension](https://developer.garmin.com/connect-iq/reference-guides/visual-studio-code-extension/)nMenu Reference Guides Monkey C Visual Studio Code Extension
 The Monkey C extension adds support for using the Connect IQ SDK, including a syntax highlighting editor, build integration, and integrated debugger. The Monkey C extension requires Visual Studio Code , the Oracle Java™ Runtime Environment 8 (version 1.8.0 or higher) and Connect IQ SDK version 4.0.6 or higher. Installing the Monkey C Extension
 In Visual Studio Code go to the View &gt; Extension 
 In the Extensions Marketplace search box type “Monkey C”
 Select the Monkey C extension from Garmin
 Use the Install button to install the extension in Visual Studio Code. This will require a restart of Visual Studio Code.
 After Visual Studio Code restarts, summon the command palette with Ctrl + Shift + P ( Command + Shift + P on Mac)
 Type “Verify Installation” and select Monkey C: Verify Installation 
 Project Management
 The following commands can be used to create a new project and export it: Command Description 
 Monkey C: New Project Create a new Connect IQ app or Monkey Barrel 
 Monkey C: Build Current Project Compiles the current project against a specified device 
 Monkey C: Build for Device Export wizard to generate a side loaded PRG for a device 
 Monkey C: Clean Project Deletes any cached artifacts generated by the build system 
 Monkey C: Export Project Creates an IQ or barrel file for the project 
 Manifest Editing
 The following commands can be used to edit and update the manifest.xml of your project: Command Description 
 Monkey C: Edit Products Edits the products in the manifest.xml . Only allows selecting products that support the minimum SDK version 
 Monkey C: Edit Permissions Edits the permissions in the manifest.xml 
 Monkey C: Edit Languages Edits the languages in the manifest.xml 
 Monkey C: Edit Application Edits the application metadata (name, label, identifier) in the manifest.xml 
 Monkey C: Configure Barrel Wizard to add or remove Monkey Barrels from your project 
 Monkey C: Set Products by Connect IQ Version Allows mass selection of all products that meet a Connect IQ version 
 Monkey C: Edit Annotations Allows adding new annotations to Monkey Barrel projects 
 Monkey C: Regenerate UUID Creates a new application UUID for your project 
 Interfacing with the Connect IQ SDK
 The following commands allow you to access the SDK tools and documentation from Visual Studio Code: Command Description 
 Monkey C: Open ERA Viewer Opens the Error Reporting Application tool 
 Monkey C: Open Monkey Graph Opens the Monkey Graph tool 
 Monkey C: Open Monkey Motion Opens the Monkey Motion tool 
 Monkey C: Open SDK Manager Opens the Connect IQ SDK Manager 
 Monkey C: View Documentation Provides access to all of the Connect IQ SDK documentation 
 Running the Program
 Before running the program, make sure you have one of your source files (In the source folder with the .mc extension) open and selected in the editor. Select Run &gt; Run Without Debugging ( Command + F5 on Mac, Ctrl + F5 on other platforms)
 You will be prompted with the list of products your application supports. Select one from the list.
 If all goes well, the simulator will start up and the selected watch will appear: Running Run No Evil Tests
 You can use the following commands to run tests: Command Description 
 Monkey C: Run Tests Runs all the Run No Evil tests in your application 
 Editing the Launch Configuration
 The extension will create a launch.json for your project when you run or debug your product. The launch.json provides many customization options for adding launch functionality Property Required Type Description 
 prg x Path Absolute path to project prg file 
 prgDebugXml x Path Absolute path to project debug xml file 
 stopAtLaunch Boolean When debugging, break immediately when the program launches. 
 runTests Boolean Run runNoEvil test cases when running this configuration 
 device Product Identifier Device to run or ${command:GetTargetDevice} to choose a new device each run 
 settingsJson Path Absolute path to project settings file 
 testNames Array of Strings An optional array of strings listing the test names to run


# [Monkey C Command Line Setup](https://developer.garmin.com/connect-iq/reference-guides/monkey-c-command-line-setup/)nMenu Reference Guides Using Monkey C from the Command Line
 Before getting started with the installation on Mac or Windows, you’ll need [Oracle Java™ Runtime Environment 8][JavaJRE] (version 1.8.0 or higher) installed. Once that’s done, continue on to your platform’s installation instructions. OS X Installation
 Install the Connect IQ SDK manager , download the SDK, and set the active SDK.
 Point your PATH to the active Connect IQ bin directory in the Terminal. To temporarily add it to a single local shell instance:
 $ export PATH=$PATH:`cat $HOME/Library/Application\ Support/Garmin/ConnectIQ/current-sdk.cfg`/bin For a more persistent addition, open .bash_profile in a text editor: $ touch ~/.bash_profile $ open ~/.bash_profile Then add the line below to the file and save the changes: export PATH=$PATH:`cat $HOME/Library/Application\ Support/Garmin/ConnectIQ/current-sdk.cfg`/bin Windows Installation
 Install the Connect IQ SDK manager , download the SDK, and set the active SDK.
 Point your PATH to the active Connect IQ bin directory in the command prompt:
 &gt; for /f usebackq %i in (%APPDATA%\Garmin\ConnectIQ\current-sdk.cfg) do set CIQ_HOME=%~pi &gt; set PATH=%PATH%;%CIQ_HOME%\bin Linux Installation
 Install the Connect IQ SDK manager , download the SDK, and set the active SDK.
 Point your PATH to the active Connect IQ bin directory in the command prompt:
 $ export PATH=$PATH:`cat $HOME/.Garmin/ConnectIQ/current-sdk.cfg`/bin For a more persistent addition, open .bash_profile in a text editor: $ touch ~/.bash_profile $ nano ~/.bash_profile Then add the line below to the file and save the changes: CTRL-X export PATH=$PATH:`cat $HOME/.Garmin/ConnectIQ/current-sdk.cfg`/bin Basic Commands
 After installation, three new shell commands are available: connectiq , monkeyc , and monkeydo . connectiq launches the Connect IQ simulator, which can be used to run and test apps on your computer before running them on your device. In the simulator, your app will only have access to those APIs that are available on the currently simulated device. For example, an API only available in Connect IQ v2.2.x or higher, such as PersistedContent , will not be available on devices that run earlier versions of Connect IQ. 
 monkeyc calls the Monkey C compiler. The compiler can take code from multiple files and link them together into a single Connect IQ executable (a PRG file). The usage is: 
 
 &gt; monkeyc [-d &lt;arg&gt;] [-f &lt;arg&gt;] [-o &lt;arg&gt;] [-y &lt;arg&gt;] Argument Definition 
 -d &lt;arg&gt; Target device 
 -f &lt;arg&gt; Jungle files 
 -o &lt;arg&gt; Output file to create 
 -y &lt;arg&gt; Private key to sign builds with 
 Note: For more information on all the command line options, refer to the Compiler Options section in the Monkey C guide. monkeydo runs a Connect IQ executable in the simulator. You must have previously started the simulator with connectiq . The usage is:
 
 monkeydo [executable] [device_id] [-t | -t test_name] Argument Definition 
 executable A Connect IQ executable (PRG) to run 
 device_id The device to simulate (e.g. “fenix5plus”) 
 -t Execute Run No Evil unit tests. Supply an optional test method or class name to only run that test or set of tests. 
 Here is an example of a basic build and run cycle from the command line: // Launch the simulator: &gt; connectiq // Compile the executable: &gt; monkeyc -d fenix5plus -f /path/to/monkey.jungle -o project_name.prg -y /path/to/Dev_Key // Run in the simulator &gt; monkeydo myApp.prg fenix5plus Note: For more information on the -f option and the Jungle build framework, see the Overriding Resources section of this guide. Generating a Key Using OpenSSL
 If you’re working from the command line you can generate a RSA key using OpenSSL . The following command will generate a valid signing key. &gt; openssl genrsa -out developer_key.pem 4096 &gt; openssl pkcs8 -topk8 -inform PEM -outform DER -in developer_key.pem -out developer_key.der -nocrypt This developer key, developer_key.der , is passed to the compiler using the -y command line option.


# [Devices Reference](https://developer.garmin.com/connect-iq/reference-guides/devices-reference/)nMenu Reference Guides


# [App Review Guidelines](https://developer.garmin.com/connect-iq/app-review-guidelines/)nMenu App Review Guidelines Garmin Connect IQ App Review Guidelines
 Last Updated: Oct 13th, 2021 Using the Connect IQ SDK, developers can create apps for Garmin Connect IQ compatible devices and distribute them via the Connect IQ store. Connect IQ is a strategic commitment for Garmin enabling you to bring your innovations to life through our mutual users, diverse device portfolio &amp; powerful metrics. We’re glad you want to develop Connect IQ apps, and we want you to be successful. To help you create apps that best serve our users, we created these Connect IQ App Developer Guidelines (these “ Guidelines ”). These Guidelines apply to any development or creation using the Connect IQ SDK, such as device apps, widgets, watch faces, custom data fields, and audio content provider apps. For ease of reference, we use the term “app” to cover all of these categories. These Guidelines are not an exhaustive set of rules. It may be necessary for us to suspend or remove a potentially harmful app from the Connect IQ store, even if there is no specific violation of the Guidelines. In other words, by providing you with these Guidelines, we do not waive any of our rights under applicable law or the Connect IQ Developer Agreement (which you should review). Summary
 We encourage you to read the entire Guidelines, but here is a summary of the main points: Appropriate Content and Subject Matter. You are responsible for your app. We may reject or remove an app for any content or subject matter we believe is dangerous, offensive, inappropriate or unlawful. You should also be aware that certain types of apps, such as aviation apps, medical apps, or apps that support user-generated content, may be allowed only if you comply with additional requirements.
 Performance Requirements. We want our users to have the best experience. If your app doesn’t function, diminishes battery life or other features of the Garmin device, or crashes frequently, it may be rejected or removed.
 Promoting and Monetizing Your App. The user experience begins with how you promote, describe, and monetize your app. You must do so in a manner that is honest and fair to users and other apps
 Respecting the Rights of Others. Do not use copyrighted content or other intellectual property of others without their permission. Your app cannot use data in a way that violates the Connect IQ Developer Agreement or privacy laws.
 Enforcement. We expect our developers to comply, and we reserve the right to take steps to protect our users if these Guidelines are not followed.
 The remainder of these Guidelines provide additional details for these five topics. Detailed Guidelines
 1. Appropriate Content and Subject Matter You are ultimately responsible for your app. This includes your app’s software and content, your app’s description in the Connect IQ store, the behavior of your app’s users, and compliance with laws, regulations, and contracts. These Guidelines describe potential issues with content and subject matter that ask you to avoid. a. Prohibited Content Your app should not include content that is unlawful, harmful, obscene, inappropriate, or offensive. We prohibit apps from including, linking to, or encouraging the creation of the following types of content: Sexual or obscene content: Including pornography, any content or services intended to be sexually gratifying, any content relating to bestiality or non-consensual sex, or explicit descriptions or displays or sexual organs or activities.
 Bullying, harassment, and abuse;
 Profanity or defamatory, fraudulent, infringing, or other unlawful content;
 Spam or advertising-focused content that serves primarily to drive affiliate traffic to a website; or that has the primary purpose of serving ads;
 Gambling;
 Any other inappropriate or offensive Content: We reserve the right to reject or remove any app that, in our opinion, creates any risk of liability to Garmin, threatens any type of harm to our users or third parties, or could harm our reputation. This includes, but is not limited to, any content that directly or indirectly violates other of our terms or guidelines.
 
 b. Physical Safety Your app must not threaten the physical safety or well-being of users or anyone else. We reserve the right to reject any app that we believe is unsafe or could, directly or indirectly, cause anyone harm. This includes apps that may create a false sense of security, such as “safety awareness” apps. Here are some specific issues to avoid: Harmful Challenges: Your app should not encourage or challenge users to act or use devices in a manner that risks physical harm to themselves or others. For example, apps should not challenge users to perform exercises or activities in a manner likely to result in injury or to drink excessive amounts of alcohol.
 Dangerous Activities: We prohibit apps that are designed to be used during dangerous activities such as scuba diving, free diving, skydiving, base-jumping, and extreme flight sports, even if your app is designed to work with one of Garmin’s products that has been designed for those activities. For example, you may create apps that add functionality to a Garmin Descent series dive watch, but your app should not be intended only for use during a user’s dive.
 Violence: We do not allow apps to facilitate or encourage gratuitous violence, human rights violations, domestic violence, child or animal abuse, or similar actions that harm the user or others.
 Drugs and Dangerous Products: Apps should not promote the use of illegal drugs, tobacco or vape products, excessive amounts of alcohol, unapproved substances, and illegal or dangerous products.
 Certain Aviation Use Cases: We will allow appropriate aviation-themed apps, but in addition to any other legally required disclaimers, aviation apps (except watch faces) must include the following disclaimer: “WARNING: The app is intended only as an in-flight aid and should not be used as a primary information source. If the app contains a barometric altimeter, it will not function in a pressurized aircraft and should not be used in a pressurized aircraft.”
 Regulated Activities : You are solely responsible for ensuring that your app complies with laws and regulations and includes any legally-required disclaimer. We encourage you to seek independent legal advice where appropriate, especially if your app relates to regulated activities, including the practice of medicine, law, or financial services.
 
 c. Medical Apps If your app is intended for use in the diagnosis, cure, mitigation, treatment or prevention of disease or other conditions, you must be prepared to submit documentation from any relevant regulatory agencies proving the app is cleared for use in your target markets. Otherwise, you must update the app’s description, features and functionality to ensure it does not indicate any use for the purposes of diagnosis, cure, prevention, mitigation or treatment of disease or other conditions and is intended for informational purposes only. Even if your app has been cleared by a regulatory agency, we reserve the right to accept or reject the app based on these Guidelines. d. No Malware or Harmful Apps We do not allow any apps that introduce or exploit security vulnerabilities. This includes, but is not limited to, apps that contain or enable any malicious software, including viruses, spyware, disabling code, or other software designed to damage a device or server or violate the privacy of our users. You are responsible for screening your apps for malicious software prior to submitting. e. No Mining for Cryptocurrency We prohibit apps from using Garmin devices to mine for cryptocurrency. f. No Apps for Children under 13 We prohibit apps that are designed to be used by children under the age of 13. This prohibition does not apply to any general audience apps, unless you are aware that the app is used by children under the age of 13. g. User-Generated Content If you offer features that allow the publication of user-generated content to the general public or other users in your app, you are responsible for moderating the content, as necessary, to prevent any unlawful, infringing or inappropriate content. “User-generated content” includes text, images, sound, or other data submitted or uploaded by users or third parties. You must: Have an agreement with end users that prohibits unlawful, harmful, obscene, inappropriate, or offensive content (see 1(b) – Prohibited Content, above);
 Maintain a method for users to report any inappropriate or prohibited content; and
 Publish a DMCA-compliant policy to remove content that infringes the intellectual property rights of third parties.
 
 If you fail to moderate your app’s user-generated content, we reserve the right to take action to suspend or remove your app – just as if your own content violated these Guidelines. 2. Performance Requirements Our users expect a high-quality experience when using Garmin products. These Guidelines are intended to help ensure that apps perform to our users’ expectations. a. Do Not Harm the Garmin Experience Your app should do no harm. Apps must not interfere with the use or enjoyment of other apps or features, such as the activity experience, battery life, device performance, etc. Here are some specific issues to avoid: Interfering with Other Features. We do not allow apps that damage, disrupt or access in an unauthorized manner the user’s Garmin device, other devices or computers, networks, servers, application programming interfaces (APIs), or services. The app should not require changes to system settings that will adversely affect the performance of other features on the device (e.g., requiring users to disconnect a Garmin device from a paired compatible smartphone).
 Drain on Battery Life. Apps should not cause Garmin’s products to no longer meet their expected battery life, cause other apps to run more slowly, attempt to access data in an unauthorized manner, or otherwise disrupt the advertised or desired user experience.
 Overriding the User’s Data . We do not allow apps to override information previously synced to their Connect account, where such data fields typically come from the Garmin device itself (e.g., speed or distance). We want to maintain the integrity and reliability of data values collected or generated by Garmin’s devices and software.
 Features Likely to Harm the Device . Apps should not require or encourage the use of a Garmin device in a manner likely to harm the device. For example, the app should not be designed for use during activities that will expose the device to harmful levels of heat or water pressure.
 Test Before Submitting . By the time you submit, your app should be fully completed, tested, and ready for use. You should ensure that your app provides a stable, engaging, and responsive user experience. The app should not contain any broken links or functionality.
 
 b. Support We are not responsible for providing customer support for your app or fielding complaints. You should clearly explain to users your support policy and availability. It is your responsibility to follow through on whatever support commitments you make. 3. Respect the Rights of Others, including IP and Privacy Rights a. No Infringement You may not infringe any copyright, trademark, patent, trade secret, or any other form of intellectual property (“ IP” ). You must own or have a license to use all IP included in or used by your app. This includes your app’s software and content (other than user generated content, discussed below), your developer account name, as well as the logos, images, and content that you use to promote your app in the Connect IQ store. It is your responsibility to ensure IP compliance and non-infringement. Here are some tips (not legal advice): Obtain legal advice: If you are unsure if your use of IP is infringing, check with a lawyer. It is not for us to decide whether your use of a third party’s IP may be infringing, properly used under a license, or fair use.
 Get permission: It is your responsibility to get permission as necessary from the IP owner before using their materials. Get permission in writing, keep a record of the permission, and make sure you’re complying with any terms and conditions.
 Be careful using brand names and logos: Your app may be the perfect complement for someone else’s product or brand. That doesn’t mean you have a right to use their intellectual property. Be careful before making any mention of a brand or using any logo or name that is not yours.
 Ask the IP owner: If you have questions about someone’s IP, you should ask the IP owner, not us (unless it is Garmin’s IP).
 
 b. Garmin’s DMCA Policy Garmin maintains a DMCA policy for IP owners to notify Garmin of alleged infringement. In some situations, we may need to remove or suspend your app in accordance with our policy. You can find the policy and additional details in our Terms of Use . Garmin’s DMCA Policy is not a substitute for maintaining your own policy for moderating user-generated content. However, in some cases, we may need take action against your app as the result of infringing user-generated content. c. Privacy and Data Use If your app collects and processes any user data, including any personal data, you must comply with privacy laws and any other applicable laws and regulations, as well as all privacy requirements stated in the Connect IQ Developer Agreement . Here are some general considerations to keep in mind (not legal advice): Data Minimization: Think carefully before collecting and using personal data. It is a best practice (and often a required practice) that you take all steps to minimize the collection, processing, and retention of personal data as much as possible. 
 Notice: Publish and make available your own privacy policy or other notice concerning your processing of personal data and how users may contact you to exercise any of their privacy rights. You cannot rely on Garmin’s privacy policies, which only describe Garmin’s privacy practices. 
 Permissions: Where appropriate, seek permission from users prior to collecting location data or data that may be considered sensitive. After obtaining permission, use the data only in accordance with that permission. You are responsible for complying with any legal obligations to obtain consent, even if doing so would require you to take steps outside of the Connect IQ framework for your particular use case. 
 
 4. Promoting and Monetizing Your App We want users to download, install, and use your app. Promoting your app starts with a strong description in the Connect IQ store but can also include advertising the app in your own channels. We expect you to advertise in a fair, lawful and transparent manner. a. Describe Your App Accurately and Completely You must not make any inaccurate or misleading statements. The information you provide about your app when submitting it to the app store should include a complete description of all features and any minimum requirements, limitations, or dependencies. This also applies to any other advertising you for your app, whether or not on a Garmin digital property, and any content or metadata associated with your app. Specifically, you must: Use your or your company’s real name or an alias that does not impersonate another person or company;
 Keep your contact information up-to-date;
 Avoid claiming any partnership or affiliation with Garmin, unless we have given you express written permission;
 Do not claim your app is compatible with any third-party system or protocol, if you have not obtained any required certification necessary to support such compatibility claim; and
 Identify whether your app requires any specific Garmin or third-party hardware or software to operate. For example, if the app’s core features do not work without ANT+, you must disclose that. If a specific feature has a dependency, you must disclose that dependency when advertising that the specific feature.
 
 b. Compatibility with Garmin Devices and ANT or ANT+ Communications Protocols You must accurately disclose which Garmin devices support your app. Because Garmin regularly releases new products, we encourage you to keep this list up-to-date. At minimum, you must avoid falsely claiming that your app works with a certain Garmin device. If your app supports ANT or ANT+ profiles, you must list all profiles your app supports. In addition, where applicable, your app must pass ANT+ certification. c. No Review or Rating Manipulation You must not perform or encourage any action that creates deceptive reviews or manipulates your app’s rating. Specifically, you must not : Disguise yourself as a user to publish positive reviews of your app or negative reviews of another developer’s app;
 Pay for positive reviews, including by offering users discounts on your products in exchange for a positive review or rating – even if you disclose your material connection to the reviewer; and
 Submit a rating for your own app.
 
 d. Monetization of Your App You must identify whether or not your app requires payment. An app requires payment if the user must pay to access or use any primary feature of the app (i.e., those features that are advertised in the app’s description, excluding any features that are clearly labeled optional). In contrast, an app is not considered to require payment, if the only features that require payment or subscription are optional. You must be honest when describing any payment requirements, whether optional or not. You must: Disclose from the outset if your app is only free for a limited time or for a limited number of uses;
 Inform users of your refund policy or lack thereof;
 Not “bait-and-switch” users by implying that a feature is available for free, when it is not; and
 Obtain express consent for any auto-renewal of payments, regardless of whether required to do so by law.
 
 5. Enforcement Garmin intends to enforce these Guidelines by rejecting or removing apps, if necessary to stop or prevent violations. Garmin, in its discretion, may choose to contact developers and request changes to apps, but Garmin is not required to provide notice prior to suspending or removing an app. a. Approval Process When you submit an app for approval, we expect the app to be ready to meet all of our Guidelines. We endeavor to review the app and the related documentation as thoroughly and promptly as possible. Please keep in mind that even if an app is approved, we may later discover issues after the review process. b. Removal Process If we find an issue with an app, whether discovered by us or brought to our attention by a user, we endeavor to provide an opportunity for the developer to resubmit with feedback. If the issue presents significant risks to Garmin or our users, we may immediately suspend the ability to download or use the app. We are under no obligation to provide you with any notice or process before taking action. c. Reservation of Rights Garmin reserves all rights to take any actions necessary to protect its users, products, brand, reputation, etc. This means that even if we remove an app, we can still exercise all available legal or equitable remedies. d. Contact Us Despite our right to enforce these Guidelines, we hope to avoid the need to take any action. We want your app to be a success. If you have questions about Connect IQ or these Guidelines, please feel free to ask a question in our developer forums .


# [Personality Library](https://developer.garmin.com/connect-iq/personality-library/)nMenu Personality Library Personality UI Personality UI
 Each Garmin® product has a unique device personality. This personality can be a combination of the industrial design, the screen technology, the inputs available, and the graphic styling of the system software. While there are often common components and patterns across Garmin products, the device personality alters how the user interfaces with those components. This makes it difficult for developers to make apps that feel native to the device. The goal of Personality UI is to help you navigate these design variations by providing a style system to adapt your design language to Garmin devices, along with a set of reusable components for your apps. Monkey Style
 Monkey style is a domain-specific property language for managing style elements. It borrows heavily from CSS, but has been tailored for Monkey C. Monkey C allows developers to create style property constants that can adapt among different Garmin products. Personality Components
 The personality components are a library of assets and monkey style definitions you can build upon when creating your apps. How to Read this Guide
 The components outlined in this guide use a combination of the resource system, Toybox.WatchUi classes, and personality selectors. Each component has a set of examples that outlines how to create it. The sample code examples are broken down with the headers listed below. Header Explanation 
 layout.xml Belongs in the layouts portion of your resource definitions. 
 menus.xml Belongs within the menus element of your resource definitions. 
 InputDelegate.mc Belongs in your input handler implementation. 
 View.mc Belongs in your view implementation. 
 Component Overview
 Chapter Description 
 Colors Learn how colors are expressed in the design system. 
 Iconography Integrate system iconography into your app. 
 Typography Choose the appropriate font. 
 Input Hints Provide visual guidance to users for actions. 
 Prompts Provide textual information to the user. 
 Confirmations Ask the user if they want to proceed. 
 Toasts Provide a small status update. 
 Action Views Create pages with interactive information. 
 Page Loops Break information across multiple pages. 
 Progress Indicators Give the status of a long-running action.


# [Colors](https://developer.garmin.com/connect-iq/personality-library/colors/)nMenu Personality Library Color Color
 The colors chosen for the product depend on the display technology and the graphic design language for the product. Using Color Selectors
 Personality UI provides context-specific color selectors that you can use with the resource system and in your code. Example Within layouts, combine the color with other selectors when adding layout components. layout.xml &lt;!-- Prompt Title --&gt; &lt;text-area text="@Strings.mainTitle" personality=" system_color_dark__text prompt_size__title prompt_loc__title prompt_font__title "/&gt; Example In Monkey C source, you can reference the color selector directly in code. View.mc import Rez.Styles; dc.setColor( system_color_dark__text.color, system_color_dark__text.background ); Light and Dark Themes
 Many Garmin® products have both light and dark themes. Some products allow customers to choose a theme for each activity, while others have day and night modes that determine the theme. Components in the personality design system have all of their colors documented with color_light and color_dark selectors. On certain products, especially those with AMOLED displays, these selectors are the same. If your app does not take night mode into account or does not run on products that have night mode, use only the color_dark selectors. Example drawables.xml &lt;drawable-list id="DarkBackground"&gt; &lt;shape type="rectangle" x="0" y="0" personality=" system_size__screen system_color_dark__background " /&gt; &lt;/drawable-list&gt; Example layout.xml &lt;!-- The Main View for our app --&gt; &lt;layout id="MainLayoutDark"&gt; &lt;!-- Dark Background --&gt; &lt;drawable id="DarkBackground" /&gt; &lt;!-- ActionMenu hint --&gt; &lt;bitmap id="actionMenuDark" personality=" system_icon_dark__hint_action_menu system_loc__hint_action_menu" /&gt; &lt;!-- Prompt Title --&gt; &lt;text-area text="@Strings.mainTitle" personality=" system_color_dark__text prompt_size__title prompt_loc__title prompt_font__title "/&gt; &lt;!-- Prompt Body --&gt; &lt;text-area text="@Strings.mainPrompt" personality=" system_color_dark__text prompt_size__body_with_title prompt_loc__body_with_title prompt_font__body_with_title " /&gt; &lt;/layout&gt; Example For performance reasons, it is faster to track the day or night mode in your own local variable rather than querying the system on every update. The following example exposes day or night mode as a theme that can be accessed by pages in the app. Application.mb import Toybox.Application; import Toybox.Lang; import Toybox.System; import Toybox.WatchUi; enum Theme { THEME_LIGHT, THEME_DARK } class MyApp extends Application { private var _theme as Theme; // Theme initialization public function initialize() { AppBase.initialize(); // Test for night mode if (Styles.device_info.hasNightMode &amp;&amp; System.DeviceSettings has :isNightModeEnabled) { _theme = System.getDeviceSettings().isNightModeEnabled ? THEME_DARK : THEME_LIGHT; } else { _theme = THEME_LIGHT; } } // Application handler for changes in day/night mode public function onNightModeChanged() { // Handle a change in night mode if (Styles.device_info.hasNightMode &amp;&amp; System.DeviceSettings has :isNightModeEnabled) { _theme = System.getDeviceSettings().isNightModeEnabled ? THEME_DARK : THEME_LIGHT; } else { _theme = THEME_LIGHT; } // Force a screen update. WatchUi.requestUpdate(); } // Theme accessor public function getTheme() as Theme { return _theme; } } Example You can load different layouts based on whether your app is in day or night mode. The following example keeps track of the current mode and changes it if the theme changes. View.mb //! View that shows the main menu for the app class MainView extends WatchUi.View { private var _theme as Theme; //! Constructor function initialize() { View.initialize(); _theme = $.getApp().getTheme(); } //! Handle layout function onLayout(dc as Dc) as Void { _theme = $.getApp().getTheme(); setLayout( _theme == $.THEME_DARK ? Rez.Layouts.MainLayoutDark(dc) : Rez.Layouts.MainLayoutLight(dc) ); } function onUpdate(dc as Dc) as Void { if ($.getApp().getTheme() != _theme) { onLayout(dc); } View.onUpdate(dc); } } Selectors
 Selector Context 
 system_color_light__background system_color_dark__background The default system background color. 
 system_color_light__text system_color_dark__text The default system text color. 
 activity_color_light__background activity_color_dark__background The default activity background color. 
 activity_color_light__text activity_color_dark__text The default activity text color. 
 prompt_color_light__background prompt_color_dark__background The default prompt background color. 
 prompt_color_light__title prompt_color_dark__title The text color for a title string in a prompt. 
 prompt_color_light__body prompt_color_dark__body The text color for the body text of a prompt. 
 confirmation_color_light__background confirmation_color_dark__background The default confirmation background color. 
 confirmation_color_light__body confirmation_color_dark__body The default confirmation body text color.


# [Iconography](https://developer.garmin.com/connect-iq/personality-library/iconography/)nMenu Personality Library Iconography Iconography
 Garmin® products use a common system of icons. While the intent and shape of the icons are shared across products, their visual styles are altered to match the product personality. There is a subset of system icons in the personality library that you can integrate into your apps. Icon assets in the personality library have icon in the prefix. Asset Colors
 Icons in the personality system have all of their colors documented with light and dark selectors. On some products, especially those with AMOLED displays, these selectors are the same. If your app does not take night mode into account or does not run on products that have night mode, use only the dark selectors. Components may also have positive or destructive colors to represent positive or destructive actions. Not every asset has positive or destructive variations. Sizing and Placement
 The size and screen placement of icons are determined by the kind of page being made. Selectors for location have loc in the prefix, while selectors for sizing have size in the prefix. By using these selectors, you can adapt your images across multiple products. Example The following example places the warning icon in the header of a text prompt. layout.xml &lt;!-- Warning icon in prompt header --&gt; &lt;bitmap id="warningIcon" personality=" system_icon_light__warning prompt_loc__title_icon prompt_size__title_icon " /&gt; Selectors
 Selector Icon Context 
 system_icon_light__about system_icon_dark__about Use for pages with instructional information or help pages. 
 system_icon_light__check system_icon_dark__check system_icon_positive__check Use to present confirmation actions. 
 system_icon_light__cancel system_icon_dark__cancel system_icon_destructive__cancel Use to present cancellation actions. 
 system_icon_light__discard system_icon_dark__discard system_icon_destructive__discard Use to identify actions that involve discarding recorded information. 
 system_icon_light__question system_icon_dark__question Use on pages where the user must answer a query. 
 system_icon_light__revert system_icon_dark__revert Use to indicate actions that undo or revert previous actions. 
 system_icon_light__save system_icon_dark__save Use to identify actions where information is saved. 
 system_icon_light__search system_icon_dark__search Use to highlight query or browse actions. 
 system_icon_light__warning system_icon_dark__warning system_icon_destructive__warning Use to warn the user of an action that can have a detrimental effect.


# [Typography](https://developer.garmin.com/connect-iq/personality-library/typography/)nMenu Personality Library Typography Typography
 The choice of fonts used for a product are based on readability, the product's visual language, and other aesthetic considerations. System and Number Fonts
 Garmin® products typically have two sets of fonts. The system font is used for textural information, while the number font is used for numeric information. Each font has a set of sizes available. The device reference outlines the available fonts on each product. The font selectors in the layout system map out the fonts available for each usage context. The selector typically provides the font size and justification, and it relies on other selectors for color, position, and bounding area. Example The following example describes the body text displayed in a prompt with a title. layout.xml &lt;!-- Prompt body --&gt; &lt;text-area text="@Strings.warningPrompt" personality=" prompt_color_dark__body prompt_size__body_with_title prompt_loc__body_with_title prompt_font__body_with_title " /&gt; Selectors
 Selector Context 
 confirmation_font__body The font for the body text in a confirmation. 
 prompt_font__title The font for prompt titles. 
 prompt_font__body_no_title The font for the body text in a prompt without a title. 
 prompt_font__body_with_title The font for prompts with a title string or icon.


# [Input Hints](https://developer.garmin.com/connect-iq/personality-library/input-hints/)nMenu Personality Library Input Hints Input Hints
 Garmin® software follows common interaction patterns. It is important to provide guidance on a page to indicate which actions are available to the user. Physical Button Hints
 On products without a touchscreen, the software should communicate to the user which buttons trigger the next steps. Button hints highlight the appropriate physical buttons to guide the user. Example layout.xml &lt;!-- Left top hint --&gt; &lt;bitmap id="leftTop" personality=" system_icon_dark__hint_button_left_top system_loc__hint_button_left_top" /&gt; Selectors
 NOTE: Not every selector is available for every product. NOTE: Hints applied to a product that does not have a button in that position will automatically be excluded when building for that product. Asset Selector Placement Selector Context 
 system_icon_light__hint_button_left_top system_icon_dark__hint_button_left_top system_loc__hint_button_left_top system_size__hint_button_left_top The top-left button for a wearable with a five-button configuration. 
 system_icon_light__hint_button_left_middle system_icon_dark__hint_button_left_middle system_loc__hint_button_left_middle system_size__hint_button_left_middle The middle-left button for a wearable with a five-button configuration. 
 system_icon_light__hint_button_left_bottom system_icon_dark__hint_button_left_bottom system_loc__hint_button_left_bottom system_size__hint_button_left_bottom The bottom-left button for a wearable with a five-button configuration. 
 system_icon_light__hint_button_right_top system_icon_dark__hint_button_right_top system_loc__hint_button_right_top system_size__hint_button_right_top The top-right button for a wearable with a five-button, three-button, or two-button configuration. 
 system_icon_light__hint_button_right_middle system_icon_dark__hint_button_right_middle system_loc__hint_button_right_middle system_size__hint_button_right_middle The middle-right button for a wearable with a three-button configuration. 
 system_icon_light__hint_button_right_bottom system_icon_dark__hint_button_right_bottom system_loc__hint_button_right_bottom system_size__hint_button_right_bottom The bottom-right button for a wearable with a five-button, three-button, or two-button configuration.


# [Prompts](https://developer.garmin.com/connect-iq/personality-library/prompts/)nMenu Personality Library Prompts Prompts
 A prompt is a page of textual information for the user. A prompt can be a valuable tool that provides important information. It can contain helpful tips or messages explaining why the user is unable to perform a specific action. Prompts with No Title
 Prompts are often pages without titles that automatically disappear after a short time. Example layout.xml &lt;!-- Informational Prompt --&gt; &lt;layout id="InfoPromptDark" &gt; &lt;!-- Dark Background --&gt; &lt;drawable id="DarkBackground" /&gt; &lt;!-- Prompt Body --&gt; &lt;text-area id="mainLabel" text="@Strings.informationPrompt" personality=" prompt_color_dark__body prompt_size__body_no_title prompt_loc__body_no_title prompt_font__body_no_title " /&gt; &lt;/layout&gt; Prompts with a Textual Title
 A textual title for the prompt provides additional context. Example layout.xml &lt;!-- Informational Prompt --&gt; &lt;layout id="TitlePromptDark" &gt; &lt;!-- Dark Background --&gt; &lt;drawable id="DarkBackground" /&gt; &lt;!-- Prompt Title --&gt; &lt;text-area id="title" text="@Strings.mainTitle" personality=" prompt_color_dark__title prompt_size__title prompt_loc__title prompt_font__title " /&gt; &lt;!-- Prompt Body --&gt; &lt;text-area id="mainLabel" text="@Strings.informationPrompt" personality=" prompt_color_dark__body prompt_size__body_with_title prompt_loc__body_with_title prompt_font__body_with_title " /&gt; &lt;/layout&gt; Prompts with an Icon Title
 You can use an icon in place of a textual title to provide context more quickly, or with greater emphasis. Example The following example places a warning icon above the prompt body text. layout.xml &lt;!-- About page prompt --&gt; &lt;layout id="AboutPageLight"&gt; &lt;!-- Light Background --&gt; &lt;drawable id="LightBackground" /&gt; &lt;bitmap id="aboutIconLight" personality=" system_icon_light__about prompt_loc__title_icon prompt_size__title_icon " /&gt; &lt;text-area text="@Strings.aboutPrompt" personality=" prompt_color_light__body prompt_size__body_with_title prompt_loc__body_with_title prompt_font__body_with_title " /&gt; &lt;/layout&gt;


# [Confirmations](https://developer.garmin.com/connect-iq/personality-library/confirmations/)nMenu Personality Library Confirmations Confirmations
 Confirmations ask the user for a yes or no response to a question. Confirmations are usually text only. Confirmations are a useful way of adding small amounts of friction to important decisions, to make sure the user understands their significance. Yes/No Confirmations
 A yes/no confirmation gives the user an opportunity to confirm an action. Example The following example uses WatchUi.Confirmation to display a yes/no confirmation. InputDelegate.mc using Toybox.WatchUi; var message = "Continue?"; dialog = new WatchUi.Confirmation(message); WatchUi.pushView( dialog, new ConfirmationDelegate(), WatchUi.SLIDE_IMMEDIATE ); Delete Confirmation
 A delete confirmation asks the user to confirm whether they want to delete an item. Example WatchUi.Confirmation does not support delete confirmations, but you can build your own confirmation using selectors. layout.xml &lt;!-- A Delete Confirmation page --&gt; &lt;layout id="DeleteConfirmationPage"&gt; &lt;!-- Confirm --&gt; &lt;bitmap id="confirmIcon" personality=" confirmation_icon__hint_confirm confirmation_loc__hint_confirm " /&gt; &lt;!-- Delete --&gt; &lt;bitmap id="deleteIcon" personality=" confirmation_icon__hint_delete confirmation_loc__hint_delete " /&gt; &lt;!-- Prompt body --&gt; &lt;text-area text="@Strings.deletePrompt" personality=" confirmation_color_dark__body confirmation_size__body confirmation_loc__body confirmation_font__body " /&gt; &lt;/layout&gt; InputDelegate.mc function onKey(evt as KeyEvent) as Boolean { if (Styles.confirmation_input__confirm has :button &amp;&amp; evt.getKey() == Styles.confirmation_input__confirm.button) { doConfirmAction(); return true; } else if (Styles.confirmation_input__reject has :button &amp;&amp; evt.getKey() == Styles.confirmation_input__reject.button) { doRejectAction(); return true; } return false; } function onTap(evt as ClickEvent) as Boolean { if (!(Styles.confirmation_input__confirm has :button) &amp;&amp; $.isInRejectArea(evt.getCoordinates())) { doConfirmAction(); return true; } else if (!(Styles.confirmation_input__reject has :button) &amp;&amp; $.isInRejectArea(evt.getCoordinates())) { doRejectAction(); return true; } return false; } Helper Functions import Rez.Styles; //! Function to see if a tap falls within the touch area for //! the confirm touch area. //! @param x X coord of tap //! @param y Y coord of tap //! @return true if tapped, false otherwise function isInConfirmArea(coord as Array&lt;Numeric&gt;) as Boolean { if (Styles.confirmation_input__confirm has :x1 &amp;&amp; Styles.confirmation_input__confirm has :y1 &amp;&amp; Styles.confirmation_input__confirm has :x2 &amp;&amp; Styles.confirmation_input__confirm has :y2) { var x = coord[0]; var y = coord[1]; if (x &gt;= Styles.confirmation_input__confirm.x1 &amp;&amp; x &lt;= Styles.confirmation_input__confirm.x2 &amp;&amp; y &gt;= Styles.confirmation_input__confirm.y1 &amp;&amp; y &lt;= Styles.confirmation_input__confirm.y2) { return true; } } return false; } //! Function to see if a tap falls within the touch area for //! the reject touch area. //! @param x X coord of tap //! @param y Y coord of tap //! @return true if tapped, false otherwise function isInRejectArea(coord as Array&lt;Numeric&gt;) as Boolean { if (Styles.confirmation_input__reject has :x1 &amp;&amp; Styles.confirmation_input__reject has :y1 &amp;&amp; Styles.confirmation_input__reject has :x2 &amp;&amp; Styles.confirmation_input__reject has :y2) { var x = coord[0]; var y = coord[1]; if (x &gt;= Styles.confirmation_input__reject.x1 &amp;&amp; x &lt;= Styles.confirmation_input__reject.x2 &amp;&amp; y &gt;= Styles.confirmation_input__reject.y1 &amp;&amp; y &lt;= Styles.confirmation_input__reject.y2) { return true; } } return false; }


# [Toasts](https://developer.garmin.com/connect-iq/personality-library/toasts/)nMenu Personality Library Toasts Toasts
 Asynchronous events can occur outside of the user's current flow. For example, GPS may establish the user's location after being enabled. When these events occur, you can use toasts to update the user without interrupting the user's current flow. Toasts are UI elements that take up a small portion of the screen and disappear after a short time. When paired with a vibration or tone, they can effectively update the user. Standard Toast
 The System 6 WatchUi.showToast() API provides access to the system toast. The toast can display a short text string and an icon. Example Use the size__toast_icon selector to scale an icon asset to the system size for a toast. drawables.xml &lt;bitmap id="warningToastIcon" personality=" system_icon_destructive__warning system_size__toast_icon "/&gt; InputDelegate.mc WatchUi.showToast("Lost GPS", {:icon=&gt;Rez.Drawables.warningToastIcon});


# [Action Views](https://developer.garmin.com/connect-iq/personality-library/action-views/)nMenu Personality Library Action Views Action Views
 Action views are screens that provide both information and a contextual menu of actions. These actions might be steps or tasks that can be performed on the visible information. Action Menu Hint
 Each product has a standard hint about how to access the contextual action menu. Example layout.xml &lt;!-- ActionMenu hint --&gt; &lt;bitmap id="actionMenu" personality=" system_icon_dark__hint_action_menu system_loc__hint_action_menu" /&gt; Action menus do not support iconography. Example menu.xml &lt;action-menu id="ActionMenu"&gt; &lt;action-menu-item id="edit" label="@Strings.edit" /&gt; &lt;action-menu-item id="dismiss" label="@Strings.dismiss" /&gt; &lt;/action-menu&gt; InputDelegate.mc function onKey(evt as KeyEvent) as Boolean { if (Styles.system_input__action_menu has :button &amp;&amp; evt.getKey() == Styles.system_input__action_menu.button) { showActionMenu(); return true; } return false; } function onTap(evt as ClickEvent) as Boolean { if (!(Styles.system_input__action_menu has :button) &amp;&amp; $.isInActionArea(evt.getCoordinates())) { showActionMenu(); return true; } return false; } function showActionMenu() as Void{ WatchUi.showActionMenu(new WatchUi.ActionMenu(), new MyActionMenuDelegate()); } The system_input__action_menu will let you know if the product uses a button or a touch area to trigger the contextual information. Example Helper: isInActionArea //! Function to see if a tap falls within the touch area for //! a action menu. //! @param x X coord of tap //! @param y Y coord of tap //! @return true if tapped, false otherwise function isInActionArea(coord as Array&lt;Numeric&gt;) as Boolean { if (Styles.system_input__action_menu has :x1 &amp;&amp; Styles.system_input__action_menu has :y1 &amp;&amp; Styles.system_input__action_menu has :x2 &amp;&amp; Styles.system_input__action_menu has :y2) { var x = coord[0]; var y = coord[1]; if (x &gt;= Styles.system_input__action_menu.x1 &amp;&amp; x &lt;= Styles.system_input__action_menu.x2 &amp;&amp; y &gt;= Styles.system_input__action_menu.y1 &amp;&amp; y &lt;= Styles.system_input__action_menu.y2) { return true; } } return false; } Edge 2022 Personality
 Products with the Edge 2022 personality have an optional configurable control bar that provides contextual actions. You can configure this bar to have an action menu using the View.setControlBar() API. Example View.mc if (View has :setControlBar) { setControlBar({:title=&gt;Rez.Strings.infoPrompt, :leftButton=&gt;WatchUi.CONTROL_BAR_LEFT_BUTTON_BACK, :rightButton=&gt;WatchUi.CONTROL_BAR_RIGHT_BUTTON_MENU }); } By using has in the above example, you can share this code with other products.


# [Page Loops](https://developer.garmin.com/connect-iq/personality-library/page-loops/)nMenu Personality Library Page Loops Page Loops
 Page loops present the user with a set of pages containing data and insights. There are standard behaviors for moving to the next and previous pages. Advancing from the last page typically loops the user back to the first page. Activity Page Loop
 One common page loop on Garmin® products appears when the user records an activity. While the activity is in progress, the user can navigate through multiple pages of information and metrics related to it. Example The System 6 WatchUi.ViewLoop can be used to handle the inputs and transitions between pages. You create a WatchUi.ViewLoopFactory that feeds WatchUi.View on demand. As the user selects the system input to navigate the page loop, the ViewLoop handles the page transitions and displays the page indicators. You provide your own WatchUi.InputDelegate for each view to handle inputs not involved with page navigation. InputDelegate.mc import Toybox.Lang; import Toybox.WatchUi; var loop = new WatchUi.ViewLoop(new PageLoopFactory(), {:wrap =&gt; true}); WatchUi.pushView(loop, new ViewLoopDelegate(loop), WatchUi.SLIDE_IMMEDIATE);


# [Progress Bars](https://developer.garmin.com/connect-iq/personality-library/progress-bars/)nMenu Personality Library Progress Indicators Progress Indicators
 At points where your app needs to perform an asynchronous operation, such as loading an update or a new view, you should indicate to the user that they need to wait. Progress indicators provide a full-page experience informing the user the process is ongoing while they wait. Percent Progress Indicator
 If you quantify the percentage or time you need to complete a process, you can use a percent progress indicator to present that progress to the user. Example WatchUI.ProgressBar shows a progress percentage if you initialize it with a value between 0 to 100. Call ProgressBar.setProgress() to update the progress displayed. InputDelegate.mc progressBar = new WatchUi.ProgressBar( "Processing...", 0 ); WatchUi.pushView( progressBar, new MyProgressDelegate(), Ui.SLIDE_DOWN ); Infinite Progress Indicator
 If you do not have a known progress end point, you can use an infinite progress mode. This displays a spinning indicator to show that a task is ongoing. Example WatchUi.ProgressBar shows a busy progress if you initialize it with a null value. InputDelegate.mc progressBar = new WatchUi.ProgressBar( "Processing...", null ); WatchUi.pushView( progressBar, new MyProgressDelegate(), Ui.SLIDE_DOWN );


# [Monetization](https://developer.garmin.com/connect-iq/monetization/)nMenu Monetization Connect IQ Monetization System
 The Connect IQ™ monetization system gives developers the ability to monetize their Connect IQ apps. Customers are provided a straightforward purchase experience, and can create a single digital wallet that can be used for both Connect IQ content, as well as Garmin® products and services. Merchant Onboarding 
 App Sales 
 Account Management 
 Price Points


# [Merchant Onboarding](https://developer.garmin.com/connect-iq/monetization/merchant-onboarding/)nMenu Monetization Merchant Onboarding
 The developer dashboard now includes a Merchant Account tab. To begin the merchant onboarding process, select this tab, select Set Up Merchant Account, and follow the on-screen instructions. After you complete the onboarding process, you must wait for approval. The verification process can take several days, and you may be asked to provide additional information. You will receive an email when the application is approved. Supported Countries for Developers
 The Connect IQ™ monetization system is available to developers with legal entities in the United States, Canada, Australia, Singapore, and most of the European Union. If you do not live or are not incorporated in any of the following countries, you cannot sign up for the monetization system: This list is subject to change. Region Countries 
 North America United States [1] and Canada 
 Europe Austria, Belgium, Croatia, Cyprus, Czech Republic, Denmark, Estonia, Finland, France, Germany, Gibraltar, Greece, Guernsey, Hungary, Ireland, Italy, Latvia, Liechtenstein, Lithuania, Luxembourg, Malta, Monaco, Netherlands, Norway, Poland, Portugal, Romania, Slovakia, Slovenia, Spain, Sweden, Switzerland, and United Kingdom [2] 
 APAC Australia and Singapore 
 Program Fee
 During the onboarding process, you are asked to pay the program fee. This is an annual, non-refundable fee of $100 USD. Business Entities
 The Connect IQ monetization system recognizes both sole proprietors and organizations. When asked to select your business entity type, select Individual/Sole Proprietor if you are signing up as an individual, and are not part of an incorporated company. If you are a partnership or a corporation, select Organization. After you begin receiving payouts, you cannot change your business entity type without contacting ConnectIQAppStoreAdmin@garmin.com . Changing your business entity type after payouts are received will have implications on tax reporting for the year. Legal Documentation
 You must provide legal information to verify your business. The required legal documentation includes photo identification, proof of address, proof of tax information, VAT documentation, and other information based on your legal entity type. Business Type Identification 
 Individuals and Sole Proprietors Photo ID, proof of national ID number, proof of residential address, proof of individual tax ID, and proof of industry 
 Sole Proprietorship Constitutional document, proof of address, and proof of industry 
 Organization Registration document, proof of address, proof of industry, proof of ownership, proof of tax information, and VAT document 
 Tax Documentation
 To finish enrollment, you must provide tax documentation. The required tax documentation varies by country of incorporation. The system requires different forms of documentation based on your home or business address. Including Puerto Rico &nbsp;↩ 
 Including Isle of Man and Jersey &nbsp;↩


# [App Sales](https://developer.garmin.com/connect-iq/monetization/app-sales/)nMenu Monetization App Sales
 After your application is approved, you are officially a merchant and can begin listing apps for sale. To list your app, select Upload an App from the developer dashboard. When asked if your app is monetized, select Yes, through Garmin CIQ merchant account. Select a price from the drop-down menu. Supported Products
 When you list an app for sale, it will only be offered on these products: Category Products 
 Running Forerunner® 165 Series, Forerunner 255 Series, Forerunner 955 Series, Forerunner 265 Series, and Forerunner 965 Series 
 Outdoor Approach® S70 Series, D2™ Mach 1 Pro, Descent™ Mk3 Series, Enduro™ 2, Enduro 3, epix™ (Gen 2), epix Pro (Gen 2) Series, fēnix® 6 Pro Series, fēnix 7 Series, fēnix 8 Series, fēnix E, MARQ® (Gen 2) Series, and tactix® 7 AMOLED Edition 
 Wellness Venu® Sq. 2 Series, Venu 3 Series, and vívoactive® 5 
 This list is subject to change. Supported Countries for Users
 Only users from the following countries can purchase monetized apps: Region Countries 
 Americas Antigua and Barbuda, Argentina, Aruba, Bahamas, Barbados, Belize, Bermuda, Bolivia, Bouvet Island, Brazil, Canada, Cayman Islands, Colombia, Costa Rica, Dominican Republic, Ecuador, El Salvador, Falkland Islands (Malvinas), France, Guyana, Greenland, Guadeloupe, Guatemala, Guyana, Honduras, Jamaica, Martinique, Mexico, Montserrat, Nicaragua, Panama, Paraguay, Peru, Puerto Rico, Saint Kitts and Nevis, Saint Lucia, South Georgia and the South Sandwich Islands, St Pierre and Miquelon, Suriname, Trinidad and Tobago, United States, Uruguay, Virgin Islands (British), and Virgin Islands (United States) 
 Africa Algeria, Angola, Benin, Botswana, British Indian Ocean Territory, Burkina Faso, Burundi, Cameroon, Cape Verde, Central African Republic, Chad, Comoros, Congo, Cote d’Ivoire, Djibouti, Egypt, Equatorial Guinea, Eritrea, Ethiopia, French Southern Territories, Gabon, Gambia, Ghana, Guinea, Guinea-Bissau, Kenya, Lesotho, Liberia, Madagascar, Malawi, Mali, Mauritania, Mauritius, Mayotte, Morocco, Mozambique, Namibia, Niger, Nigeria, Reunion, Rwanda, Saint Helena, Sao Tome and Principe, Senegal, Seychelles, Sierra Leone, State of Libya, Swaziland, United Republic of Tanzania, Togo, Tunisia, Uganda, Western Sahara, Zambia, and Zimbabwe 
 Europe Aland Islands, Albania, Andorra, Austria, Belgium, Bosnia and Herzegovina, Bulgaria, Croatia, Czech Republic, Denmark, Estonia, Faroe Islands, Finland, France, Germany, Gibraltar, Greece, Guernsey, Hungary, Iceland, Ireland, Isle of Man, Italy, Jersey, Latvia, Liechtenstein, Lithuania, Luxembourg, The Former Yugoslav Republic of Macedonia, Malta, Republic of Moldova, Monaco, Montenegro, Netherlands, Norway, Poland, Portugal, Romania, San Marino, Serbia, Slovakia, Slovenia, Spain, Svalbard and Jan Mayen, Sweden, Switzerland, Ukraine, United Kingdom, and Vatican City 
 APAC Afghanistan, Armenia, Australia, Azerbaijan, Bahrain, Bangladesh, Bhutan, Brunei Darussalam, Cambodia, Cyprus, Georgia, Hong Kong, India, Indonesia, Iraq, Israel, Japan, Jordan, Kazakhstan, Republic of Korea, Kuwait, Kyrgyzstan, Lebanon, Malaysia, Maldives, Mongolia, Oman, Pakistan, Philippines, Qatar, Saudi Arabia, Singapore, Sri Lanka, Taiwan, Tajikistan, Thailand, Turkey, Turkmenistan, United Arab Emirates, Uzbekistan, Vietnam, Yemen 
 This list is subject to change. Tax-Exclusive Price Points
 There is a set of available price points for monetized apps. These prices are tax-exclusive, and are the basis of the revenue split between Garmin® and the developer. The price points map to different currencies around the world based on the type of currency, tax-inclusivity, tax rates, and additional factors. Purchase Breakdown
 Garmin receives 15% of the tax-exclusive price point.
 Garmin adds the sales tax onto the price point.
 Garmin is responsible for the credit card fees.
 The digital service taxes (if applicable) will be withheld from your payouts.
 The cost of conversion to the developer payout currency will be withheld from your payouts.
 
 App Reviews
 Uploading an app requires a review process to verify it complies with the terms and conditions listed in the Connect IQ™ developer license agreement. If you are setting a price for an app that has already been approved, the app is temporarily removed from the store so it can be reviewed again. After the app is approved, users receive a message explaining that they must purchase the app before they can use it again. If you are switching to the Connect IQ monetization system from a different monetization system, you can use this marketing form to request promotion codes to migrate users who have already purchased the app. These one-time-use codes allow existing users to purchase the app without additional cost. You are responsible for distribution of these codes. Payouts
 Payouts are sent on the first day of every month. Separate payouts are sent from Garmin International, which covers sales in the United States and Canada, and Garmin Europe, which covers app purchases from other regions. Funds are not captured from customers until the 48-hour return window has passed.
 Purchases from the last five days of the month may not be included in the next payout. They are rolled into the following month’s payout, instead.
 Payouts require a minimum $10 USD balance in your account.


# [Account Management](https://developer.garmin.com/connect-iq/monetization/account-management/)nMenu Monetization Account Management
 When you are an approved merchant, the Merchant Account tab on the developer dashboard allows you to update your banking information, request sales reports and tax forms, and cancel your account. To change your legal entity type, you must email ConnectIQAppAdmin@garmin.com Cancelling Your Account
 You may opt out of the monetization program at any time. You can do this from the Merchant Account tab on the developer dashboard by selecting Account Information &gt; Deactivate Account . Your account will also be deactivated if you delete your account information at https://www.garmin.com/en-US/account/datamanagement , are listed on the denied parties list, or violate the terms and conditions of the monetization program. When your merchant account is terminated, your monetized apps are immediately demonetized. Customers who have purchases still in their return window are allowed to request refunds. After your account termination is processed, you must repeat all of the initial onboarding steps to become a merchant again, including payment of the program fee.


# [Price Points](https://developer.garmin.com/connect-iq/monetization/price-points/)nMenu Monetization Price Points
 ARS 
 AUD 
 CAD 
 CHF 
 CZK 
 DKK 
 EUR 
 GBP 
 MXN 
 NOK 
 NZD 
 RON 
 SEK 
 THB 
 USD 
 VND 
 
 ARS
 Price Point Argentina 
 USD $2.00 2099 ARS 
 USD $2.25 2299 ARS 
 USD $2.50 2599 ARS 
 USD $2.75 2799 ARS 
 USD $3.00 3099 ARS 
 USD $3.25 3299 ARS 
 USD $3.50 3599 ARS 
 USD $3.75 3799 ARS 
 USD $4.00 4099 ARS 
 USD $4.25 4299 ARS 
 USD $4.50 4599 ARS 
 USD $4.75 4799 ARS 
 USD $5.00 5099 ARS 
 USD $5.25 5299 ARS 
 USD $5.50 5599 ARS 
 USD $5.75 5799 ARS 
 USD $6.00 6099 ARS 
 USD $6.25 6299 ARS 
 USD $6.50 6599 ARS 
 USD $6.75 6799 ARS 
 USD $7.00 7099 ARS 
 USD $7.25 7299 ARS 
 USD $7.50 7599 ARS 
 USD $7.75 7799 ARS 
 USD $8.00 8099 ARS 
 USD $8.25 8299 ARS 
 USD $8.50 8599 ARS 
 USD $8.75 8799 ARS 
 USD $9.00 9099 ARS 
 USD $9.25 9299 ARS 
 USD $9.50 9599 ARS 
 USD $9.75 9799 ARS 
 USD $10.00 10099 ARS 
 USD $11.00 11099 ARS 
 USD $12.00 12099 ARS 
 USD $13.00 13099 ARS 
 USD $14.00 14099 ARS 
 USD $15.00 15099 ARS 
 USD $16.00 16099 ARS 
 USD $17.00 17099 ARS 
 USD $18.00 18099 ARS 
 USD $19.00 19099 ARS 
 USD $20.00 20099 ARS 
 USD $21.00 21099 ARS 
 USD $22.00 22099 ARS 
 USD $23.00 23099 ARS 
 USD $24.00 24099 ARS 
 USD $25.00 25099 ARS 
 USD $26.00 26099 ARS 
 USD $27.00 27099 ARS 
 USD $28.00 28099 ARS 
 USD $29.00 29099 ARS 
 USD $30.00 30199 ARS 
 USD $31.00 31199 ARS 
 USD $32.00 32199 ARS 
 USD $33.00 33199 ARS 
 USD $34.00 34199 ARS 
 USD $35.00 35199 ARS 
 USD $36.00 36199 ARS 
 USD $37.00 37199 ARS 
 USD $38.00 38199 ARS 
 USD $39.00 39199 ARS 
 USD $40.00 40199 ARS 
 USD $41.00 41199 ARS 
 USD $42.00 42199 ARS 
 USD $43.00 43199 ARS 
 USD $44.00 44199 ARS 
 USD $45.00 45199 ARS 
 USD $46.00 46199 ARS 
 USD $47.00 47199 ARS 
 USD $48.00 48199 ARS 
 USD $49.00 49199 ARS 
 USD $50.00 50199 ARS 
 USD $60.00 60299 ARS 
 USD $70.00 70299 ARS 
 USD $80.00 80299 ARS 
 USD $90.00 90399 ARS 
 USD $100.00 100399 ARS 
 AUD
 Price Point Australia 
 USD $2.00 3.25 AUD 
 USD $2.25 3.75 AUD 
 USD $2.50 3.99 AUD 
 USD $2.75 4.49 AUD 
 USD $3.00 4.75 AUD 
 USD $3.25 5.25 AUD 
 USD $3.50 5.49 AUD 
 USD $3.75 5.99 AUD 
 USD $4.00 6.49 AUD 
 USD $4.25 6.75 AUD 
 USD $4.50 7.25 AUD 
 USD $4.75 7.49 AUD 
 USD $5.00 7.99 AUD 
 USD $5.25 8.25 AUD 
 USD $5.50 8.75 AUD 
 USD $5.75 8.99 AUD 
 USD $6.00 9.49 AUD 
 USD $6.25 9.99 AUD 
 USD $6.50 10.25 AUD 
 USD $6.75 10.75 AUD 
 USD $7.00 10.99 AUD 
 USD $7.25 11.49 AUD 
 USD $7.50 11.75 AUD 
 USD $7.75 12.25 AUD 
 USD $8.00 12.75 AUD 
 USD $8.25 12.99 AUD 
 USD $8.50 13.49 AUD 
 USD $8.75 13.75 AUD 
 USD $9.00 14.25 AUD 
 USD $9.25 14.49 AUD 
 USD $9.50 14.99 AUD 
 USD $9.75 15.49 AUD 
 USD $10.00 15.75 AUD 
 USD $11.00 17.25 AUD 
 USD $12.00 18.99 AUD 
 USD $13.00 20.49 AUD 
 USD $14.00 21.99 AUD 
 USD $15.00 23.49 AUD 
 USD $16.00 25.25 AUD 
 USD $17.00 26.75 AUD 
 USD $18.00 28.25 AUD 
 USD $19.00 29.99 AUD 
 USD $20.00 31.49 AUD 
 USD $21.00 32.99 AUD 
 USD $22.00 34.49 AUD 
 USD $23.00 36.25 AUD 
 USD $24.00 37.75 AUD 
 USD $25.00 39.25 AUD 
 USD $26.00 40.75 AUD 
 USD $27.00 42.49 AUD 
 USD $28.00 43.99 AUD 
 USD $29.00 45.49 AUD 
 USD $30.00 46.99 AUD 
 USD $31.00 48.75 AUD 
 USD $32.00 50.25 AUD 
 USD $33.00 51.75 AUD 
 USD $34.00 53.25 AUD 
 USD $35.00 54.99 AUD 
 USD $36.00 56.49 AUD 
 USD $37.00 57.99 AUD 
 USD $38.00 59.75 AUD 
 USD $39.00 61.25 AUD 
 USD $40.00 62.75 AUD 
 USD $41.00 64.25 AUD 
 USD $42.00 65.99 AUD 
 USD $43.00 67.49 AUD 
 USD $44.00 68.99 AUD 
 USD $45.00 70.49 AUD 
 USD $46.00 72.25 AUD 
 USD $47.00 73.75 AUD 
 USD $48.00 75.25 AUD 
 USD $49.00 76.75 AUD 
 USD $50.00 78.49 AUD 
 USD $60.00 93.99 AUD 
 USD $70.00 109.75 AUD 
 USD $80.00 125.49 AUD 
 USD $90.00 140.99 AUD 
 USD $100.00 156.75 AUD 
 CAD
 Price Point Canada 
 USD $2.00 3.49 CAD 
 USD $2.25 3.75 CAD 
 USD $2.50 4.25 CAD 
 USD $2.75 4.75 CAD 
 USD $3.00 4.99 CAD 
 USD $3.25 5.49 CAD 
 USD $3.50 5.99 CAD 
 USD $3.75 6.25 CAD 
 USD $4.00 6.75 CAD 
 USD $4.25 7.25 CAD 
 USD $4.50 7.49 CAD 
 USD $4.75 7.99 CAD 
 USD $5.00 8.49 CAD 
 USD $5.25 8.75 CAD 
 USD $5.50 9.25 CAD 
 USD $5.75 9.75 CAD 
 USD $6.00 9.99 CAD 
 USD $6.25 10.49 CAD 
 USD $6.50 10.75 CAD 
 USD $6.75 11.25 CAD 
 USD $7.00 11.75 CAD 
 USD $7.25 11.99 CAD 
 USD $7.50 12.49 CAD 
 USD $7.75 12.99 CAD 
 USD $8.00 13.25 CAD 
 USD $8.25 13.75 CAD 
 USD $8.50 14.25 CAD 
 USD $8.75 14.49 CAD 
 USD $9.00 14.99 CAD 
 USD $9.25 15.49 CAD 
 USD $9.50 15.75 CAD 
 USD $9.75 16.25 CAD 
 USD $10.00 16.75 CAD 
 USD $11.00 18.25 CAD 
 USD $12.00 19.99 CAD 
 USD $13.00 21.49 CAD 
 USD $14.00 23.25 CAD 
 USD $15.00 24.99 CAD 
 USD $16.00 26.49 CAD 
 USD $17.00 28.25 CAD 
 USD $18.00 29.99 CAD 
 USD $19.00 31.49 CAD 
 USD $20.00 33.25 CAD 
 USD $21.00 34.75 CAD 
 USD $22.00 36.49 CAD 
 USD $23.00 38.25 CAD 
 USD $24.00 39.75 CAD 
 USD $25.00 41.49 CAD 
 USD $26.00 42.99 CAD 
 USD $27.00 44.75 CAD 
 USD $28.00 46.49 CAD 
 USD $29.00 47.99 CAD 
 USD $30.00 49.75 CAD 
 USD $31.00 51.49 CAD 
 USD $32.00 52.99 CAD 
 USD $33.00 54.75 CAD 
 USD $34.00 56.25 CAD 
 USD $35.00 57.99 CAD 
 USD $36.00 59.75 CAD 
 USD $37.00 61.25 CAD 
 USD $38.00 62.99 CAD 
 USD $39.00 64.49 CAD 
 USD $40.00 66.25 CAD 
 USD $41.00 67.99 CAD 
 USD $42.00 69.49 CAD 
 USD $43.00 71.25 CAD 
 USD $44.00 72.99 CAD 
 USD $45.00 74.49 CAD 
 USD $46.00 76.25 CAD 
 USD $47.00 77.75 CAD 
 USD $48.00 79.49 CAD 
 USD $49.00 81.25 CAD 
 USD $50.00 82.75 CAD 
 USD $60.00 99.25 CAD 
 USD $70.00 115.99 CAD 
 USD $80.00 132.49 CAD 
 USD $90.00 148.99 CAD 
 USD $100.00 165.49 CAD 
 CHF
 Price Point Switzerland 
 USD $2.00 2.00 CHF 
 USD $2.25 2.30 CHF 
 USD $2.50 2.60 CHF 
 USD $2.75 2.80 CHF 
 USD $3.00 3.10 CHF 
 USD $3.25 3.30 CHF 
 USD $3.50 3.60 CHF 
 USD $3.75 3.90 CHF 
 USD $4.00 4.10 CHF 
 USD $4.25 4.40 CHF 
 USD $4.50 4.60 CHF 
 USD $4.75 4.90 CHF 
 USD $5.00 5.20 CHF 
 USD $5.25 5.40 CHF 
 USD $5.50 5.70 CHF 
 USD $5.75 5.90 CHF 
 USD $6.00 6.20 CHF 
 USD $6.25 6.50 CHF 
 USD $6.50 6.70 CHF 
 USD $6.75 7.00 CHF 
 USD $7.00 7.20 CHF 
 USD $7.25 7.50 CHF 
 USD $7.50 7.80 CHF 
 USD $7.75 8.00 CHF 
 USD $8.00 8.30 CHF 
 USD $8.25 8.50 CHF 
 USD $8.50 8.80 CHF 
 USD $8.75 9.10 CHF 
 USD $9.00 9.30 CHF 
 USD $9.25 9.60 CHF 
 USD $9.50 9.80 CHF 
 USD $9.75 10.10 CHF 
 USD $10.00 10.40 CHF 
 USD $11.00 11.40 CHF 
 USD $12.00 12.50 CHF 
 USD $13.00 13.50 CHF 
 USD $14.00 14.50 CHF 
 USD $15.00 15.60 CHF 
 USD $16.00 16.60 CHF 
 USD $17.00 17.70 CHF 
 USD $18.00 18.70 CHF 
 USD $19.00 19.70 CHF 
 USD $20.00 20.80 CHF 
 USD $21.00 21.80 CHF 
 USD $22.00 22.90 CHF 
 USD $23.00 23.90 CHF 
 USD $24.00 25.00 CHF 
 USD $25.00 26.00 CHF 
 USD $26.00 27.00 CHF 
 USD $27.00 28.10 CHF 
 USD $28.00 29.10 CHF 
 USD $29.00 30.20 CHF 
 USD $30.00 31.20 CHF 
 USD $31.00 32.20 CHF 
 USD $32.00 33.30 CHF 
 USD $33.00 34.30 CHF 
 USD $34.00 35.40 CHF 
 USD $35.00 36.40 CHF 
 USD $36.00 37.50 CHF 
 USD $37.00 38.50 CHF 
 USD $38.00 39.50 CHF 
 USD $39.00 40.60 CHF 
 USD $40.00 41.60 CHF 
 USD $41.00 42.70 CHF 
 USD $42.00 43.70 CHF 
 USD $43.00 44.70 CHF 
 USD $44.00 45.80 CHF 
 USD $45.00 46.80 CHF 
 USD $46.00 47.90 CHF 
 USD $47.00 48.90 CHF 
 USD $48.00 50.00 CHF 
 USD $49.00 51.00 CHF 
 USD $50.00 52.00 CHF 
 USD $60.00 62.50 CHF 
 USD $70.00 72.90 CHF 
 USD $80.00 83.30 CHF 
 USD $90.00 93.70 CHF 
 USD $100.00 104.10 CHF 
 CZK
 Price Point Czech Republic 
 USD $2.00 69.00 CZK 
 USD $2.25 69.00 CZK 
 USD $2.50 79.00 CZK 
 USD $2.75 89.00 CZK 
 USD $3.00 99.00 CZK 
 USD $3.25 99.00 CZK 
 USD $3.50 109.00 CZK 
 USD $3.75 119.00 CZK 
 USD $4.00 129.00 CZK 
 USD $4.25 139.00 CZK 
 USD $4.50 139.00 CZK 
 USD $4.75 149.00 CZK 
 USD $5.00 159.00 CZK 
 USD $5.25 169.00 CZK 
 USD $5.50 169.00 CZK 
 USD $5.75 179.00 CZK 
 USD $6.00 189.00 CZK 
 USD $6.25 199.00 CZK 
 USD $6.50 199.00 CZK 
 USD $6.75 209.00 CZK 
 USD $7.00 219.00 CZK 
 USD $7.25 229.00 CZK 
 USD $7.50 239.00 CZK 
 USD $7.75 239.00 CZK 
 USD $8.00 249.00 CZK 
 USD $8.25 259.00 CZK 
 USD $8.50 269.00 CZK 
 USD $8.75 269.00 CZK 
 USD $9.00 279.00 CZK 
 USD $9.25 289.00 CZK 
 USD $9.50 299.00 CZK 
 USD $9.75 299.00 CZK 
 USD $10.00 309.00 CZK 
 USD $11.00 339.00 CZK 
 USD $12.00 369.00 CZK 
 USD $13.00 399.00 CZK 
 USD $14.00 429.00 CZK 
 USD $15.00 469.00 CZK 
 USD $16.00 499.00 CZK 
 USD $17.00 529.00 CZK 
 USD $18.00 559.00 CZK 
 USD $19.00 589.00 CZK 
 USD $20.00 619.00 CZK 
 USD $21.00 649.00 CZK 
 USD $22.00 679.00 CZK 
 USD $23.00 709.00 CZK 
 USD $24.00 739.00 CZK 
 USD $25.00 769.00 CZK 
 USD $26.00 799.00 CZK 
 USD $27.00 829.00 CZK 
 USD $28.00 859.00 CZK 
 USD $29.00 889.00 CZK 
 USD $30.00 929.00 CZK 
 USD $31.00 959.00 CZK 
 USD $32.00 989.00 CZK 
 USD $33.00 1019.00 CZK 
 USD $34.00 1049.00 CZK 
 USD $35.00 1079.00 CZK 
 USD $36.00 1109.00 CZK 
 USD $37.00 1139.00 CZK 
 USD $38.00 1169.00 CZK 
 USD $39.00 1199.00 CZK 
 USD $40.00 1229.00 CZK 
 USD $41.00 1259.00 CZK 
 USD $42.00 1289.00 CZK 
 USD $43.00 1319.00 CZK 
 USD $44.00 1359.00 CZK 
 USD $45.00 1389.00 CZK 
 USD $46.00 1419.00 CZK 
 USD $47.00 1449.00 CZK 
 USD $48.00 1479.00 CZK 
 USD $49.00 1509.00 CZK 
 USD $50.00 1539.00 CZK 
 USD $60.00 1849.00 CZK 
 USD $70.00 2149.00 CZK 
 USD $80.00 2459.00 CZK 
 USD $90.00 2769.00 CZK 
 USD $100.00 3069.00 CZK 
 DKK
 Price Point Greenland Denmark 
 USD $2.00 15.00 DKK 18.50 DKK 
 USD $2.25 16.50 DKK 20.50 DKK 
 USD $2.50 18.50 DKK 23.00 DKK 
 USD $2.75 20.50 DKK 25.50 DKK 
 USD $3.00 22.00 DKK 27.50 DKK 
 USD $3.25 24.00 DKK 30.00 DKK 
 USD $3.50 25.50 DKK 32.00 DKK 
 USD $3.75 27.50 DKK 34.50 DKK 
 USD $4.00 29.50 DKK 36.50 DKK 
 USD $4.25 31.00 DKK 39.00 DKK 
 USD $4.50 33.00 DKK 41.00 DKK 
 USD $4.75 35.00 DKK 43.50 DKK 
 USD $5.00 36.50 DKK 45.50 DKK 
 USD $5.25 38.50 DKK 48.00 DKK 
 USD $5.50 40.50 DKK 50.50 DKK 
 USD $5.75 42.00 DKK 52.50 DKK 
 USD $6.00 44.00 DKK 55.00 DKK 
 USD $6.25 45.50 DKK 57.00 DKK 
 USD $6.50 47.50 DKK 59.50 DKK 
 USD $6.75 49.50 DKK 61.50 DKK 
 USD $7.00 51.00 DKK 64.00 DKK 
 USD $7.25 53.00 DKK 66.00 DKK 
 USD $7.50 55.00 DKK 68.50 DKK 
 USD $7.75 56.50 DKK 70.50 DKK 
 USD $8.00 58.50 DKK 73.00 DKK 
 USD $8.25 60.50 DKK 75.50 DKK 
 USD $8.50 62.00 DKK 77.50 DKK 
 USD $8.75 64.00 DKK 80.00 DKK 
 USD $9.00 65.50 DKK 82.00 DKK 
 USD $9.25 67.50 DKK 84.50 DKK 
 USD $9.50 69.50 DKK 86.50 DKK 
 USD $9.75 71.00 DKK 89.00 DKK 
 USD $10.00 73.00 DKK 91.00 DKK 
 USD $11.00 80.50 DKK 100.50 DKK 
 USD $12.00 87.50 DKK 109.50 DKK 
 USD $13.00 95.00 DKK 118.50 DKK 
 USD $14.00 102.00 DKK 127.50 DKK 
 USD $15.00 109.50 DKK 136.50 DKK 
 USD $16.00 116.50 DKK 146.00 DKK 
 USD $17.00 124.00 DKK 155.00 DKK 
 USD $18.00 131.00 DKK 164.00 DKK 
 USD $19.00 138.50 DKK 173.00 DKK 
 USD $20.00 146.00 DKK 182.00 DKK 
 USD $21.00 153.00 DKK 191.50 DKK 
 USD $22.00 160.50 DKK 200.50 DKK 
 USD $23.00 167.50 DKK 209.50 DKK 
 USD $24.00 175.00 DKK 218.50 DKK 
 USD $25.00 182.00 DKK 227.50 DKK 
 USD $26.00 189.50 DKK 236.50 DKK 
 USD $27.00 196.50 DKK 246.00 DKK 
 USD $28.00 204.00 DKK 255.00 DKK 
 USD $29.00 211.50 DKK 264.00 DKK 
 USD $30.00 218.50 DKK 273.00 DKK 
 USD $31.00 226.00 DKK 282.00 DKK 
 USD $32.00 233.00 DKK 291.50 DKK 
 USD $33.00 240.50 DKK 300.50 DKK 
 USD $34.00 247.50 DKK 309.50 DKK 
 USD $35.00 255.00 DKK 318.50 DKK 
 USD $36.00 262.00 DKK 327.50 DKK 
 USD $37.00 269.50 DKK 337.00 DKK 
 USD $38.00 277.00 DKK 346.00 DKK 
 USD $39.00 284.00 DKK 355.00 DKK 
 USD $40.00 291.50 DKK 364.00 DKK 
 USD $41.00 298.50 DKK 373.00 DKK 
 USD $42.00 306.00 DKK 382.50 DKK 
 USD $43.00 313.00 DKK 391.50 DKK 
 USD $44.00 320.50 DKK 400.50 DKK 
 USD $45.00 327.50 DKK 409.50 DKK 
 USD $46.00 335.00 DKK 418.50 DKK 
 USD $47.00 342.50 DKK 428.00 DKK 
 USD $48.00 349.50 DKK 437.00 DKK 
 USD $49.00 357.00 DKK 446.00 DKK 
 USD $50.00 364.00 DKK 455.00 DKK 
 USD $60.00 437.00 DKK 546.00 DKK 
 USD $70.00 509.50 DKK 637.00 DKK 
 USD $80.00 582.50 DKK 728.00 DKK 
 USD $90.00 655.00 DKK 819.00 DKK 
 USD $100.00 728.00 DKK 910.00 DKK 
 EUR
 Price Point France, Germany, Italy, Portugal, Spain 
 USD $2.00 2.49 EUR 
 USD $2.25 2.69 EUR 
 USD $2.50 2.99 EUR 
 USD $2.75 3.29 EUR 
 USD $3.00 3.49 EUR 
 USD $3.25 3.99 EUR 
 USD $3.50 3.99 EUR 
 USD $3.75 4.49 EUR 
 USD $4.00 4.69 EUR 
 USD $4.25 4.99 EUR 
 USD $4.50 5.29 EUR 
 USD $4.75 5.49 EUR 
 USD $5.00 5.99 EUR 
 USD $5.25 5.99 EUR 
 USD $5.50 6.49 EUR 
 USD $5.75 6.69 EUR 
 USD $6.00 6.99 EUR 
 USD $6.25 7.29 EUR 
 USD $6.50 7.49 EUR 
 USD $6.75 7.99 EUR 
 USD $7.00 7.99 EUR 
 USD $7.25 8.49 EUR 
 USD $7.50 8.69 EUR 
 USD $7.75 8.99 EUR 
 USD $8.00 9.29 EUR 
 USD $8.25 9.49 EUR 
 USD $8.50 9.99 EUR 
 USD $8.75 9.99 EUR 
 USD $9.00 10.49 EUR 
 USD $9.25 10.69 EUR 
 USD $9.50 10.99 EUR 
 USD $9.75 11.29 EUR 
 USD $10.00 11.49 EUR 
 USD $11.00 12.69 EUR 
 USD $12.00 13.99 EUR 
 USD $13.00 14.99 EUR 
 USD $14.00 15.99 EUR 
 USD $15.00 17.29 EUR 
 USD $16.00 18.49 EUR 
 USD $17.00 19.49 EUR 
 USD $18.00 20.69 EUR 
 USD $19.00 21.99 EUR 
 USD $20.00 22.99 EUR 
 USD $21.00 23.99 EUR 
 USD $22.00 25.29 EUR 
 USD $23.00 26.49 EUR 
 USD $24.00 27.49 EUR 
 USD $25.00 28.69 EUR 
 USD $26.00 29.99 EUR 
 USD $27.00 30.99 EUR 
 USD $28.00 31.99 EUR 
 USD $29.00 33.29 EUR 
 USD $30.00 34.49 EUR 
 USD $31.00 35.49 EUR 
 USD $32.00 36.69 EUR 
 USD $33.00 37.99 EUR 
 USD $34.00 38.99 EUR 
 USD $35.00 40.29 EUR 
 USD $36.00 41.29 EUR 
 USD $37.00 42.49 EUR 
 USD $38.00 43.49 EUR 
 USD $39.00 44.69 EUR 
 USD $40.00 45.99 EUR 
 USD $41.00 46.99 EUR 
 USD $42.00 48.29 EUR 
 USD $43.00 49.29 EUR 
 USD $44.00 50.49 EUR 
 USD $45.00 51.49 EUR 
 USD $46.00 52.69 EUR 
 USD $47.00 53.99 EUR 
 USD $48.00 54.99 EUR 
 USD $49.00 56.29 EUR 
 USD $50.00 57.29 EUR 
 USD $60.00 68.69 EUR 
 USD $70.00 80.29 EUR 
 USD $80.00 91.49 EUR 
 USD $90.00 102.99 EUR 
 USD $100.00 114.49 EUR 
 GBP
 Price Point Gibraltar United Kingdom 
 USD $2.00 1.69 GBP 1.99 GBP 
 USD $2.25 1.99 GBP 2.29 GBP 
 USD $2.50 2.29 GBP 2.49 GBP 
 USD $2.75 2.29 GBP 2.69 GBP 
 USD $3.00 2.49 GBP 2.99 GBP 
 USD $3.25 2.69 GBP 3.29 GBP 
 USD $3.50 2.99 GBP 3.49 GBP 
 USD $3.75 3.29 GBP 3.69 GBP 
 USD $4.00 3.29 GBP 3.99 GBP 
 USD $4.25 3.49 GBP 4.29 GBP 
 USD $4.50 3.69 GBP 4.49 GBP 
 USD $4.75 3.99 GBP 4.69 GBP 
 USD $5.00 4.29 GBP 4.99 GBP 
 USD $5.25 4.29 GBP 5.29 GBP 
 USD $5.50 4.49 GBP 5.49 GBP 
 USD $5.75 4.69 GBP 5.69 GBP 
 USD $6.00 4.99 GBP 5.99 GBP 
 USD $6.25 5.29 GBP 6.29 GBP 
 USD $6.50 5.29 GBP 6.49 GBP 
 USD $6.75 5.49 GBP 6.69 GBP 
 USD $7.00 5.69 GBP 6.99 GBP 
 USD $7.25 5.99 GBP 6.99 GBP 
 USD $7.50 6.29 GBP 7.29 GBP 
 USD $7.75 6.29 GBP 7.49 GBP 
 USD $8.00 6.49 GBP 7.99 GBP 
 USD $8.25 6.69 GBP 7.99 GBP 
 USD $8.50 6.99 GBP 8.29 GBP 
 USD $8.75 7.29 GBP 8.49 GBP 
 USD $9.00 7.29 GBP 8.69 GBP 
 USD $9.25 7.49 GBP 8.99 GBP 
 USD $9.50 7.69 GBP 9.29 GBP 
 USD $9.75 7.99 GBP 9.49 GBP 
 USD $10.00 8.29 GBP 9.69 GBP 
 USD $11.00 8.99 GBP 10.69 GBP 
 USD $12.00 9.69 GBP 11.69 GBP 
 USD $13.00 10.49 GBP 12.69 GBP 
 USD $14.00 11.49 GBP 13.69 GBP 
 USD $15.00 12.29 GBP 14.49 GBP 
 USD $16.00 12.99 GBP 15.49 GBP 
 USD $17.00 13.69 GBP 16.49 GBP 
 USD $18.00 14.49 GBP 17.49 GBP 
 USD $19.00 15.49 GBP 18.49 GBP 
 USD $20.00 16.29 GBP 19.49 GBP 
 USD $21.00 16.99 GBP 20.49 GBP 
 USD $22.00 17.99 GBP 21.49 GBP 
 USD $23.00 18.69 GBP 22.29 GBP 
 USD $24.00 19.49 GBP 23.29 GBP 
 USD $25.00 20.29 GBP 24.29 GBP 
 USD $26.00 20.99 GBP 25.29 GBP 
 USD $27.00 21.99 GBP 26.29 GBP 
 USD $28.00 22.69 GBP 27.29 GBP 
 USD $29.00 23.49 GBP 28.29 GBP 
 USD $30.00 24.29 GBP 28.99 GBP 
 USD $31.00 24.99 GBP 29.99 GBP 
 USD $32.00 25.99 GBP 30.99 GBP 
 USD $33.00 26.69 GBP 31.99 GBP 
 USD $34.00 27.49 GBP 32.99 GBP 
 USD $35.00 28.29 GBP 33.99 GBP 
 USD $36.00 28.99 GBP 34.99 GBP 
 USD $37.00 29.99 GBP 35.99 GBP 
 USD $38.00 30.69 GBP 36.99 GBP 
 USD $39.00 31.49 GBP 37.69 GBP 
 USD $40.00 32.29 GBP 38.69 GBP 
 USD $41.00 33.29 GBP 39.69 GBP 
 USD $42.00 33.99 GBP 40.69 GBP 
 USD $43.00 34.69 GBP 41.69 GBP 
 USD $44.00 35.49 GBP 42.69 GBP 
 USD $45.00 36.29 GBP 43.49 GBP 
 USD $46.00 37.29 GBP 44.49 GBP 
 USD $47.00 37.99 GBP 45.49 GBP 
 USD $48.00 38.69 GBP 46.49 GBP 
 USD $49.00 39.49 GBP 47.49 GBP 
 USD $50.00 40.49 GBP 48.49 GBP 
 USD $60.00 48.49 GBP 57.99 GBP 
 USD $70.00 56.49 GBP 67.69 GBP 
 USD $80.00 64.49 GBP 77.49 GBP 
 USD $90.00 72.49 GBP 86.99 GBP 
 USD $100.00 80.69 GBP 96.69 GBP 
 MXN
 Price Point Mexico 
 USD $2.00 39.25 MXN 
 USD $2.25 44.25 MXN 
 USD $2.50 48.99 MXN 
 USD $2.75 53.99 MXN 
 USD $3.00 58.75 MXN 
 USD $3.25 63.75 MXN 
 USD $3.50 68.75 MXN 
 USD $3.75 73.49 MXN 
 USD $4.00 78.49 MXN 
 USD $4.25 83.25 MXN 
 USD $4.50 88.25 MXN 
 USD $4.75 93.25 MXN 
 USD $5.00 97.99 MXN 
 USD $5.25 102.99 MXN 
 USD $5.50 107.75 MXN 
 USD $5.75 112.75 MXN 
 USD $6.00 117.49 MXN 
 USD $6.25 122.49 MXN 
 USD $6.50 127.49 MXN 
 USD $6.75 132.25 MXN 
 USD $7.00 137.25 MXN 
 USD $7.25 141.99 MXN 
 USD $7.50 146.99 MXN 
 USD $7.75 151.99 MXN 
 USD $8.00 156.75 MXN 
 USD $8.25 161.75 MXN 
 USD $8.50 166.49 MXN 
 USD $8.75 171.49 MXN 
 USD $9.00 176.25 MXN 
 USD $9.25 181.25 MXN 
 USD $9.50 186.25 MXN 
 USD $9.75 190.99 MXN 
 USD $10.00 195.99 MXN 
 USD $11.00 215.49 MXN 
 USD $12.00 234.99 MXN 
 USD $13.00 254.75 MXN 
 USD $14.00 274.25 MXN 
 USD $15.00 293.75 MXN 
 USD $16.00 313.49 MXN 
 USD $17.00 332.99 MXN 
 USD $18.00 352.49 MXN 
 USD $19.00 372.25 MXN 
 USD $20.00 391.75 MXN 
 USD $21.00 411.25 MXN 
 USD $22.00 430.99 MXN 
 USD $23.00 450.49 MXN 
 USD $24.00 469.99 MXN 
 USD $25.00 489.75 MXN 
 USD $26.00 509.25 MXN 
 USD $27.00 528.75 MXN 
 USD $28.00 548.49 MXN 
 USD $29.00 567.99 MXN 
 USD $30.00 587.49 MXN 
 USD $31.00 607.25 MXN 
 USD $32.00 626.75 MXN 
 USD $33.00 646.25 MXN 
 USD $34.00 665.99 MXN 
 USD $35.00 685.49 MXN 
 USD $36.00 704.99 MXN 
 USD $37.00 724.75 MXN 
 USD $38.00 744.25 MXN 
 USD $39.00 763.75 MXN 
 USD $40.00 783.25 MXN 
 USD $41.00 802.99 MXN 
 USD $42.00 822.49 MXN 
 USD $43.00 841.99 MXN 
 USD $44.00 861.75 MXN 
 USD $45.00 881.25 MXN 
 USD $46.00 900.75 MXN 
 USD $47.00 920.49 MXN 
 USD $48.00 939.99 MXN 
 USD $49.00 959.49 MXN 
 USD $50.00 979.25 MXN 
 USD $60.00 1174.99 MXN 
 USD $70.00 1370.75 MXN 
 USD $80.00 1566.49 MXN 
 USD $90.00 1762.49 MXN 
 USD $100.00 1958.25 MXN 
 NOK
 Price Point Svalbard and Jan Mayen Norway 
 USD $2.00 22.50 NOK 28.00 NOK 
 USD $2.25 25.50 NOK 31.50 NOK 
 USD $2.50 28.00 NOK 35.00 NOK 
 USD $2.75 31.00 NOK 38.50 NOK 
 USD $3.00 34.00 NOK 42.00 NOK 
 USD $3.25 36.50 NOK 45.50 NOK 
 USD $3.50 39.50 NOK 49.00 NOK 
 USD $3.75 42.00 NOK 52.50 NOK 
 USD $4.00 45.00 NOK 56.00 NOK 
 USD $4.25 48.00 NOK 59.50 NOK 
 USD $4.50 50.50 NOK 63.00 NOK 
 USD $4.75 53.50 NOK 66.50 NOK 
 USD $5.00 56.00 NOK 70.00 NOK 
 USD $5.25 59.00 NOK 73.50 NOK 
 USD $5.50 62.00 NOK 77.00 NOK 
 USD $5.75 64.50 NOK 80.50 NOK 
 USD $6.00 67.50 NOK 84.00 NOK 
 USD $6.25 70.00 NOK 87.50 NOK 
 USD $6.50 73.00 NOK 91.00 NOK 
 USD $6.75 76.00 NOK 94.50 NOK 
 USD $7.00 78.50 NOK 98.00 NOK 
 USD $7.25 81.50 NOK 101.50 NOK 
 USD $7.50 84.00 NOK 105.00 NOK 
 USD $7.75 87.00 NOK 108.50 NOK 
 USD $8.00 90.00 NOK 112.00 NOK 
 USD $8.25 92.50 NOK 115.50 NOK 
 USD $8.50 95.50 NOK 119.00 NOK 
 USD $8.75 98.00 NOK 122.50 NOK 
 USD $9.00 101.00 NOK 126.00 NOK 
 USD $9.25 103.50 NOK 129.50 NOK 
 USD $9.50 106.50 NOK 133.00 NOK 
 USD $9.75 109.50 NOK 136.50 NOK 
 USD $10.00 112.00 NOK 140.00 NOK 
 USD $11.00 123.50 NOK 154.00 NOK 
 USD $12.00 134.50 NOK 168.00 NOK 
 USD $13.00 145.50 NOK 182.00 NOK 
 USD $14.00 157.00 NOK 196.00 NOK 
 USD $15.00 168.00 NOK 210.00 NOK 
 USD $16.00 179.50 NOK 224.00 NOK 
 USD $17.00 190.50 NOK 238.00 NOK 
 USD $18.00 201.50 NOK 252.00 NOK 
 USD $19.00 213.00 NOK 266.00 NOK 
 USD $20.00 224.00 NOK 280.00 NOK 
 USD $21.00 235.00 NOK 294.00 NOK 
 USD $22.00 246.50 NOK 308.00 NOK 
 USD $23.00 257.50 NOK 322.00 NOK 
 USD $24.00 269.00 NOK 336.00 NOK 
 USD $25.00 280.00 NOK 350.00 NOK 
 USD $26.00 291.00 NOK 364.00 NOK 
 USD $27.00 302.50 NOK 378.00 NOK 
 USD $28.00 313.50 NOK 392.00 NOK 
 USD $29.00 324.50 NOK 406.00 NOK 
 USD $30.00 336.00 NOK 420.00 NOK 
 USD $31.00 347.00 NOK 434.00 NOK 
 USD $32.00 358.50 NOK 448.00 NOK 
 USD $33.00 369.50 NOK 461.50 NOK 
 USD $34.00 380.50 NOK 475.50 NOK 
 USD $35.00 392.00 NOK 489.50 NOK 
 USD $36.00 403.00 NOK 503.50 NOK 
 USD $37.00 414.00 NOK 517.50 NOK 
 USD $38.00 425.50 NOK 531.50 NOK 
 USD $39.00 436.50 NOK 545.50 NOK 
 USD $40.00 448.00 NOK 559.50 NOK 
 USD $41.00 459.00 NOK 573.50 NOK 
 USD $42.00 470.00 NOK 587.50 NOK 
 USD $43.00 481.50 NOK 601.50 NOK 
 USD $44.00 492.50 NOK 615.50 NOK 
 USD $45.00 503.50 NOK 629.50 NOK 
 USD $46.00 515.00 NOK 643.50 NOK 
 USD $47.00 526.00 NOK 657.50 NOK 
 USD $48.00 537.50 NOK 671.50 NOK 
 USD $49.00 548.50 NOK 685.50 NOK 
 USD $50.00 559.50 NOK 699.50 NOK 
 USD $60.00 671.50 NOK 839.50 NOK 
 USD $70.00 783.50 NOK 979.00 NOK 
 USD $80.00 895.50 NOK 1119.00 NOK 
 USD $90.00 1007.00 NOK 1259.00 NOK 
 USD $100.00 1119.00 NOK 1398.50 NOK 
 NZD
 Price Point New Zealand 
 USD $2.00 3.49 NZD 
 USD $2.25 3.99 NZD 
 USD $2.50 4.49 NZD 
 USD $2.75 4.75 NZD 
 USD $3.00 5.25 NZD 
 USD $3.25 5.75 NZD 
 USD $3.50 6.25 NZD 
 USD $3.75 6.49 NZD 
 USD $4.00 6.99 NZD 
 USD $4.25 7.49 NZD 
 USD $4.50 7.75 NZD 
 USD $4.75 8.25 NZD 
 USD $5.00 8.75 NZD 
 USD $5.25 9.25 NZD 
 USD $5.50 9.49 NZD 
 USD $5.75 9.99 NZD 
 USD $6.00 10.49 NZD 
 USD $6.25 10.99 NZD 
 USD $6.50 11.25 NZD 
 USD $6.75 11.75 NZD 
 USD $7.00 12.25 NZD 
 USD $7.25 12.49 NZD 
 USD $7.50 12.99 NZD 
 USD $7.75 13.49 NZD 
 USD $8.00 13.99 NZD 
 USD $8.25 14.25 NZD 
 USD $8.50 14.75 NZD 
 USD $8.75 15.25 NZD 
 USD $9.00 15.49 NZD 
 USD $9.25 15.99 NZD 
 USD $9.50 16.49 NZD 
 USD $9.75 16.99 NZD 
 USD $10.00 17.25 NZD 
 USD $11.00 18.99 NZD 
 USD $12.00 20.75 NZD 
 USD $13.00 22.49 NZD 
 USD $14.00 24.25 NZD 
 USD $15.00 25.99 NZD 
 USD $16.00 27.75 NZD 
 USD $17.00 29.49 NZD 
 USD $18.00 30.99 NZD 
 USD $19.00 32.75 NZD 
 USD $20.00 34.49 NZD 
 USD $21.00 36.25 NZD 
 USD $22.00 37.99 NZD 
 USD $23.00 39.75 NZD 
 USD $24.00 41.49 NZD 
 USD $25.00 43.25 NZD 
 USD $26.00 44.99 NZD 
 USD $27.00 46.49 NZD 
 USD $28.00 48.25 NZD 
 USD $29.00 49.99 NZD 
 USD $30.00 51.75 NZD 
 USD $31.00 53.49 NZD 
 USD $32.00 55.25 NZD 
 USD $33.00 56.99 NZD 
 USD $34.00 58.75 NZD 
 USD $35.00 60.49 NZD 
 USD $36.00 61.99 NZD 
 USD $37.00 63.75 NZD 
 USD $38.00 65.49 NZD 
 USD $39.00 67.25 NZD 
 USD $40.00 68.99 NZD 
 USD $41.00 70.75 NZD 
 USD $42.00 72.49 NZD 
 USD $43.00 74.25 NZD 
 USD $44.00 75.99 NZD 
 USD $45.00 77.49 NZD 
 USD $46.00 79.25 NZD 
 USD $47.00 80.99 NZD 
 USD $48.00 82.75 NZD 
 USD $49.00 84.49 NZD 
 USD $50.00 86.25 NZD 
 USD $60.00 103.49 NZD 
 USD $70.00 120.75 NZD 
 USD $80.00 137.75 NZD 
 USD $90.00 154.99 NZD 
 USD $100.00 172.25 NZD 
 RON
 Price Point Romania 
 USD $2.00 19 RON 
 USD $2.25 19 RON 
 USD $2.50 19 RON 
 USD $2.75 19 RON 
 USD $3.00 19 RON 
 USD $3.25 19 RON 
 USD $3.50 29 RON 
 USD $3.75 29 RON 
 USD $4.00 29 RON 
 USD $4.25 29 RON 
 USD $4.50 29 RON 
 USD $4.75 29 RON 
 USD $5.00 39 RON 
 USD $5.25 39 RON 
 USD $5.50 39 RON 
 USD $5.75 39 RON 
 USD $6.00 39 RON 
 USD $6.25 39 RON 
 USD $6.50 39 RON 
 USD $6.75 49 RON 
 USD $7.00 49 RON 
 USD $7.25 49 RON 
 USD $7.50 49 RON 
 USD $7.75 49 RON 
 USD $8.00 49 RON 
 USD $8.25 49 RON 
 USD $8.50 59 RON 
 USD $8.75 59 RON 
 USD $9.00 59 RON 
 USD $9.25 59 RON 
 USD $9.50 59 RON 
 USD $9.75 59 RON 
 USD $10.00 69 RON 
 USD $11.00 69 RON 
 USD $12.00 79 RON 
 USD $13.00 79 RON 
 USD $14.00 89 RON 
 USD $15.00 99 RON 
 USD $16.00 99 RON 
 USD $17.00 109 RON 
 USD $18.00 109 RON 
 USD $19.00 119 RON 
 USD $20.00 129 RON 
 USD $21.00 129 RON 
 USD $22.00 139 RON 
 USD $23.00 139 RON 
 USD $24.00 149 RON 
 USD $25.00 159 RON 
 USD $26.00 159 RON 
 USD $27.00 169 RON 
 USD $28.00 169 RON 
 USD $29.00 179 RON 
 USD $30.00 189 RON 
 USD $31.00 189 RON 
 USD $32.00 199 RON 
 USD $33.00 199 RON 
 USD $34.00 209 RON 
 USD $35.00 219 RON 
 USD $36.00 219 RON 
 USD $37.00 229 RON 
 USD $38.00 229 RON 
 USD $39.00 239 RON 
 USD $40.00 249 RON 
 USD $41.00 249 RON 
 USD $42.00 259 RON 
 USD $43.00 259 RON 
 USD $44.00 269 RON 
 USD $45.00 279 RON 
 USD $46.00 279 RON 
 USD $47.00 289 RON 
 USD $48.00 289 RON 
 USD $49.00 299 RON 
 USD $50.00 309 RON 
 USD $60.00 369 RON 
 USD $70.00 429 RON 
 USD $80.00 489 RON 
 USD $90.00 549 RON 
 USD $100.00 609 RON 
 SEK
 Price Point Sweden 
 USD $2.00 28.00 SEK 
 USD $2.25 31.50 SEK 
 USD $2.50 35.00 SEK 
 USD $2.75 38.50 SEK 
 USD $3.00 42.00 SEK 
 USD $3.25 45.50 SEK 
 USD $3.50 49.00 SEK 
 USD $3.75 52.50 SEK 
 USD $4.00 56.00 SEK 
 USD $4.25 59.50 SEK 
 USD $4.50 63.00 SEK 
 USD $4.75 66.50 SEK 
 USD $5.00 70.00 SEK 
 USD $5.25 73.50 SEK 
 USD $5.50 77.00 SEK 
 USD $5.75 80.50 SEK 
 USD $6.00 83.50 SEK 
 USD $6.25 87.00 SEK 
 USD $6.50 90.50 SEK 
 USD $6.75 94.00 SEK 
 USD $7.00 97.50 SEK 
 USD $7.25 101.00 SEK 
 USD $7.50 104.50 SEK 
 USD $7.75 108.00 SEK 
 USD $8.00 111.50 SEK 
 USD $8.25 115.00 SEK 
 USD $8.50 118.50 SEK 
 USD $8.75 122.00 SEK 
 USD $9.00 125.50 SEK 
 USD $9.25 129.00 SEK 
 USD $9.50 132.50 SEK 
 USD $9.75 136.00 SEK 
 USD $10.00 139.50 SEK 
 USD $11.00 153.50 SEK 
 USD $12.00 167.00 SEK 
 USD $13.00 181.00 SEK 
 USD $14.00 195.00 SEK 
 USD $15.00 209.00 SEK 
 USD $16.00 223.00 SEK 
 USD $17.00 237.00 SEK 
 USD $18.00 250.50 SEK 
 USD $19.00 264.50 SEK 
 USD $20.00 278.50 SEK 
 USD $21.00 292.50 SEK 
 USD $22.00 306.50 SEK 
 USD $23.00 320.50 SEK 
 USD $24.00 334.00 SEK 
 USD $25.00 348.00 SEK 
 USD $26.00 362.00 SEK 
 USD $27.00 376.00 SEK 
 USD $28.00 390.00 SEK 
 USD $29.00 403.50 SEK 
 USD $30.00 417.50 SEK 
 USD $31.00 431.50 SEK 
 USD $32.00 445.50 SEK 
 USD $33.00 459.50 SEK 
 USD $34.00 473.50 SEK 
 USD $35.00 487.00 SEK 
 USD $36.00 501.00 SEK 
 USD $37.00 515.00 SEK 
 USD $38.00 529.00 SEK 
 USD $39.00 543.00 SEK 
 USD $40.00 557.00 SEK 
 USD $41.00 570.50 SEK 
 USD $42.00 584.50 SEK 
 USD $43.00 598.50 SEK 
 USD $44.00 612.50 SEK 
 USD $45.00 626.50 SEK 
 USD $46.00 640.50 SEK 
 USD $47.00 654.00 SEK 
 USD $48.00 668.00 SEK 
 USD $49.00 682.00 SEK 
 USD $50.00 696.00 SEK 
 USD $60.00 835.00 SEK 
 USD $70.00 974.00 SEK 
 USD $80.00 1113.50 SEK 
 USD $90.00 1252.50 SEK 
 USD $100.00 1391.50 SEK 
 THB
 Price Point Thailand 
 USD $2.00 79 THB 
 USD $2.25 89 THB 
 USD $2.50 99 THB 
 USD $2.75 109 THB 
 USD $3.00 119 THB 
 USD $3.25 129 THB 
 USD $3.50 139 THB 
 USD $3.75 149 THB 
 USD $4.00 159 THB 
 USD $4.25 169 THB 
 USD $4.50 179 THB 
 USD $4.75 189 THB 
 USD $5.00 199 THB 
 USD $5.25 209 THB 
 USD $5.50 219 THB 
 USD $5.75 229 THB 
 USD $6.00 239 THB 
 USD $6.25 249 THB 
 USD $6.50 259 THB 
 USD $6.75 269 THB 
 USD $7.00 279 THB 
 USD $7.25 289 THB 
 USD $7.50 299 THB 
 USD $7.75 309 THB 
 USD $8.00 319 THB 
 USD $8.25 329 THB 
 USD $8.50 339 THB 
 USD $8.75 349 THB 
 USD $9.00 359 THB 
 USD $9.25 369 THB 
 USD $9.50 379 THB 
 USD $9.75 389 THB 
 USD $10.00 399 THB 
 USD $11.00 439 THB 
 USD $12.00 479 THB 
 USD $13.00 519 THB 
 USD $14.00 559 THB 
 USD $15.00 599 THB 
 USD $16.00 639 THB 
 USD $17.00 679 THB 
 USD $18.00 719 THB 
 USD $19.00 759 THB 
 USD $20.00 799 THB 
 USD $21.00 839 THB 
 USD $22.00 879 THB 
 USD $23.00 919 THB 
 USD $24.00 959 THB 
 USD $25.00 999 THB 
 USD $26.00 1039 THB 
 USD $27.00 1079 THB 
 USD $28.00 1119 THB 
 USD $29.00 1159 THB 
 USD $30.00 1199 THB 
 USD $31.00 1239 THB 
 USD $32.00 1279 THB 
 USD $33.00 1319 THB 
 USD $34.00 1359 THB 
 USD $35.00 1399 THB 
 USD $36.00 1439 THB 
 USD $37.00 1479 THB 
 USD $38.00 1519 THB 
 USD $39.00 1559 THB 
 USD $40.00 1599 THB 
 USD $41.00 1639 THB 
 USD $42.00 1679 THB 
 USD $43.00 1719 THB 
 USD $44.00 1759 THB 
 USD $45.00 1799 THB 
 USD $46.00 1839 THB 
 USD $47.00 1879 THB 
 USD $48.00 1919 THB 
 USD $49.00 1959 THB 
 USD $50.00 1999 THB 
 USD $60.00 2389 THB 
 USD $70.00 2789 THB 
 USD $80.00 3189 THB 
 USD $90.00 3589 THB 
 USD $100.00 3989 THB 
 USD
 Price Point United States Taiwan Indonesia, Japan, Puerto Rico, Singapore Saudi Arabia India Iceland 
 USD $2.00 1.99 USD 2.25 USD 2.25 USD 2.49 USD 2.49 USD 2.49 USD 
 USD $2.25 2.25 USD 2.49 USD 2.49 USD 2.75 USD 2.75 USD 2.99 USD 
 USD $2.50 2.49 USD 2.75 USD 2.75 USD 2.99 USD 2.99 USD 3.25 USD 
 USD $2.75 2.75 USD 2.99 USD 3.25 USD 3.25 USD 3.49 USD 3.49 USD 
 USD $3.00 2.99 USD 3.25 USD 3.49 USD 3.49 USD 3.75 USD 3.75 USD 
 USD $3.25 3.25 USD 3.49 USD 3.75 USD 3.75 USD 3.99 USD 4.25 USD 
 USD $3.50 3.49 USD 3.75 USD 3.99 USD 4.25 USD 4.25 USD 4.49 USD 
 USD $3.75 3.75 USD 3.99 USD 4.25 USD 4.49 USD 4.49 USD 4.75 USD 
 USD $4.00 3.99 USD 4.25 USD 4.49 USD 4.75 USD 4.99 USD 4.99 USD 
 USD $4.25 4.25 USD 4.49 USD 4.75 USD 4.99 USD 5.25 USD 5.49 USD 
 USD $4.50 4.49 USD 4.75 USD 4.99 USD 5.25 USD 5.49 USD 5.75 USD 
 USD $4.75 4.75 USD 4.99 USD 5.25 USD 5.49 USD 5.75 USD 5.99 USD 
 USD $5.00 4.99 USD 5.25 USD 5.49 USD 5.75 USD 5.99 USD 6.25 USD 
 USD $5.25 5.25 USD 5.75 USD 5.99 USD 6.25 USD 6.49 USD 6.75 USD 
 USD $5.50 5.49 USD 5.99 USD 6.25 USD 6.49 USD 6.75 USD 6.99 USD 
 USD $5.75 5.75 USD 6.25 USD 6.49 USD 6.75 USD 6.99 USD 7.25 USD 
 USD $6.00 5.99 USD 6.49 USD 6.75 USD 6.99 USD 7.25 USD 7.49 USD 
 USD $6.25 6.25 USD 6.75 USD 6.99 USD 7.25 USD 7.49 USD 7.99 USD 
 USD $6.50 6.49 USD 6.99 USD 7.25 USD 7.49 USD 7.99 USD 8.25 USD 
 USD $6.75 6.75 USD 7.25 USD 7.49 USD 7.99 USD 8.25 USD 8.49 USD 
 USD $7.00 6.99 USD 7.49 USD 7.75 USD 8.25 USD 8.49 USD 8.75 USD 
 USD $7.25 7.25 USD 7.75 USD 7.99 USD 8.49 USD 8.75 USD 9.25 USD 
 USD $7.50 7.49 USD 7.99 USD 8.25 USD 8.75 USD 8.99 USD 9.49 USD 
 USD $7.75 7.75 USD 8.25 USD 8.75 USD 8.99 USD 9.49 USD 9.75 USD 
 USD $8.00 7.99 USD 8.49 USD 8.99 USD 9.25 USD 9.75 USD 9.99 USD 
 USD $8.25 8.25 USD 8.75 USD 9.25 USD 9.49 USD 9.99 USD 10.49 USD 
 USD $8.50 8.49 USD 8.99 USD 9.49 USD 9.99 USD 10.25 USD 10.75 USD 
 USD $8.75 8.75 USD 9.25 USD 9.75 USD 10.25 USD 10.49 USD 10.99 USD 
 USD $9.00 8.99 USD 9.49 USD 9.99 USD 10.49 USD 10.99 USD 11.25 USD 
 USD $9.25 9.25 USD 9.75 USD 10.25 USD 10.75 USD 11.25 USD 11.75 USD 
 USD $9.50 9.49 USD 9.99 USD 10.49 USD 10.99 USD 11.49 USD 11.99 USD 
 USD $9.75 9.75 USD 10.25 USD 10.75 USD 11.25 USD 11.75 USD 12.25 USD 
 USD $10.00 9.99 USD 10.49 USD 10.99 USD 11.49 USD 11.99 USD 12.49 USD 
 USD $11.00 10.99 USD 11.75 USD 12.25 USD 12.75 USD 13.25 USD 13.75 USD 
 USD $12.00 11.99 USD 12.75 USD 13.25 USD 13.99 USD 14.49 USD 14.99 USD 
 USD $13.00 12.99 USD 13.75 USD 14.49 USD 14.99 USD 15.75 USD 16.25 USD 
 USD $14.00 13.99 USD 14.75 USD 15.49 USD 16.25 USD 16.99 USD 17.49 USD 
 USD $15.00 14.99 USD 15.75 USD 16.49 USD 17.25 USD 17.99 USD 18.75 USD 
 USD $16.00 15.99 USD 16.99 USD 17.75 USD 18.49 USD 19.25 USD 19.99 USD 
 USD $17.00 16.99 USD 17.99 USD 18.75 USD 19.75 USD 20.49 USD 21.25 USD 
 USD $18.00 17.99 USD 18.99 USD 19.99 USD 20.75 USD 21.75 USD 22.49 USD 
 USD $19.00 18.99 USD 19.99 USD 20.99 USD 21.99 USD 22.99 USD 23.75 USD 
 USD $20.00 19.99 USD 20.99 USD 21.99 USD 22.99 USD 23.99 USD 24.99 USD 
 USD $21.00 20.99 USD 22.25 USD 23.25 USD 24.25 USD 25.25 USD 26.25 USD 
 USD $22.00 21.99 USD 23.25 USD 24.25 USD 25.49 USD 26.49 USD 27.49 USD 
 USD $23.00 22.99 USD 24.25 USD 25.49 USD 26.49 USD 27.75 USD 28.75 USD 
 USD $24.00 23.99 USD 25.25 USD 26.49 USD 27.75 USD 28.99 USD 29.99 USD 
 USD $25.00 24.99 USD 26.25 USD 27.75 USD 28.75 USD 29.99 USD 31.25 USD 
 USD $26.00 25.99 USD 27.49 USD 28.75 USD 29.99 USD 31.25 USD 32.49 USD 
 USD $27.00 26.99 USD 28.49 USD 29.75 USD 31.25 USD 32.49 USD 33.75 USD 
 USD $28.00 27.99 USD 29.49 USD 30.99 USD 32.25 USD 33.75 USD 34.99 USD 
 USD $29.00 28.99 USD 30.49 USD 31.99 USD 33.49 USD 34.99 USD 36.25 USD 
 USD $30.00 29.99 USD 31.49 USD 32.99 USD 34.49 USD 35.99 USD 37.49 USD 
 USD $31.00 30.99 USD 32.75 USD 34.25 USD 35.75 USD 37.25 USD 38.75 USD 
 USD $32.00 31.99 USD 33.75 USD 35.25 USD 36.99 USD 38.49 USD 39.99 USD 
 USD $33.00 32.99 USD 34.75 USD 36.49 USD 37.99 USD 39.75 USD 41.25 USD 
 USD $34.00 33.99 USD 35.75 USD 37.49 USD 39.25 USD 40.99 USD 42.49 USD 
 USD $35.00 34.99 USD 36.75 USD 38.49 USD 40.25 USD 41.99 USD 43.75 USD 
 USD $36.00 35.99 USD 37.99 USD 39.75 USD 41.49 USD 43.25 USD 44.99 USD 
 USD $37.00 36.99 USD 38.99 USD 40.75 USD 42.75 USD 44.49 USD 46.25 USD 
 USD $38.00 37.99 USD 39.99 USD 41.99 USD 43.75 USD 45.75 USD 47.49 USD 
 USD $39.00 38.99 USD 40.99 USD 42.99 USD 44.99 USD 46.99 USD 48.75 USD 
 USD $40.00 39.99 USD 41.99 USD 43.99 USD 45.99 USD 47.99 USD 49.99 USD 
 USD $41.00 40.99 USD 43.25 USD 45.25 USD 47.25 USD 49.25 USD 51.25 USD 
 USD $42.00 41.99 USD 44.25 USD 46.25 USD 48.49 USD 50.49 USD 52.49 USD 
 USD $43.00 42.99 USD 45.25 USD 47.49 USD 49.49 USD 51.75 USD 53.75 USD 
 USD $44.00 43.99 USD 46.25 USD 48.49 USD 50.75 USD 52.99 USD 54.99 USD 
 USD $45.00 44.99 USD 47.25 USD 49.75 USD 51.75 USD 53.99 USD 56.25 USD 
 USD $46.00 45.99 USD 48.49 USD 50.75 USD 52.99 USD 55.25 USD 57.49 USD 
 USD $47.00 46.99 USD 49.49 USD 51.75 USD 54.25 USD 56.49 USD 58.75 USD 
 USD $48.00 47.99 USD 50.49 USD 52.99 USD 55.25 USD 57.75 USD 59.99 USD 
 USD $49.00 48.99 USD 51.49 USD 53.99 USD 56.49 USD 58.99 USD 61.25 USD 
 USD $50.00 49.99 USD 52.49 USD 54.99 USD 57.49 USD 59.99 USD 62.49 USD 
 USD $60.00 59.99 USD 62.99 USD 65.99 USD 68.99 USD 71.99 USD 74.99 USD 
 USD $70.00 69.99 USD 73.49 USD 76.99 USD 80.49 USD 83.99 USD 87.49 USD 
 USD $80.00 79.99 USD 83.99 USD 87.99 USD 91.99 USD 95.99 USD 99.99 USD 
 USD $90.00 89.99 USD 94.49 USD 98.99 USD 103.49 USD 107.99 USD 112.49 USD 
 USD $100.00 99.99 USD 104.99 USD 109.99 USD 114.99 USD 119.99 USD 124.99 USD 
 VND
 Price Point Vietnam 
 USD $2.00 55699 VND 
 USD $2.25 62599 VND 
 USD $2.50 69599 VND 
 USD $2.75 76499 VND 
 USD $3.00 83499 VND 
 USD $3.25 90399 VND 
 USD $3.50 97399 VND 
 USD $3.75 104299 VND 
 USD $4.00 111299 VND 
 USD $4.25 118199 VND 
 USD $4.50 125199 VND 
 USD $4.75 132099 VND 
 USD $5.00 139099 VND 
 USD $5.25 145999 VND 
 USD $5.50 152999 VND 
 USD $5.75 159899 VND 
 USD $6.00 166899 VND 
 USD $6.25 173799 VND 
 USD $6.50 180799 VND 
 USD $6.75 187699 VND 
 USD $7.00 194699 VND 
 USD $7.25 201599 VND 
 USD $7.50 208599 VND 
 USD $7.75 215499 VND 
 USD $8.00 222499 VND 
 USD $8.25 229399 VND 
 USD $8.50 236399 VND 
 USD $8.75 243299 VND 
 USD $9.00 250299 VND 
 USD $9.25 257199 VND 
 USD $9.50 264199 VND 
 USD $9.75 271099 VND 
 USD $10.00 278099 VND 
 USD $11.00 305899 VND 
 USD $12.00 333699 VND 
 USD $13.00 361499 VND 
 USD $14.00 389299 VND 
 USD $15.00 417099 VND 
 USD $16.00 444899 VND 
 USD $17.00 472699 VND 
 USD $18.00 500499 VND 
 USD $19.00 528299 VND 
 USD $20.00 556099 VND 
 USD $21.00 583899 VND 
 USD $22.00 611699 VND 
 USD $23.00 639499 VND 
 USD $24.00 667299 VND 
 USD $25.00 695099 VND 
 USD $26.00 722899 VND 
 USD $27.00 750799 VND 
 USD $28.00 778599 VND 
 USD $29.00 806399 VND 
 USD $30.00 834199 VND 
 USD $31.00 861999 VND 
 USD $32.00 889799 VND 
 USD $33.00 917599 VND 
 USD $34.00 945399 VND 
 USD $35.00 973199 VND 
 USD $36.00 1000999 VND 
 USD $37.00 1028799 VND 
 USD $38.00 1056599 VND 
 USD $39.00 1084399 VND 
 USD $40.00 1112199 VND 
 USD $41.00 1139999 VND 
 USD $42.00 1167799 VND 
 USD $43.00 1195599 VND 
 USD $44.00 1223399 VND 
 USD $45.00 1251199 VND 
 USD $46.00 1278999 VND 
 USD $47.00 1306799 VND 
 USD $48.00 1334599 VND 
 USD $49.00 1362399 VND 
 USD $50.00 1390199 VND 
 USD $60.00 1668299 VND 
 USD $70.00 1946299 VND 
 USD $80.00 2224299 VND 
 USD $90.00 2502399 VND 
 USD $100.00 2780399 VND


# [Garmin Brand Guidelines](https://developer.garmin.com/brand-guidelines/overview/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Overview Developer Guidance for Garmin Branding Integration
 As developers partnering with Garmin, you can help us achieve our common goal of delivering best-in-class solutions that allow our customers to make the most of the time they spend pursuing their passions. By marketing and promoting your innovations using Garmin's developer programs, you can drive awareness of your relationship with Garmin and create more engagement with your customer experience. Please use the following Garmin brand guidelines and imagery provided at the links below to effectively and accurately present Garmin’s brands to your customers. Consumer Style Guide The Garmin Consumer Brand Style Guide is a valuable resource for designers and developers who wish to integrate the Garmin brand into their affiliated products. You’ll find guidance for logo use, typefaces, colors, iconography, photography, tone of voice and more in this comprehensive guide. Garmin Connect Guidelines Garmin Connect is the one-stop source for health and fitness data. You can use Garmin Connect imagery to represent the API integrations you enable for your customers by following the guidelines for color, typefaces, logos and other imagery found here. Connect IQ Guidelines Connect IQ enables developers to build unique wearable, cycling computer and outdoor handheld experiences leveraging Garmin device sensors and features. Promote the Connect IQ apps you develop using the guidance found here. Garmin Pay Guidelines Garmin Pay is a contactless payment solution designed for people who are always on the move. If your product is aligned with the innovative Garmin Pay feature, these are the images, guidelines and more that you need to highlight your Garmin Pay implementation or enablement. Garmin Ready Guidelines The Garmin Ready™ program provides you with a way to communicate to your customers hardware that is compatible with select Garmin products through a certified process. If approved, these are the digital assets and logos to communicate that your approved products are Garmin Ready. By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .


# [Garmin Connect](https://developer.garmin.com/brand-guidelines/connect/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Garmin Connect Brand Images
 Download all official Garmin Connect brand logos and badges. Download Garmin Connect Brand Guidelines
 For licensees with a commercially available integration of the Garmin Connect portfolio of APIs, you can use the guidelines and images provided here to represent your integration with Garmin Connect to your customers. By including this imagery in your digital and printed marketing materials, you create a clear call to action for your customers to connect their Garmin Connect account with your app or platform. Please do not alter these images. Colors
 Three colors are approved for use in the Garmin Connect IQ logo. &nbsp; Blue
 Hex: #11A9ED &nbsp; Black
 Hex: #000000 &nbsp; White
 Hex: #FFFFFF Two colors are approved for use in the Garmin Connect IQ badges and tile. &nbsp; Blue
 Hex: #11A9ED &nbsp; Dark Gray
 Hex: #494848 Logos
 Blue Reversed Black Badges
 The “download…” badge can be used for promoting the mobile app. Minimum height 88px The “works with…” badge can be used to promote products that are compatible with Garmin Connect. Minimum height 88px Tile
 Use the Garmin Connect tile to promote the app or when showing the app on a mobile phone screen. Minimum height 88px Dynamic URLs
 Garmin Connect developer images are also available in URL versions. We encourage developers to use these URLs in your work. They will dynamically pull in the most recent icons and badges to assure that your app is always using the latest assets. iOS https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/gc-app-tile_iOS.pdf Android https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/hdpi/gc-app-tile_@180.png https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/mdpi/gc-app-tile_@120.png https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/xhdpi/gc-app-tile_@240.png https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/xxhdpi/gc-app-tile_@360.png https://static.garmincdn.com/com.garmin.connect/content/images/developer/gc-app-tile/xxxhdpi/gc-app-tile_@480.png Questions?
 For further guidance on Garmin Connect brand guidelines, contact us . By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .


# [Garmin Connect IQ](https://developer.garmin.com/brand-guidelines/connect-iq/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Garmin Connect IQ Brand Images
 Download all official Garmin Connect IQ brand logos and badges. Download Garmin Connect IQ Brand Guidelines
 A successful Connect IQ app requires more than just great functionality. It also needs memorable branding and iconography to appeal to customers. The following guidelines will help you accomplish that. As you develop apps for the Connect IQ store and Garmin products, these guidelines will help you promote them and their relationship with Connect IQ effectively. By including Connect IQ imagery in your marketing materials, you can promote your app's availability in the Connect IQ store, as well as its compatibility with Garmin products. Please do not alter any Connect IQ brand images. Colors
 Three colors are approved for use in the Garmin Connect IQ logo. &nbsp; Blue Hex: #109AD7 CMYK: 76,25,0,0 Pantone 2925C &nbsp; Black Hex: #000000 CMYK: 40,30,30,100 &nbsp; White Hex: #FFFFFF CMYK: 0,0,0,0 Logos
 Two logos are approved to use for the Garmin Connect IQ logo. There are also reversed versions of the logo to be paired with dark backgrounds. Full Color One Color Badges
 The badge can be used to promote apps that are compatible and available on the Connect IQ store app and website. Dark Badge Light Badge App Tile
 Use the Garmin Connect IQ tile to promote the app or when showing the app on a mobile phone screen. App Store Assets
 When it comes to promoting your specific Connect IQ applications, the Connect IQ store allows you to upload various assets. Asset Attributes: 500px x 500px, Color space: sRGB The most effective asset for promoting your application is the app icon. This icon will display in the app lists throughout Connect IQ and in search results. Allow 10px of padding between the edge of the image to place focus on the icon. Center the icon in the allowed space and do not stretch, compress or skew the image. When choosing an icon design, simpler is usually better. Images that are complex or contain a lot of details can be hard to discern at smaller sizes. Instead, choose a simple, compelling image that best represents your application. Here are some other design best practices to keep in mind for your icon: Do not choose black or transparent backgrounds (transparent backgrounds allow the Connect IQ background color to show)
 Choose a simple, solid background color that puts the emphasis on your app icon
 Steer clear of descriptive text anywhere on the icon
 Do not use clip art
 Avoid fine details like shimmer or shadows
 You cannot use any elements of Garmin branding in your icon without express permission from Garmin

 For watch faces, using a preview of the watch face as the app icon often works best. For data fields, apps and audio content providers, focus on providing a consistent brand identity in your app icon. On Device App Icon
 Icon Attributes: 128px x 128px, Color space: sRGB If desired, you can also provide an app icon for the Connect IQ store experience on Garmin devices. The store allows for a full-color icon for devices with OLED displays and a low-color icon for devices with memory-in-pixel displays. When creating a low-color image, limit yourself to the 64-color palette . MIP AMOLED Hero Images
 Hero Image Dimensions: 1440 x 720px App hero images offer a compelling way to bring more attention and focus to your app. You can further reinforce your app's branding and function with effective use of photography, illustrations and more. If your hero image contains text callouts or captions, it's best to upload separate images in different languages to communicate with all potential customers. Questions?
 If you need further guidance on the Garmin Connect IQ brand guidelines discussed here, feel free to contact us . By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .


# [Garmin Pay](https://developer.garmin.com/brand-guidelines/pay/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Garmin Pay Request Brand Assets
 Send us a request to download all official Garmin Pay brand logos and other assets. Request Assets Garmin Pay Brand Guidelines
 If your financial institution or product enables Garmin Pay, you can promote that integration using official Garmin Pay guidelines and images. Click “Request Assets” at right to gain access to the following Garmin Pay assets: Garmin and Garmin Pay logos
 Garmin Pay branding guidelines
 Garmin wearable device image customizable template
 Lifestyle imagery
 Garmin Pay mobile app screens
 Garmin Pay press release

 By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .


# [Garmin Logo](https://developer.garmin.com/brand-guidelines/logo/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Garmin Logo Using the Garmin Logo
 The Garmin Consumer Brand Style Guide has been created for Garmin global markets and third-party partners to aid in the development of consumer-facing advertising and marketing materials. Here, you will find guidance for logo use, typefaces, colors, iconography, photography and tone of voice. By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .


# [Garmin Ready](https://developer.garmin.com/brand-guidelines/ready/)nGuidelines for Garmin Brands 
 Overview 
 

 Garmin Connect 
 

 Garmin Connect IQ 
 

 Garmin Pay 
 

 Garmin Logo 
 

 Garmin Ready 
 


 Menu Garmin Ready Request authorization to access digital brand assets.
 Request Authorization Garmin Ready Brand Guidelines
 Garmin Ready provides you with a way to clearly communicate to your current and prospective customers that your hardware is compatible with Garmin ® devices. It takes out the guess work by signifying to a customer that the product they are purchasing (such as an eBike) will ‘talk’ to their Garmin device. Click “Request Authorization” to the right to gain access to the digital assets including brand guidelines needed to communicate products that are Garmin Ready. These assets can be used on website product pages, marketing or social content, printed material, stickers, or labels on bikes/packaging at the retail level so you can clarify the compatibility and take out the guess work for you and your customers. For more information, please visit the Garmin Ready website and the Support and FAQ page . By downloading any files from this page, you agree to the Garmin Confidentiality Agreement &amp; Terms of Use .

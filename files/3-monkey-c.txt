https://developer.garmin.com/connect-iq/monkey-c/

Hello Monkey C!
Code Monkey get up get coffee...
There is no better way to learn Monkey C than by jumping right in. Let’s take a look at the application object of a watch face.

using Toybox.Application as App;
using Toybox.System;

class MyProjectApp extends App.AppBase {

    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView() {
        return [ new MyProjectView() ];
    }
}
If this looks familiar and non-threatening, that’s the point. Monkey C is intended to be the language you didn’t know you already knew.

At the top is a using statement, which is analogous to C++’s using statement, or an import in Java™, Ruby, or Python™. using statements lexically bring modules into our name space. After a using clause, we can refer to a module by its shortened name (in this case System). Toybox is the root module for Monkey C system modules; all the cool toys are kept in there.

To print out values to the debug console, use:

System.println( "Hello Monkey C!" );
System refers to the Toybox.System module we imported with the using statement. Unlike Java namespaces, modules in Monkey C are static objects that can contain functions, classes, and variables. The println() function should be familiar to Java programmers—it prints a string and automatically adds a new line. The System module has a number of useful functions:

print and println send output to the console
getTimer returns the current millisecond timer. The value is a 32 bit integer representing the number of milliseconds the system has been running. The value can be used for timing but is allowed to roll over.
getSystemStats provides statistics from the runtime system
exit will terminate your application
error will exit your application while logging an error message
Differences From Other Languages
As Italian and Spanish derive from Latin, Monkey C derives heavily from other popular languages. C, Java™, JavaScript, Python™, Lua, Ruby, and PHP all influenced the design for Monkey C. If you are familiar with any of those languages, Monkey C should be easy to pick up.

Java
Like Java, Monkey C compiles into byte code that is interpreted by a virtual machine. Also like Java, all objects are allocated on the heap, and the virtual machine cleans up memory (Java through garbage collection, Monkey C through reference counting). Unlike Java, Monkey C does not have primitive types—integers, floats, and chars are objects. This means primitives can have methods just like other objects.

While Java is a statically typed language, Monkey C is duck typed. In Java, the developer must declare the types for all parameters of a function, and declare the return value type. The Java compiler checks these at compile time to ensure type safety. Duck typing is the concept of “if it walks like a duck, and quacks like a duck, then it must be a duck”[1]. For example:

function add( a, b ) {
    return a + b;
}

function thisFunctionUsesAdd() {
    var a = add( 1, 3 ); // Return  4
    var b = add( "Hello ", "World" ); // Returns "Hello World"
}
The Monkey C compiler does not verify type safety, and instead causes a runtime error if a function mishandles a method.

Monkey C modules serve a similar purpose as Java packages, but unlike packages, modules can contain variables and functions. It is common for static methods to exist in the module as opposed to a particular class.

Lua/JavaScript
The main difference between JavaScript or Lua and Monkey C is that functions in Monkey C are not first class. In JavaScript, a function can be passed to handle a callback:

function wakeMeUpBeforeYouGoGo() {
    // Handle completion
}

// Do a long running thing, and pass callback to call when done.
doLongRunningTask( wakeMeUpBeforeYouGoGo );
In Lua, to create an object, you bind functions to a hash table:

function doSomethingFunction( me ) {
    // Do something here
}

// Constructor for MyObject
function newMyObject() {
    local result = {};
    result["doSomething"] = doSomethingFunction;
}
Neither of these techniques works in Monkey C, because functions are bound to the object they are created in.

To create a callback in Monkey C, create a Method object. Method objects are a combination of the function and the object instance or module they originate from.

Ruby, Python, and PHP
Objects in Ruby and Python are hash tables, and have many of the properties of hash tables. Functions and variables can be added to objects at run time.

Monkey C objects are compiled and cannot be modified at runtime. All variables have to be declared before they can be used, either in the local function, the class instance, or in the parent module.

When importing a module, all classes inside the module have to be referenced through their parent module. You import modules, not classes, into your namespace.

This is different than Monkey Typing, where a thousand monkeys over infinite time write the works of Shakespeare.  ↩

--

https://developer.garmin.com/connect-iq/monkey-c/objects-and-memory/

Objects, Modules, and Memory
Objects are created with the class keyword. Classes allow data and operations to be bound together on an object. In Monkey C, variables, functions, and other classes can be defined within a class.

Constructors
When an object is instantiated with the new keyword, the memory is allocated and the initialize method is called:

class Circle
{
    protected var mRadius;
    public function initialize( aRadius ) {
      mRadius = aRadius;
    }
}

function createCircle() {
    var c = new Circle( 1.5 );
}
Within a method implementation you can refer to your current instance using either the self or me keywords.

class A
{
    public var x;
    public var y;
    public function initialize() {
        me.x = "Hello"; // Set current instance x variable
        self.y = "Hello"; // Set current instance y variable
    }
}
To instantiate an inner class of nested classes, you must first instantiate the outer class. However, unlike Java, nested classes in Monkey C do not have access to the members of the enclosing class.

Inheritance
Monkey C uses the extends keyword to support class inheritance:

import Toybox.System;

class A
{
    function print() {
        System.print( "Hello!" );
    }
}

class B extends A
{

}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints "Hello!"
}
You can call superclass methods by using the super class’s symbol:

import Toybox.System;

class A
{
    function print() {
        System.print( "Hello!" );
    }
}

class B extends A
{
    function print() {
        // Call the super class implementation
        A.print();

        // Amend the output
        System.println( "Hola!" );
    }
}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints "Hello! Hola!"
}
Data Hiding
Class members have three levels of access — public, protected, and private.

public is the default, but it can also be explicitly specified. When the public access modifier is used for an enum, variable, or function, those members are visible to all other classes.

The private modifier specifies that the member can only be accessed in its own class.

The protected modifier specifies that the member can only be accessed by its own class or one of its subclasses. The hidden keyword is synonymous with the protected keyword.

import Toybox.System;

class Foo
{
    public var publicVar;
    protected var _protectedVar
    private var _privateVar;

    public function initialize() {
        publicVar = "a";
        _protectedVar = "b";
        _privateVar = "c";
    }
}

class Bar extends Foo {
    public function initialize() {
        // Initialize the parent
        Foo.initialize();
        publicVar = "b";
        _protectedVar = "c";
        // Error - can't access private member
        _privateVar = "d";
    }
}

function usageSample() {
    var v = new Foo();
    System.println( v.publicVar );
    // Error - cannot access protected member
    System.println( v._protectedVar );
    // Error - cannot access private member
    System.println( v._privateVar );
}
Polymorphism
Most object-oriented languages support a concept of polymorphic functions in which a function can have multiple definitions based on the input parameter quantity and type. Partially because of its duck-typed nature, Monkey C does not support this kind of runtime polymorphism.

Because function parameters are duck typed, it is possible to implement some level of polymorphism using the instanceof operator:

import Toybox.Lang;

function aPolymorphicFunction(a) {
    switch(a) {
        case instanceof String:
            return doTheStringVersion(a);
        case instanceof Number:
        case instanceof Long:
            return doTheNumericVersion(a);
        default:
            throw new UnexpectedTypeException();
    }

}
This kind of pattern works when the function expects the same number of inputs. If your function needs to expect multiple inputs, another pattern is to use the options dictionary. You can use symbols to define the keys to maximize processing efficiency:

x = aPolymorphicFunction({
    :param1=>"Foo",
    :param2=>"Bar"
})
This pattern is good when you want to leave room for an API to expand in the future.

Strong and Weak References
Monkey C is reference counted, which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly which is important in low memory environments. The kryptonite of reference counting are circular references. A circular reference happens when a cycle is formed in the reference chain. For example, imagine object C references object A, object A references object B, and object B references object A.


Now C gets invited to sit at the cool-kid table, so it dereferences A so it can hang out with its real friends.[1]


This forms a roundabout to nowhere. The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other. The memory used by A and B are now unavailable to objects from the cool-kids table.

Sometimes B really does need to reference A. In these cases, you can use a weak reference. A weak reference is an object that keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled.


To create a weak reference you use the weak() method. Weak is a method in Lang.Object and is available to all Monkey C objects.

// I would make a "Hans and Franz" reference but I
// think certain advertising has made them uncool.
var weakRef = obj.weak()
If you are calling weak on one of the immutable types (Number, Float, Char, Long, Double, String), then it returns the object itself. Otherwise it will return a WeakReference instance.

//! A weak reference is a loosely bound reference to
//! another object. If all strong references have been
//! freed, the get() method will return null.
//! This allows the developer to avoid circular references.
//! @since 1.2.0
class WeakReference
{
    //! Return if the reference is still alive.
    //! @return true if object is still alive, false otherwise.
    //!    When you are dead I will be STILL ALIVE
    //!    I feel fantastic and I am STILL ALIVE
    function stillAlive();

    //! Get the object referenced.
    //! @return Object referenced, or null if object is no
    //!         longer alive.
    function get();
}
You can use the stillAlive method to check if the reference has been cleaned up. Use get to create a strong reference to the object. Only keep the strong reference during the scope you need it!

// This is a triumph...
if( weakRef.stillAlive() ) {
    var strongRef = weakRef.get();
    strongRef.doTheThing();
}
Handles and Heap Allocation
The heap memory limit varies on a per device basis. Starting with version 2.4.x, Connect IQ uses a dynamically allocated heap for memory handles. Each unique object takes up one memory handle. Object references do not have unique allocations and only reference the memory handle of the object. Older versions of Connect IQ have a smaller, static limit for objects defined by the device. Reaching the object limit in either version will cause a runtime error.

Modules
Modules in Monkey C allow for the scoping of classes and functions. Unlike Java packages, Monkey C modules have many of the same properties as classes. You can have variables, functions, classes, and other modules at the module level:

module MyModule
{
    class Foo
    {
        var mValue;
    }
    var moduleVariable;
}

function usageSample() {
    MyModule.moduleVariable = new MyModule.Foo();
}
However, unlike classes in Monkey C, modules have no concept of inheritance or data hiding (the extends, private, and protected keywords are not supported for modules).

Import and Using Statements
You can bring a module into your scoping level with the import keyword. When you use import it will bring the module suffix and all classes in the module into the type namespace. This allows classes in a module to be accessed without the module suffix, making for easier typing. Function invocations still require the module suffix to be accessed.

import Toybox.Lang;
import Toybox.System;

// Import lets you say goodbye to
// module prefixes
var globalX as Number or String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = "2"; // Allowed
    // Still require prefixes in code
    System.println("globalX = " + globalX);
}
You can also bring a module into your scoping level with the using keyword. using allows a module to be imported into another class or module by a symbol:

using Toybox.System;

function foo() {
    System.print( "Hello" );
}
The as clause provides a way to assign a module to a different name within scope. This is useful for shortening module names or when you simply disagree with our naming scheme:

using Toybox.System as Sys;

function foo() {
    Sys.print( "Hello" );
}
using statements are scoped to the class or module in which they are defined.

The difference between import and using is subtle. import brings the module name and class names into the namespace, where using only brings the module name into the namespace. If you are using monkeytypes you should use import exclusively, as it will save you a lot of redundant module references. Finally, the as clause is only supported for using statements.

Scoping
Monkey C is a message-passed language. When a function is called, the virtual machine does a look up operation at runtime to find the function being called. Here is the hierarchy that it will search:

Instance members of the class
Members of the superclass
Static members of the class
Members of the parent module, and the parent modules up to the global namespace
Members of the superclass’s parent module up to the global namespace
For example, if function a() is called on an instance of Child(), it will be able to access non-member functions b(), c(), and d() when:

b() is a member of the parent module of the object
c() is a static member of the object
d() is a member of the parent module of the parent module, also known as the globals module
The code below tries to clarify:

import Toybox.System;

// A globally visible function
function d() {
    System.print( "this is D!" );
}

module Parent
{
    // A module function.
    function b() {
        System.print( "This is B!" );
        d(); // Call a globally visible function
    }

    // A child class of a Parent module
    class Child
    {
        // An instance method of Child
        function a() {
            System.print( "This is A!" );
            b(); // Call a function in our parent module
            c(); // Call a static function within the class.
            d(); // Call a globally visible function.
        }

        // A static function of Child.
        // Note that static methods can't call instance method but still have
        // access to parent modules.
        static function c() {
            System.print( "This is C!" );
            b(); // Call a method in the parent module.
            d(); // Call a globally visible function
        }
    }
}
Sometimes you want to run your search from the global namespace instead of your current scope. You can do this using the bling symbol $. The bling symbol refers to global scope:

function helloFunction() {
    System.println("Hello Hello");
}

class A {
     function helloFunction() {
        System.println("Every time I say goodbye you say hello");
     }

    function b() {
        // Call global helloFunction
        $.helloFunction();
        // Call instance helloFunction
        helloFunction();
    }
}
If you are referring to a global variable, using bling can improve runtime performance[2]:

var globalScopedVariable = "Global String";

module A
{
    class B
    {
        function c() {
            // To find globalScopedVariable, the VM will search at runtime:
            //     instance B
            //     instance B's superclass Toybox.Lang.Object
            //     Module A
            //     Module A's parent globals
            // and finally find globalScopedVariable.
            System.println(globalScopedVariable);
            // This will search only the global namespace for globalScopedVariable.
            // Thanks bling!
            System.println($.globalScopedVariable);
        }
    }
}
Because Monkey C is dynamically typed, referencing a global variable will search your Object’s inheritance structure and the module hierarchy before it will eventually find the global variable. Using the bling symbol we can search globals directly.

Not that this ever happened to the author.  ↩

Do not forget to match your bling with pieces of flair; you can’t have enough of either.  ↩

--

https://developer.garmin.com/connect-iq/monkey-c/functions/

Functions
Functions are the meat[1] of your program. Functions define discrete callable units of code.

Monkey C functions can take arguments, but because Monkey C is a dynamically typed language the argument types is not declared; just its name. Also, it is not necessary to declare the return value of a function, or even if a function returns a value, because all functions return values.

Functions can exist in a class or module, or appear in the global module.

Variables, Expressions, and Operators
The basic types supported by Monkey C are:

Integers - 32-bit signed integers
Floats - 32-bit floating point numbers
Longs – 64-bit signed integers
Doubles – 64-bit floating point numbers
Booleans - true and false
Chars - Unicode characters
Strings - strings of characters
Objects – Instantiated objects (defined with the class keyword)
Arrays - Allocated with the syntax new [X] where ‘X’ is an expression computing the size of the array
Dictionaries - Associative arrays, allocated with the syntax {}
Keywords
Here is a list of keywords in the Monkey C programming language. You cannot use any of the following as variables or symbols in your programs. The keywords native and alias are reserved, even though it is not currently used. true, false, null, NaN, new, and, and or might seem like keywords, but they are actually literals and operators; you cannot use them as identifiers in your programs.

as	const	enum	has	module	self	using
break	continue	extends	hidden	private	static	var
`case	default	finally	if	protected	switch	while
catch	do	for	instanceof	public	throw
class	else	function	me	return	try
Declaring Variables
All local variables must be declared ahead of time using the var keyword. In the Monkey C language, all values (including numeric values) are objects.

var n = null;               // Null reference
var x = 5;                  // 32-bit signed integers
var y = 6.0;                // 32-bit floating point
var l = 5l;                 // 64-bit signed integers
var d = 4.0d;               // 64-bit floating point
var bool = true;            // Boolean (true or false)
var c = 'x';                // Unicode character
var str = "Hello";          // String
var arr = new [20 + 30];    // Array of size 50
var dict = { x=>y };        // Dictionary: key is 5, value is 6.0
var z = arr[2] + x;         // Null pointer waiting to happen
Monkey C supports the following operators:

Precedence	Operator	Description
1	new	creation
!	logical NOT
~	bitwise NOT
( )	function invocation
2	*	multiplication
/	division
%	modulo
&	bitwise AND
<<	left shift
>>	right shift
3	+	addition
-	subtraction
|	bitwise OR
^	bitwise XOR
4	<	less than
<=	less than or equals
>	greater than
>=	greater than or equals
==	equals
!=	not equals
5	&&	logical AND
and	
6	||	logical OR
or	
7	?:	conditional
Symbols
Symbols are lightweight constant identifiers. When the Monkey C compiler finds a new symbol, it will assign it a new unique value. This allows symbols to be used as keys or constants without explicitly declaring a const or enum:

var a = :symbol_1;
var b = :symbol_1;
var c = :symbol_2;
Sys.println( a == b );  // Prints true
Sys.println( a == c );  // Prints false
Symbols can be useful when wanting to create keys without having to declare an enum:

var person = { :firstName=>"Bob", :lastName=>"Jones" };
Constants
Constants are named, immutable values declared with the const keyword. These are useful for storing unchanging values that may be used repeatedly throughout code. Constants must be declared at the module or class level; they cannot be declared within a function.

Constants support the same types as listed for variables. It is important to note that with data structures like arrays, const functions similar to Java’s final keyword. For example, a const array prevents the array from being replaced by a new instance, but the elements of the array may be modified.

const PI = 3.14;
const EAT_BANANAS = true;
const BANANA_YELLOW = "#FFE135";
Enumerations
Enumerations are explicit or auto-incrementing constant mappings from symbol to integer. Unless explicity set (see the second example), each proceeding symbol is automatically assigned the value of its predecessor plus one, starting with 0. So, in the following example, the symbol Monday is automatically assigned the value 0, Tuesday is assigned 1, and so on. These symbols can be used just like constant variables (which is essentially what they are). Enums must be declared at the module or class level; they cannot be declared within a function.

enum {
    Monday,   // Monday = 0
    Tuesday,  // Tuesday = 1
    Wednesday // Wednesday = 2
    // ...and so on
}
enum {
    x = 1337, // x = 1337
    y,        // y = 1338
    z,        // z = 1339
    a = 0,    // a = 0
    b,        // b = 1
    c         // c = 2
}
Calling Methods and Functions
To call a method within your own class or module, simply use the function call syntax:

function foo( a ) {
    //Assume foo does something really impressive
}

function bar() {
    foo( "hello" );
}
If calling on an instance of an object, precede the call with the object and a ‘.’.

When accessing class members, public and protected variables should be accessed using either one of the following formats:

var x = mMemberVariable;
var y = self.mMemberVariable;
Overridden parent member functions should be accessed using the following syntax:

class A
{
    function overridableMethod() {
        System.println("I am A!");
    }
}

class B extends A
{
    function overridableMethod() {
        System.println("B wins!");
        A.overridableMethod();
    }
}
The syntax of SuperClass.memberVariable is not supported in the Monkey C language. Always use self to access member variables of super classes.

If Statements
if statements allow branch points in your code:

myInstance.methodToCall( parameter );

if ( a == true ) {
    // Do something
} else if ( b == true ) {
    // Do something else
} else {
    // If all else fails
}

// Monkey C also supports the ternary operator
var result = a ? 1 : 2;
The expression inside the if statement is required to be an expression; assignments are not allowed. Things that will evaluate to true are:

true
A non-zero integer
A non-null object
Switch Statements
Like if statements, switch statements also allow branch points in your code. Deciding whether to use if statements or a switch statement is based on readability and the expression that the statement is testing.

A switch statement tests expressions based only on a single object. Like if statements, the expression inside the switch statement is required to be an expression; assignments are not allowed. You can have any number of case statements within a switch statement. Each case is followed by the object or instanceof object to be compared to and a colon:

switch ( obj ) {
    case true:
    // Do something
    break;
    case 1:
    // Do something
    break;
    case "B": {
        // Do something
        break;
    }
    // Executed based on the type
    // instead of the value
    case instanceof MyClass:
    // Do something
    break;
    default:
    // If all else fails
    break;
}

// Monkey C also supports fall-through into the next case statement
switch ( obj ) {
    case false:
    // Do something
    // Fall through and execute the code in the next case block
    case 2: {
        // Do something
        break;
    }
    case instanceof MyOtherClass:
    // Do something
    break;
    case "B":
    // Do something
    // Fall through and execute the code in the default block
    default:
    // If all else fails
    break;
}
The instanceof operator is discussed in more detail later in this guide.

When the object being switched on is either equal to or an instance of the value defined in a case statement, the statements following that case will execute until a break statement is reached. Each break statement terminates the enclosing switch statement. Without a break statement, case statements fall through: all statements after the matching case label are executed in sequence, regardless of the expression of the subsequent case labels, until a break statement is encountered. A final break statement is not required because control flow will just naturally fall out of the switch statement.

A switch statement can also have a single optional default case, which is not required to appear at the end of the switch statement. The default case handles all objects that are not explicitly handled by one of the case statements.

Switch Block Variable Scoping
The body of a switch statement is known as the “switch block”. Variables declared within the switch block will be scoped at the switch block level. Variables defined within curly braces of a case block will be scoped at that code block level. Additionally, due to the nature of fall-through cases, all variables defined at the switch block level must be initialized before being used in any subsequent case statements. For instance:

switch ( obj ) {
    case true:
    var aaa = 1; // Scoped at the switch block level
    ...
    case 1:
    var zzz = aaa; // Results in a compiler error because aaa was not initialized in this case block
    ...
    break;
    case "B": {
       var aaa = true; // Scoped at the code block level within the curly braces, no scoping conflict with variable aaa at the swtich block level
       ...
       break;
    }
    case instanceof MyClass:
    var aaa = "Hello!" // Results in a compiler error because aaa has already been defined in the switch block
    ...
    default:
    aaa = 0; // aaa was defined in the first case and initialized at the beginning of the default case, no errors!
    var good = aaa;
    ...
    break;
}
Loops
Monkey C supports for loops, while loops, and do/while loops. while and do/while loops have a familiar syntax:

// do/while loop
do {
    // Code to do in a loop
}
while( expression );

// while loop
while( expression ) {
    // Code to do in a loop
}
Loops must have braces around them because single-line loops are not supported:

// Monkey C does allow for variable declaration in for loops
for( var i = 0; i < array.size(); i++ ) {
    // Code to do in a loop
}
Control within loops can be managed by using the break and continue statements. These should also have familiar behavior:

// This for loop should only print 5, 6, and 7.
for (var i = 0; i < 10; i += 1) {
    if (i < 5) {
        continue;
    }
    System.println(i);
    if (7 == i) {
        break;
    }
}
Returning Values From Functions
All functions return values in Monkey C. You can explicitly set the return value by using the return keyword:

return expression;
The expression is optional. Functions without a return statement automatically return the last value operated on.

Instanceof and Has
As a duck-typed language, Monkey C gives the programmer great flexibility, but the trade off is that the compiler cannot perform the type checking like in C, C++ or Java. Monkey C provides two tools to do runtime type checking—instanceof and has.

The instanceof operator offers the ability to check if an object instance inherits from a given class. The second argument is the class name to check against:

var value = 5;
// Check to see if value is a number
if ( value instanceof Toybox.Lang.Number )
{
    System.println( "Value is a number" );
}
The has operator lets you check if a given object has a symbol, which may be a public method, instance variable, or even a class definition or module. The second argument is the symbol to check for. For example, assume we have magnetometer libraries in Toybox.Sensor.Magnetometer, but not all products have a magnetometer. Here is an example of changing your implementation based on those criteria:

var impl;
// Check to see if the Magnetometer module exists in Toybox
if ( Toybox has :Magnetometer )
{
    impl = new ImplementationWithMagnetometer();
}
else
{
    impl = new ImplementationWithoutMagnetometer();
}
Monkey C’s object-oriented design patterns in conjunction with the has and instanceof operator enables software that has implementations for many devices in one code base.

Callbacks
Functions in Monkey C are not first class, meaning you cannot pass them as objects directly for use in other functions. However, using the method() function inherited from Toybox.Lang.Object, a class instance can create a Method object, which provides a way to invoke it as a callback method.

class Foo
{
    function operation(a, b) {
        // The code here is really amazing. Like mind blowing amazing. You wish this method was in your program.
    }
}
function usageSample() {
    // Create a new instance of Foo
    var v = new Foo();
    // Get the callback for the operation method from the instance of Foo.
    var m = v.method(:operation);
    // Invoke v's operation method.
    m.invoke(1,2);
}
AMethod object will invoke a method on the instance of the object it came from. It keeps a strong reference to the source object.

Unlike classes, Modules do not inherit from Object so do not have access to the method() function. However, a new instance of Method can be created, which allows module-level functions to be invoked as callbacks in a similar fashion:

import Toybox.Lang;

module Foo
{
    function operation() {
        // Do something
    }
}
function moduleSample() {
    var v = new Method(Foo, :operation);
    v.invoke();
}
Tofu for the vegetarians, BBQ for Kansans…  ↩

--

https://developer.garmin.com/connect-iq/monkey-c/containers/

Containers
Monkey C has two container types built into the language: Arrays and Dictionaries.

Arrays
Arrays in Monkey C, like variables, are typeless, it is not necessary to declare a data type. There are two forms for creating a new array. To create an empty array of a fixed size, use this:

// Create a typeless array
var untypedArray = new [size];
// Create a typed array
var typedArray = new Array<Number>[size];
To pre-initialize an array, this syntax can be used:

// New array. Will be typed as a Tuple
// [Number, Number, Number, Number, Number]
var untypedArray = [1, 2, 3, 4, 5];
// New typed array
var typedArray = [1, 2, 3, 4, 5] as Array<Number>;
Elements are expressions, so multidimensional arrays can be created using this syntax:

var array = [ [1,2], [3,4] ];
Monkey C does not have a direct way of creating an empty two-dimensional array, one may be initialized with this syntax:

// Shout out to all the Java programmers in the house
var array = new [first_dimension_size];

// Initialize the sub-arrays
for( var i = 0; i < first_dimension_size; i += 1 ) {
    array[i] = new [second_dimension_size];
}
Dictionaries
Dictionaries, or associative arrays, are a built-in data structure in Monkey C:

var dict = { "a" => 1, "b" => 2 };  // Creates a dictionary
System.println( dict["a"] );        // Prints "1"
System.println( dict["b"] );        // Prints "2"
System.println( dict["c"] );        // Prints "null"
To initialize an empty dictionary, use the following syntax:

var x = {};                         // Empty dictionary
A type suffix can be added when creating new Dictionary objects:

var x = {} as Dictionary<Symbol, String>;
// Valid
x[:option] = "value";
// Invalid
x["option"] = "value";
By default, objects hash on their reference value. Classes should override the hashCode() method in Toybox.Lang.Object to change the hashing function for their type:

class Person
{
    // Return a number as the hash code. Remember that the hash code must be
    // the same for two objects that are equal.
    // @return Hash code value
    function hashCode() {
        // Using the unique person id for the hash code
        return mPersonId;
    }
}
Dictionaries automatically resize and rehash as the contents grow or shrink. This makes them extremely flexible, but it comes at a cost. Insertion and removal of the contents can cause performance problems if there is accidental or excessive resizing and rehashing. Also, because hash tables require extra space for allocation, they are not as space-efficient as either objects or arrays.

--

https://developer.garmin.com/connect-iq/monkey-c/monkey-types/

Monkey Types
Monkey Types is the gradual type system for the Monkey C language. The type system is designed to recognize Monkey C’s historically duck-typed nature but add the necessary components to type check your applications at compile time.

Monkey Types has the following goals:

Compatibility - Breaking changes to the Monkey C language would require rework to thousands of Connect IQ apps. Monkey Types extends the Monkey C grammar but avoids breaking changes. Monkey Types is also designed to not rely on additional run time information. Because of this, you can use Monkey Types for apps that run on all Connect IQ compatible devices.
Ease of Use - The philosophy of Monkey C is to be the language you didn’t know you already knew. We want the experience of writing Monkey C to be like deja-vu. Likewise, Monkey Types borrows heavily from Kotlin, Swift, and Typescript in its design.
Flexibility - Monkey Types is a gradual type system. You can leave the type scaffolding off if you choose, or you can strictly type your app.
The Connect IQ type checker is disabled by default and is enabled with the -l compiler option. There are four levels of type checking:

Option	Level	Description
-l 0	Silent	No type checking; keep everything dynamically typed
-l 1	Gradual	Type check any statement where typing can be inferred, otherwise stay silent
-l 2	Informative	Type check only what has been typed, warn about ambiguity
-l 3	Strict	Do not allow compiler ambiguity
Let’s cover the new syntax available for communicating type information to the type system.

The as Clause
Monkey Types introduces a new keyword as. You use as to bind a type to a member variable, module variable, function argument, or function return value. Locals are always type inferred at assignment.

Once a type has been bound to a value, the compiler will only allow values of that type to be assigned.

using Toybox.Lang;
using Toybox.System;

var globalX as Lang.Number = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = "2"; // Not allowed
    System.println("globalX = " + globalX);
}
In this example we are declaring that global variable globalX will only accept values of Toybox.Lang.Number. Once that has been declared, the compiler will only allow values of that type to be assigned to globalX.

Since Monkey C is a duck-typed language, only allowing a single type to be bound to a variable would be overly restrictive. An as clause is allowed to have an or clause attached if a variable accepts multiple types.

using Toybox.Lang;
using Toybox.System;

var globalX as Lang.Number or Lang.String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = "2"; // Allowed
    System.println("globalX = " + globalX);
}
The import Statement
In traditional Monkey C, the using statement brings a module suffix into the namespace of the file being processed. To access any functions, variables, or class definitions, the module suffix must be referenced.

For adding type information, all that module prefixing is annoying. Monkey Types introduces the import statement. When you use import it will bring the module suffix and all classes in the module into the type namespace. This allows classes in a module to be accessed without the module suffix, making for easier typing. Functions still require the module suffix to be accessed.

import Toybox.Lang;
import Toybox.System;

// Import lets you say goodbye to
// module prefixes
var globalX as Number or String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = "2"; // Allowed
    // Still require prefixes in code
    System.println("globalX = " + globalX);
}
Note import does not support using as for renaming modules in a source file[1].

Named Versus Anonymous Types
As you can see from the above example, the type system can allow for complicated type definitions. There are times where a type pattern is repeated that you just want to refer to it by a name.

A typedef statement allows you to create a named type in the application namespace. For example, the following would create a poly type named Numeric in the global namespace. The function add then binds Numeric to parameters a and b and its return value by having the as clauses refer to the Numeric type declaration.

import Toybox.Lang;

typedef Numeric as Number or Float or Long or Double;

function add(a as Numeric, b as Numeric) as Numeric {
    return a + b;
}
If you do not wish to name your type declarations, you can always use the as clause to build the type declaration in line as an anonymous type.

Types
Monkey Types allows you to add a layer of type scaffolding to your Monkey C code. The type system allows for a lot more than associating variables with classes.

This section will overview the type declarations you can use.

Any
Any variable, function argument, or function return value that does not have a type bound to it is of type Any. The Any type can be anything, including nothing. Values of type Any follow the traditional duck type rules of Monkey C.

To bind Any to a value, simply do not add an as clause to it’s declaration. There is no keyword to bind Any to a value.

Void
The void type is only for return values, and communicates that a function does not allow return values. It also communicates that a function should not expect a return value by calling this function.

import Toybox.Lang;

function doNothing() as Void {
    // Compiler error - this is failing to
    // do nothing.
    return true;
}

function doSomething() as String {
    // Compiler error - cannot assign value
    // from a function that returns nothing
    var x = doNothing();
    // Compiler error - doSomething should
    // return a String
}
Concrete
Concrete types are a single reference to a declared class in the program namespace. This is the most traditional and most familiar use of typing. If a value is bound to a concrete type, it will only accept values of that class or any derived classes.

import Toybox.Lang;
import WoolMarket;

class Wool {
    public var bagsFull;

    public function initialize(bags as Number) {
        bagsFull = bags;
    }
}

class Sheep {
    public var wool as Wool;

    public function initialize() {
        wool = new Wool(1);
    }
}

class BlackSheep extends Sheep {
    public function initialize() {
        Sheep.initialize();
        wool = new Wool(3);
    }
}

function processSheep(baa as Sheep) {
    if(baa.wool != null) {
        WoolMarket.sellWool(baa.wool);
    }
}

function example() {
    // Allowed
    processSheep(new Sheep());
    processSheep(new BlackSheep());
    // Not allowed
    processSheep(new Wool());
}
Note that concrete types do not implicitly accept null as a value. If you want a value to also accept null you must make a poly type (see Null for more information).

Poly
Poly types allow the concatenation of multiple types into a single type. This allows for the type system to model the duck-type nature of Monkey C. To create a poly type, you simply use the or clause when defining your type.

A poly type will accept:

A value whose type is bound to one of the types within the poly type
A value bound to a poly type whose types are within the definition of the destination type
import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;
typedef Numeric as Number or Float or Long or Double;

function add(a as Addable, b as Addable) as Addable {
    return a + b;
}

function subtract(a as Numeric, b as Numeric) as Numeric {
    return a - b;
}

function doWork() {
    // Allowed
    var x as Addable = add("1", "2");
    // Not allowed; Addable has String which is
    // not within Numeric
    var y as Numeric = subtract(x, 2);
}
Interface
An interface type requires a class to contain a set of member declarations. The members can be member variables and functions.

import Toybox.Lang;

typedef LittleBoys as interface {
    var frogs as Array<Frogs>;
    var snails as Array<Snails>;
    var puppyDogTails as Array<PuppyDogTails>;
};

// Implements LittleBoys interface
class MaleChild {
    var frogs as Array<Frogs>;
    var snails as Array<Snails>;
    var puppyDogTails as Array<PuppyDogTails>;
}
Note that the class does not require additional decoration to implement the interface. This allows anonymous interfaces to be defined within function arguments.

// Processing
function example(you as interface {
    var frogs as Array<Frogs>;
})
Container
The Monkey C language has two native container types, Array and Dictionary. While the Monkey Types system does not support generics, it does allow for the developer to type the value type of an Array or the key and value type of a Dictionary.

import Toybox.Lang;

typedef ContainerA as Array<Number>;
typedef ContainerB as Dictionary<String, Number>;
Container types only match other container types if both the key and value types are equivalent. An Array<String> only matches an Array<String> and not an Array<String or Number>.

Monkey C does not infer container types at this time, so you will need to declare your containers. If you want to create a new typed array or dictionary you can use the following syntax:

class ContainerClass {
    // Array of 10 items that takes only numbers
    var typedArray as Array<Number> = new Array<Number>[10];
    // Initialized array
    var initializedArray as Array<Number> = [1, 2, 3, 4, 5] as Array<Number>;
    // Initialized dictionary
    var initializedDictionary as Dictionary<String, String> = {"this"=>"that"} as Dictionary<String, String>;
}
Tuples
A common pattern in Monkey C is to use arrays as structured groupings. Monkey types allows modeling an array by binding the indexed items to types.

Think of Tuple types like Dictionary types, except the key is implied by the order. In the following example, the array being returned is automatically typed as a Tuple of types [ StartView, StartDelegate]. This is typed against the allowed return value [Views, InputDelegates] and found to match:

function getInitialView() as [Views] or [Views, InputDelegates] {
    return [ new StartView(), new StartDelegate() ] ;
}
The rules of Tuple type A matching Tuple type B are as follows:

Tuple A and B must be the same length
For every index, every type in A must be an instance of B
Arrays created with the [ value, value...] syntax will now be typed as a Tuple instead of an Array<Any>. You can use Container types if that better matches the pattern you are implementing, but Tuples have a natural compatibility with Container types. Tuples of type [A, B, C] shall be instance of Array<A or B or C> if the types A, B, and C are in the polytype definition of the container type.

function sumArray(x as Array<Numeric>) as Number {
    var result = 0;
    for (var i = 0; i < x.size(); i++) {
        result += x[i];
    }
    return result;
}

function sumThisTuple() as Number{
    // This should pass type checking because the
    // Tuple [Number, Number... ] should be an instanceOf Array<Numeric>
    return sumArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
}

Tuple types are also more mutable. As the underlying array changes, they are modified as long as the type system can keep up. The type system will not track changes to the tuple’s types when passed as an argument to another method.

function foo(x as [Number, Number, Number]) as [Number, Number, Number] {
    x[1] = "Hello"; // Allowed, type is now [Number, String, Number]
    return x; // Error, type mismatch
}
Dictionary
A common pattern in Monkey C is to use an options dictionary as an argument. This allows for extensible APIs. Monkey Types allows modeling an options dictionary by binding key literals to types.

import Toybox.Lang;

function doWork(options as {
    :option1 as String,
    :option2 as {
        "name" as String,
        "value" as Number
    }
})
If a dictionary is declared inline, the compiler will track the types bound to the values, and then type check to see if all the value types match. It will not require all keys to be provided, and it will not error if additional keys are added.

doWork({:option1=>"x", :option3=>true})
Enumerations
Enumerations can now be named types by appending a name to the declaration. Enumeration values will be bound to both their enumeration type as well as their value type.

import Toybox.Lang;

enum Dog {
    SPOT = "Spot",
    LUKE = "Luke",
    POCO = "Poco",
    COMMODORE = "Commodore",
    BINGO = "B_I_N_G_O"
}

function getDogName(dog as Dog) as String {
    // Return the dog name
    return dog.toString();
}
Callback
The base object of Monkey C contains the method method to create Method callback objects[2]. The callback type allows you to type Method objects based on what the expected parameters and return values are.

import Toybox.Lang;

function doWork(
    x as Method(a as Number) as String
) as String {
    return x.invoke(2);
}
Null
Monkey Types treats Null as its own unique type. More importantly, Monkey Types requires explicit declaration if null is an allowed value.

function doWork() as Number or Null
The ? can be used with single type declarations to make it a null accepting poly type.

function doWork() as Number?
Type Matching and Ambiguity
Because of the duck type nature of Monkey C, ambiguity is inherit to Monkey Types. Ideally, type systems would have very clear rules for if a type does or doesn’t match, but Monkey Types has True, False, and Maybe[3].

Assuming we have the following:

var a as A;
var b as B;

a = b; // Is this assigment allowed?
You can use the following table

A↓ B→	Any	Concrete	Poly	Interface	Container	Dictionary	Enum	Callback	Null
Any	True	True	True	True	True	True	True	True	True
Concrete	Maybe	True if B is or extends A	Maybe if one of the poly types in B matches A, False otherwise	False	Maybe if A is a Dictionary or Array	Maybe if A is a Dictionary, False otherwise	True if enum value type matches A, False otherwise	False	False
Poly	Maybe	True if B is a type within A, False otherwise	True if all references exist in both A and B. Maybe if there are some types in B not in A. False if no matching types between B and A	True if B is a type within A, False otherwise	True if B is a type within A, False otherwise	True if B is a type within A, False otherwise	True if B is a type within A, False otherwise	True if B is a type within A, False otherwise	True if B is a type within A, False otherwise
Interface	Maybe	True if B is an object that contains all members of interface A, False otherwise	Maybe if the poly contains a matching type	True if B’s interface contains all members in A.	True if classes Array or Dictionary contains all members of interface, False otherwise	True if class Dictionary contains all members of interface, False otherwise	False	False	False
Container	Maybe	False	Maybe if one of the poly types in B matches A, False otherwise	False	True if container type and key/value types match exactly, False otherwise	False	False	False	False
Dictionary	Maybe	False	Maybe if one of the poly types in B matches A, False otherwise	False	True if all keys match the key type and values match the value type (if applicable), False otherwise	True if all keys match the key type and values match the value type (if applicable), False otherwise	False	False	False
Enum	Maybe	True if value type of enum value B matches concrete type A	Maybe if one of the poly types in B matches A, False otherwise	False	False	False	True if enum types match, false otherwise	False	False
Callback	Maybe	False	Maybe if one of the poly types in B matches A, False otherwise	False	False	False	False	True if function signatures match, False otherwise	False
Null	Maybe	False	Maybe if one of the poly types in B matches A, False otherwise	False	False	False	False	False	True
The type checker can run at three different levels based on your level of comfort with ambiguity.

Silent - Type match failures are marked as errors, but ambiguity is ignored
Warning - Type match failures are marked as errors, and ambiguity is marked as a warning
Error - Type match failures and ambiguity are marked as errors
Compiling a code base with ambiguity muted can find obvious type errors, while compiling code when erroring on ambiguity requires adding type scaffolding throughout the code. Monkey Types is designed to allow you to build towards aggressive typing if you choose to, while still adding value if you don’t.

Typing Within Functions
Up until now we have been explicitly adding type scaffolding. While this makes for very readable and explicit code, it can add lots of boilerplate to implementation.

Unlike with class instance variables, the Monkey Types system will infer the type of a local variable by tracking assignments.

import Toybox.Lang;
import OldMacDonaldsFarm;

function handleDog(dog as Dog, here as Array, there as Array, everywhere as Array) {
    here.add(dog.woofWoof());
    there.add(dog.woofWoof());
    everywhere.add(dog.woofWoof());
}

function handleCat(cat as Cat, here as Array, there as Array, everywhere as Array) {
    here.add(cat.meowMeow());
    there.add(cat.meowMeow());
    everywhere.add(cat.meowMeow());
}

function eieio() {
    var here = [], there = [], everywhere = [];
    // Animal will be typed as a Dog based
    // on the assignment. No need to declare
    // it's type
    var animal = new OldMacDonaldsFarm.Dog();
    // Allowed, animal is currently assigned a Dog value
    handleDog(animal, here, there, everywhere);
    // Animal will now be typed as a Cat based on
    // the assignment
    animal = new OldMacDonaldsFarm.Cat();
    // Allowed, animal is currently assigned a Cat value
    handleCat(animal, here, there, everywhere);
}
The inference will follow through branches. If the type is unclear based on which branch is taken, the type system will make a poly type of the options until the next assignment.

import Toybox.Lang;

function process(a as Boolean) as Boolean? {
    var x = null;

    if(a) {
        x = true;
    }
    // At this point, x is now the poly type
    // Boolean or Null
    return x;
}
When a value has a known type definition, the type checker will validate if method calls are allowed.

import Toybox.Lang;

class A {
    function foo() {};
    function bar() {};
}

function process() {
    var a = new A();
    a.foo(); // Allowed
    a.bar(); // Allowed
    a.fonz(); // Not allowed
}
With container types, it is also possible to bind a type to the initialized value. This will put controls on what can be assigned to the container, but allow the local to have any value.

import Toybox.Lang;

function example() {
    var a = {} as Dictionary<String, String>;
    a["key"] = "value" // <-- Assignments to a's value must obey type

    a = null; // <-- a is Any and can be assigned to null
}
Return Values and Void
By default functions return Any. If you bind a type to a function return value, the type checker will ensure that you return values of that type.

import Toybox.Lang;

function isTrue() as Boolean {
    return "true"; // Not allowed
}
If your function does not have a return value, you can use the Void type. This will ensure the function doesn’t return values and error if a function tries to assign the return value of the function.

Any and Type Ambiguity
Any function parameter without a bound type will be of type Any. The ambiguity of the parameter will percolate to any member it interacts with in an expression. If you provide all type definitions, type checking can protect them from many kinds of common errors. However, just a little ambiguity can prevent any level of checking. Take this example where a function has a result check but does not have a argument type for a.

import Toybox.Lang;

function foo(a) as Integer? {
    // a is of type Any, so Monkey Types can't identify what doThis() is being called
    var x = a.doThis();
    // x is of type Any, so we can't know what the result type is
    var y = x + 3;
    // What is Y? What is Why? What is Love?
    return y;
}
Because a is Any, Monkey Types can’t make any determination on any members of it, and by proxy Monkey Types can’t make determination on the results of accessing those members.

Type Casting
The as keyword can also be used in an expression to type cast a value to another type. This can be useful if the type is not clear to the type system.

import Toybox.WatchUi;

function process(a as View) {
    (a as MyView).specialMyViewMethod();
}
Runtime Type Checking
One of the goals of Monkey Types was to not add any runtime overhead. This allows Monkey Types to work on all Connect IQ compatible products out of the gate, but it does add a cost when it comes to runtime type checking. Put simply: while at compile time you have access to an expressive type system, at runtime instanceof and has have the same limits as they had before. For cases involving poly types of concrete types this can work fine.

import Toybox.Lang;

function example(x as Number or Float) as Boolean {
    switch(x) {
        case instanceof Number:
            doNumberImpl(x);
            break;
        case instanceof Float:
            doFloatImpl(x);
            break;
    }
}
Unfortunately not every scenario can be resolved this way. For example, lets say we had the following scenario:

typedef Nimble as interface {
    function isNimble() as Boolean;
};

typedef Quick as interface {
    function isQuick() as Boolean;
};

function handleCandleStick(jack as Nimble or Quick) {
    if(jack instanceof Nimble and jack instanceof Quick) {
        if(jack.isNimble() and jack.isQuick() and jack has :jumpOverCandleStick) {
            jack.jumpOverCandleStick();
        }
    }
}
In the case of handleCandleStick the interfaces Nimble and Quick are lexical types and only exist at compile time. This will cause a compiler error because instanceof can only be used on concrete classes and not lexical types. In this case we can use has to resolve this issue.

function handleCandleStick(jack as Nimble or Quick) {
    if(jack has :isNimble and jack has :isQuick and jack has :jumpOverCandleStick) {
        if(jack.isNimble() and jack.isQuick()) {
            jack.jumpOverCandleStick();
        }
    }
}
If-Splitting
In languages like Java, an object’s type is assumed to be whatever it was declared to be. This can lead to some very redundant casting or generation of lots of unnecessary locals to communicate to the Compiler that something isn’t what it was declared to be.

public boolean foo(SomeInterfaceType x) {
    if(x instanceof SomeConcreteType) {
        // My life will just be easier if I make
        // a new variable, even though it should
        // be possible to assume that x is
        // a SomeConcreteType
        SomeConcreteType y = (SomeConcreteType)x;
        // Do operations on y
    }
}
The Monkey C type system will take advantage of if-splitting, where the branch expression causes the types for variables to mutate within the true and false cases.

import Toybox.Lang;

public function foo(x as Number?) as Boolean {
    if(x != null) {
        // Within this block assume x is Number and not null
    } else {
        // Within this block assume x is null
    }
}
The ==, !=, and instanceof operators will mutate the types based on the following rules

type	==	!=	instanceof	!instanceof
Any	Ignore	Ignore	Mutate type to instanceof type	Ignore
Concrete	Ignore	Ignore	Mutate type to instanceof type	Ignore
Poly	If == is null, mutate to Null type	if != is null, mutate to poly type minus null.	Mutate type to instanceof type	Mutate type to poly type minus type from instanceof
Interface	Ignore	Ignore	Mutate type to instanceof type	Ignore
Container	Ignore	Ignore	Ignore	Ignore
Dictionary	Ignore	Ignore	Ignore	Ignore
Enum	Mutate to enum value type	Ignore	Ignore	Ignore
Callback	Ignore	Ignore	Ignore	Ignore
Null	Ignore	Ignore	Ignore	Ignore
Expressions can also be modified using the && and || operators. With the && operator, the mutation will carry through the expression, being further modified as the expression continues.

import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    // In the first clause, x is modified to remove the null
    // from the poly type. In the second clause, the new polytype
    // is modified to be a String concrete type.
    if(x != null &&
       x instanceof String) {
        // Within this block assume x is a string
    }
}
With || operators, a new poly type is created with the results of both operations

import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    if(x instanceof Number ||
       x instanceof Float) {
        // Within this block assume x is a Number or Float
    }
}
When if-splitting on member variables, all type mutations will be removed if a function is invoked.

Typing Modules and Classes
Class member variables are bound to type Any by default. Unlike local variables, member variables are not type inferenced based on assignment. Adding type scaffolding to your member variables and names to your enumerations will allow for stronger type checking. Constants are typed based on assignment.

class Example {
    // Member variable
    private var _x as Number = 0;

    // Enum values can be explicitly assigned, or by default will
    // be numerically incremented values.
    enum NamedEnum {
        NAMED_ENUM;
    }

    // Constants assume their type by assignment
    private const _constant = "Constant";
}
If you add type scaffolding, you must either initialize the variable or allow it to be null. The below example will cause a compiler error:

import Toybox.Lang;
import Toybox.System;

// Don't shoot
class Messenger {
    private var _message as String;

    public function shareTheMessage() as Void {
        System.println(_message);
    }
}
The reason for the error is that _message is declared as a String, but left alone it’s initialized as null. Module variables either have to be initialized at declaration or allowed to be null, while object members can be initialized in the initialize function, as well. The following would address the error:

import Toybox.Lang;
import Toybox.System;

// Don't shoot
class Messenger {
    private var _message as String;

    public function initialize() {
       // Initialize message
        _message = "";
    }

    public function shareTheMessage() {
        System.println(_message);
    }
}
Types and Inheritance
When extending classes, the type system will use the following rules:

If you extend a function from a parent with the same number of arguments but do not add type decoration, the types for the arguments and return value will be transferred verbatim from the parent implementation
If you extend a function from a parent with the same number of arguments and add type decoration, you must match the number of arguments and type decoration exactly or the compiler will error
This allows for existing Monkey C code that extends Toybox types to take advantage of type checking without having to add any type decoration.

Application Scope Type Checking
The type checker attempts to validate that any member fetched from a module or class is available in all of the same application scopes as the caller. If the developer is confident their code is application scope safe and the type checker still complains, this check can be disabled for background or glance scopes using the annotations :typecheck(disableBackgroundCheck) or :typecheck(disableGlanceCheck), respectively. To disable checks for both background and glance scopes, use the annotation :typecheck([disableBackgroundCheck, disableGlanceCheck]).

It is understood that this is controversial. First, as has a whole new meaning now in the grammar, and using it for module renaming is confusing. Also, renaming modules in Monkey C has made it really difficult to write good shareable example code because everyone renames every module to their own preference. Yes, Gregorian is a big word and is annoying to type, but thats what we have auto-complete for.  ↩

The method method that returns Method should not be confused with “The Method Method”, my upcoming self help book on evaluating self help books.  ↩

I just met you | and this is crazy | but I’m an Any | so type match? Maybe…  ↩

--

https://developer.garmin.com/connect-iq/monkey-c/exceptions-and-errors/

Exceptions and Errors
Monkey C supports structured exception handling for non-fatal errors from which there can be recovery. The syntax should be familiar for Java and Javascript developers:

try {
    // Code to execute
}
catch( ex instanceof AnExceptionClass ) {
    // Code to handle the throw of AnExceptionClass
}
catch( ex ) {
    // Code to catch all execeptions
}
finally {
    // Code to execute when
}
You can use the throw keyword to throw an exception.

Creating an Exception
If you are creating your own exception, follow these rules:

Extend Toybox.Lang.Exception
Initialize the superclass in the initializer
Assign a string message to the mMessage member variable
For example, an app specific exception can be defined as follows:

class AppSpecificException extends Lang.Exception {
    //! Constructor
    //! @param msg Message explaining cause
    function initialize(msg) {
        Exception.initialize();
        self.mMessage = msg;
    }
}
Errors
Because Monkey C uses dynamic typing, there are many errors for which the compiler cannot check. If the error is of high enough severity, it will raise an fatal API error and cause your app to terminate at runtime. These errors cannot be caught.

Array Out Of Bounds
An attempt is being made to reference an array outside of its allocated bounds
Circular Dependency
There is a loop in the dependency graph of a module or object that prevents a module or object from being constructed
Communications Error
An error has occurred in BLE communications
File Not Found
The app file could not be found, which is usually caused when trying to load a resource from the app file
Illegal Frame
The return address on the stack is corrupted
Initializer Error
An error occurred in an initializer
Invalid Value
An argument passed to a function or method is invalid
Null Reference
A value is being requested from a null value
Out of Memory
Indicates no more system memory is available for allocation
Permission Required
An attempt was made to use a restricted API without permission
Stack Underflow
The stack pointer went past the bottom of the stack memory limit
Stack Overflow
The stack pointer went past the top of the stack memory limit
Symbol Not Found
An attempt was made to access a variable or method that does not exist in the specified object or method
System Error
A generic error used by the Toybox APIs for fatal errors
Too Many Arguments
Too many arguments used by a method, which are currently limited to 10 arguments
Too Many Timers
Too many Timer::Timer objects for the target device were started
Unexpected Type
Indicates an operation being done on a variable that is unsupported by the type; for example, trying to perform a bitwise OR on two string
Unhandled Exception
An Exception was thrown but was not caught by an exception handler
Watchdog Tripped
A Monkey C function has executed for too long; watchdogs prevent a Monkey C program from hanging the system via an infinite loop

--

https://developer.garmin.com/connect-iq/monkey-c/annotations/

Annotations
Monkey C allows associating symbols with class or module methods and variables. These symbols are currently written into the debug.xml file generated by the compiler, but may be used in the future to add new features without changing the Monkey C grammar:

(:debug) class TestMethods
{
    (:test) static function testThisClass( x )
}
The following annotations have special meanings to the Monkey C compiler:

:background
Denotes code blocks available to the Background process.
:debug
Code blocks decorated with this annotation will not be included in release builds at compile time.
:glance
Denotes code blocks available to when running in Glance Mode.
:release
Code blocks decorated with this annotation will not be included in debug builds at compile time.
:test
Denotes test cases that are used as Run No Evil unit tests and are excluded from the application at compile time.
:typecheck
Code blocks decorated with this annotation can direct the type checker to perform / avoid certain checks.
:initialized
Member variables decorated with this annotation directs the type checker that it is safe to assume the variable will be initialized before it is referenced.

--

https://developer.garmin.com/connect-iq/monkey-c/coding-conventions/

Coding Conventions
Here are guidelines for Monkey C code:

Naming
Modules and Classes are camel-cased with the first letter in upper case.
Functions are camel-cased with the first letter always being lower case.
Private class member variables are camel cased with the first character being an underscore (_) and then the first letter lower case.
Public class member variables are camel cased with the first letter lower case.
Module variables should be camel cased with a lower cased first letter
Enums must have a common prefix, e.g. COLOR_RED, COLOR_BLUE.
In POMO (Plain Old Monkey C Objects) it is okay to have all public members.
Source
Put one class per Monkey C source file.
Monkey C code should use spaces aligned four spaces per indent level. The Monkey C editor will automatically convert spaces to tabs and remove trailing white space.
When defining modules, classes, functions, and enums, put the opening brace on the same line as the definition and the closing brace aligned with the first character as the definition.
Definitions
Avoid pure global variables when possible.
Because modules are not purely lexical and have runtime memory cost, putting class definitions into the global module is acceptable.
Avoid having public static members in class definitions; instead move those definitions into the parent module.
In the first line of your class initialize function, always call the superclass initialize.
Sample
Here is a sample:

class SampleName extends Toybox.Application.AppBase
{
    public var publicVar;
    private var _privateVar;

    function initialize() {
        AppBase.initialize();
    }
    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView(){
        return [new SampleNameView(), new SampleNameDelegate()];
    }
 }

--

https://developer.garmin.com/connect-iq/monkey-c/compiler-options/

Compiler Options
The following are command line options for monkeyc :

Short Option	Long Option	Argument	Description
-d	--device	Device identifier	Required for building a device executable. Specifies the device to target.
-e	--package-app	None	Specifies that output is an IQ file for uploading to the app store.
-f	--jungles	Colon separated list of paths to jungle files	Required. Each jungle specifies a project to include, which can include one app project and multiple monkey barrel projects.
-g	--debug	None	Prints the debug output.
-h	--help	None	Prints the help information.
-k	--profile	None	Includes profiler information in the executable. When an executable with profiler information runs on device, the device will generate profiler information that can be analyzed in the simulator.
-l	--typecheck	0 = off, 1 = gradual, 2 = informative, 3 = strict	See the Monkey Types section for more information.
-o	--output	File to output	Required. Specifies the output of the compiler.
-O	--optimization	0 = None, 1 = Basic,2 = Fast Optimizations, 3 = Slow Optimizations, p = Performance Optimizations, z = Code Space Optimizations	Default is 1 for building in debug, and 2 for building in release. The numeric level can be suffixed with the letters, so -O 2pz is an allowed argument.
-r	--release	None	Do not include debug information in PRG.
-t	--unit-test	None	Include unit tests in the build.
-v	--version	None	Prints the compiler version.
-w	--warn	None	Off by default. Displays build warnings generated by the compiler.
-y	--private-key	Path to developer key	Required. Specifies the developer key to use for signing the PRG or IQ file.
Debug Logging
If you encounter a bug with the monkeyc compiler you will need to generate logs to provide with your report. Here are the options to create debug logs:

Long Option	Argument	Description
--debug-log-level	0 = Errors, 1 = Basic Debug, 2 = Intermediate Debug, 3 = Verbose Debug	Specifies the verbosity level for the output.
--debug-log-output	Path to log file to generate	Specifies the path to the log file to create
--debug-log-device	Device identifier	Allows limiting logs to a specific device when building a Monkey Barrel.
Be aware that the log levels include increasingly more information about your source project. If you want to keep your project information private, limit the logging level to 1 or less. More verbosity will make it easier for Garmin to debug any issues.

Feature Control Options
These options are used for controlling different features:

Long Option	Argument	Description
--disable-api-has-check-removal	None	Disables optimizing out API has checks.
--disable-v2-opcodes	None	Disables the generation of V2 opcodes.
Private Options
These options are typically already set and should not be necessary to use:

Short Option	Long Option	Argument	Description
-a	--apidb	Path to api.db	Specifies path to API linking information.
-b	--apimir	Path to api.mir	Specifies path to API type information.
-i	--import-dbg	Path to api.debug.xml	Path to the API debug information.
-p	--project-info	Path to projectInfo.xml	Path to SDK project definitions.
